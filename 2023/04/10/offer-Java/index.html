<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>offer---Java | wBlog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  
  
    <link rel="alternate" href="/atom.xml" title="wBlog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="/localshare/css/share.css">

  
  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">wBlog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/."><i class="fa fa-home"></i> Home</a>
        
          <a class="main-nav-link" href="/archives/"><i class="fa fa-archive"></i> Archive</a>
        
          <a class="main-nav-link" href="/about/"><i class="fa fa-user"></i> About</a>
        
          <a class="main-nav-link" href="/atom.xml"><i class="fa fa-rss"></i> RSS</a>
        
      </nav>
    </div>
    <div id="search-form">
      <div id="result-mask" class="hide"></div>
      <label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label>
      <div id="result-wrap" class="hide">
        <div id="search-result"></div>
      </div>
      <div class="hide">
        <template id="search-tpl">
          <div class="item">
            <a href="/{path}" title="{title}">
              <div class="title">{title}</div>
              <div class="time">{date}</div>
              <div class="tags">{tags}</div>
            </a>
          </div>
        </template>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-offer-Java" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      offer---Java
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2023-04-10T11:13:37.000Z" itemprop="datePublished">2023年04月10日</time>
</span>
      
      
        <span class="article-views">
  <i class="fa fa-views"></i>
  <i id="busuanzi_container_page_pv">
      <i id="busuanzi_value_page_pv"></i>
  </i>
</span>
      
      
<a href="/2023/04/10/offer-Java/#comments" class="article-comment-link">
  
    
    
    
    
    
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


      
    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="Java程序编写和执行流程"><a href="#Java程序编写和执行流程" class="headerlink" title="Java程序编写和执行流程"></a>Java程序编写和执行流程</h2><ol>
<li>编写。 .java结尾的源文件</li>
<li>编译。 对源文件编译成.class， “javac xxx.java”</li>
<li>运行。 “java 字节码文件名”</li>
</ol>
<h2 id="企业真题（一）"><a href="#企业真题（一）" class="headerlink" title="企业真题（一）"></a>企业真题（一）</h2><h3 id="1-一个”-java”源文件中是否可以包括多个类？有什么限制-明-数据"><a href="#1-一个”-java”源文件中是否可以包括多个类？有什么限制-明-数据" class="headerlink" title="1.一个”.java”源文件中是否可以包括多个类？有什么限制(明*数据)"></a>1.一个”.java”源文件中是否可以包括多个类？有什么限制(明*数据)</h3><p>是！</p>
<p>一个源文件中可以声明多个类，但是最多只能有一个类使用public进行声明。<br>且要求声明为public的类的类名与源文件名相同。</p>
<h3 id="2-Java-的优势（阿-巴）"><a href="#2-Java-的优势（阿-巴）" class="headerlink" title="2.Java 的优势（阿**巴）"></a>2.Java 的优势（阿**巴）</h3><ul>
<li>跨平台型</li>
<li>安全性高</li>
<li>简单性</li>
<li>高性能</li>
<li>面向对象性</li>
<li>健壮性</li>
</ul>
<h3 id="3-常用的几个命令行操作都有哪些？-至少4个-（北京数字-）"><a href="#3-常用的几个命令行操作都有哪些？-至少4个-（北京数字-）" class="headerlink" title="3.常用的几个命令行操作都有哪些？(至少4个)（北京数字**）"></a>3.常用的几个命令行操作都有哪些？(至少4个)（北京数字**）</h3><p>略</p>
<h3 id="4-Java-中是否存在内存溢出、内存泄漏？如何解决？举例说明（拼-多）"><a href="#4-Java-中是否存在内存溢出、内存泄漏？如何解决？举例说明（拼-多）" class="headerlink" title="4.Java 中是否存在内存溢出、内存泄漏？如何解决？举例说明（拼*多）"></a>4.Java 中是否存在内存溢出、内存泄漏？如何解决？举例说明（拼*多）</h3><p>存在！</p>
<p>不能举例。</p>
<h3 id="5-如何看待Java是一门半编译半解释型的语言（携-）"><a href="#5-如何看待Java是一门半编译半解释型的语言（携-）" class="headerlink" title="5. 如何看待Java是一门半编译半解释型的语言（携*）"></a>5. 如何看待Java是一门半编译半解释型的语言（携*）</h3><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>特点：关键字都是小写（class,void,static,public）<br>‘const’ 和 ‘goto’ not used but served；true，false，null 不是关键字，为字面量  </p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>命名规则：</p>
<ul>
<li>由 26 个英文字母大小写，0-9 ，_或 $ 组成 </li>
<li>数字不可以开头。</li>
<li>不可以使用关键字和保留字，但能包含关键字和保留字。</li>
<li>Java 中严格区分大小写，长度无限制。</li>
<li>标识符不能包含空格。<br>命名规范：  </li>
<li>包名：多单词组成时所有字母都小写：xxxyyyzzz。<br> 例如：java.lang、com.atguigu.bean</li>
<li>类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz<br> 例如：HelloWorld，String，System 等</li>
<li>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单<br>词首字母大写：xxxYyyZzz<br> 例如：age,name,bookName,main,binarySearch,getName</li>
<li>常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ<br> 例如：MAX_VALUE,PI,DEFAULT_CAPACITY</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>注意：</p>
<ul>
<li>Java 中每个变量必须先声明，后使用。</li>
<li>使用变量名来访问这块区域的数据。</li>
<li>变量的作用域：其定义所在的一对{ }内。</li>
<li>变量只有在其作用域内才有效。出了作用域，变量不可以再被调用。</li>
<li>同一个作用域内，不能定义重名的变量。<br>基本数据类型：包括 整数类型、浮点数类型、字符类型、布尔类型。<br>引用数据类型：包括数组、 类、接口、枚举、注解、记录。</li>
</ul>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="整数类型：byte、short、int、long"><a href="#整数类型：byte、short、int、long" class="headerlink" title="整数类型：byte、short、int、long"></a>整数类型：byte、short、int、long</h3><ul>
<li>定义 long 类型的变量，赋值时需要以”l”或”L”作为后缀。</li>
<li>Java 程序中变量通常声明为 int 型，除非不足以表示较大的数，才使用 long。</li>
<li>Java 的整型常量默认为 int 型。</li>
</ul>
<h3 id="浮点类型：float、double"><a href="#浮点类型：float、double" class="headerlink" title="浮点类型：float、double"></a>浮点类型：float、double</h3><ul>
<li>float：尾数可以精确到 7 位有效数字  </li>
<li>double：精度是 float 的两倍  </li>
<li>定义 float 类型的变量，赋值时需要以”f”或”F”作为后缀。  </li>
<li>Java 的浮点型常量默认为 double 型。<br>注意：</li>
</ul>
<ol>
<li>并不是所有的小数都能可以精确的用二进制浮点数表示。二进制浮点数不能精确的表<br>示 0.1、0.01、0.001 这样 10 的负次幂。（为什么 0.1 + 0.2 不等于 0.3）  </li>
<li>浮点类型 float、double 的数据不适合在不容许舍入误差的金融计算领域。如果需要精确数字计算或保留指定位数的精度，需要使用 BigDecimal 类。</li>
</ol>
<h3 id="字符类型：char"><a href="#字符类型：char" class="headerlink" title="字符类型：char"></a>字符类型：char</h3><ul>
<li>形式 1：使用单引号(‘ ‘)括起来的单个字符。  </li>
<li>形式 2：直接使用 Unicode 值来表示字符型常量：‘\uXXXX’。其中，<br>XXXX 代表一个十六进制整数。例如：\u0023 表示 ‘#’。  </li>
<li>形式 3：Java 中还允许使用转义字符‘\’来将其后的字符转变为特殊字符<br>型常量。 如：’\n’表示换行符</li>
</ul>
<h3 id="布尔类型：boolean"><a href="#布尔类型：boolean" class="headerlink" title="布尔类型：boolean"></a>布尔类型：boolean</h3><ul>
<li>boolean 类型用来判断逻辑条件，一般用于流程控制语句中  </li>
<li>boolean 类型数据只有两个值：true、false，无其它；不可以使用 0 或非 0 的整数替代 false 和 true</li>
</ul>
<h2 id="基本数据类型变量间运算规则"><a href="#基本数据类型变量间运算规则" class="headerlink" title="基本数据类型变量间运算规则"></a>基本数据类型变量间运算规则</h2><h3 id="自动类型提升"><a href="#自动类型提升" class="headerlink" title="自动类型提升"></a>自动类型提升</h3><p>规则：将取值范围小（或容量小）的类型自动提升为取值范围大（或容量大）的类型 。</p>
<ul>
<li>当存储范围小的数据类型与存储范围大的数据类型变量一起混合运算时，会按照其中最大的类型运算  </li>
<li>当 byte,short,char 数据类型的变量进行算术运算时，按照 int 类型处理。</li>
</ul>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>规则：将取值范围大（或容量大）的类型强制转换成取值范围小（或容量小）的类型。<br>转换格式：数据类型 1 变量名 &#x3D; (数据类型 1)被强转数据值; &#x2F;&#x2F;()中的数据类型必须&lt;&#x3D;变量值的数据类型  </p>
<ul>
<li><p>当把存储范围大的值（常量值、变量的值、表达式计算的结果值）强制转<br>换为存储范围小的变量时，可能会损失精度或溢出  </p>
<pre><code>  double d = 1.2;
  int num = (int)d;//损失精度
  int i = 200;
  byte b = (byte)i;//溢出  
</code></pre>
</li>
<li><p>声明 long 类型变量时，可以出现省略后缀的情况。float 则不同。</p>
</li>
</ul>
<h3 id="基本数据类型与-String-的运算"><a href="#基本数据类型与-String-的运算" class="headerlink" title="基本数据类型与 String 的运算"></a>基本数据类型与 String 的运算</h3><p>String 不是基本数据类型，属于引用数据类型  </p>
<ol>
<li>任意八种基本数据类型的数据与 String 类型只能进行连接“+”运算，且结果<br>一定也是 String 类型  </li>
<li>String 类型不能通过强制类型()转换，转为其他的类型；借助包装类的方法<br>才能转</li>
</ol>
<h2 id="常识：进制的认识"><a href="#常识：进制的认识" class="headerlink" title="常识：进制的认识"></a>常识：进制的认识</h2><ul>
<li>熟悉：二进制（以0B、0b开头）、十进制、八进制（以0开头）、十六进制（以0x或0X开头）的声明方式。</li>
<li>二进制的理解<ul>
<li>正数：原码、反码、补码三码合一。</li>
<li>负数：原码、反码、补码不相同。了解三者之间的关系。</li>
<li>计算机的底层是以<code>补码</code>的方式存储数据的。</li>
</ul>
</li>
<li>熟悉：二进制与十进制之间的转换</li>
<li>了解：二进制与八进制、十六进制间的转换</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><blockquote>
<pre><code>+  -  +  -  *  /  %  (前)++  (后)++  (前)--  (后)--  +  
</code></pre>
</blockquote>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>&#x3D;   +&#x3D;、 -&#x3D;、*&#x3D;、 &#x2F;&#x3D;、%&#x3D;<br>① 当“&#x3D;”两侧数据类型不一致时，可以使用自动类型转换或使用强制类型转换原则进行处理。<br>② 支持连续赋值。<br>③ +&#x3D;、 -&#x3D;、*&#x3D;、 &#x2F;&#x3D;、%&#x3D;  操作，不会改变变量本身的数据类型。  </p>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>&#x3D;&#x3D;  !&#x3D;  &gt;   &lt;   &gt;&#x3D;   &lt;&#x3D;  instanceof<br>① instanceof 在面向对象的多态性的位置讲解。<br>② &#x3D;&#x3D;  !&#x3D;  &gt;   &lt;   &gt;&#x3D;   &lt;&#x3D; 适用于基本数据类型。(细节：&gt;   &lt;   &gt;&#x3D;   &lt;&#x3D;不适用于boolean类型)<br>  运算的结果为boolean类型。<br>③ 了解： &#x3D;&#x3D;  !&#x3D;  可以适用于引用数据类型<br>④ 区分：&#x3D;&#x3D; 与 &#x3D;   </p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ol>
<li>&amp; &amp;&amp;  |  ||  ! ^</li>
<li>说明：<br>① 逻辑运算符针对的都是boolean类型的变量进行的操作<br>② 逻辑运算符运算的结果也是boolean类型。<br>③ 逻辑运算符常使用条件判断结构、循环结构中</li>
</ol>
<ul>
<li>区分：&amp; 和 &amp;&amp;<br>1、相同点：两个符号表达的都是”且”的关系。只有当符号左右两边的类型值均为true时，结果才为true。</li>
</ul>
<p>2、执行过程：<br>        1）如果符号左边是true，则&amp; 、&amp;&amp; 都会执行符号右边的操作<br>    2）如果符号左边是false，则 &amp; 会继续执行符号右边的操作，&amp;&amp; 不会执行符号右边的操作<br>3、开发中，我们推荐使用&amp;&amp;  </p>
<ul>
<li>区分：| 和 ||（与&amp; 和 &amp;&amp;类似）</li>
</ul>
<h3 id="位运算符-了解"><a href="#位运算符-了解" class="headerlink" title="位运算符(了解)"></a>位运算符(了解)</h3><ol>
<li><p>&lt;&lt;   &gt;&gt;   &gt;&gt;&gt;   &amp;  |  ^  ~</p>
</li>
<li><p>说明：</p>
</li>
</ol>
<p>① &lt;&lt;   &gt;&gt;   &gt;&gt;&gt;   &amp;  |  ^  ~ ：针对数值类型的变量或常量进行运算，运算的结果也是数值<br>② &lt;&lt; : 在一定范围内，每向左移动一位，结果就在原有的基础上 * 2。（对于正数、负数都适用）；&gt;&gt; : 在一定范围内，每向右移动一位，结果就在原有的基础上 &#x2F; 2。（对于正数、负数都适用）</p>
<ol start="3">
<li>面试题：高效的方式计算2 * 8 ？ （2 &lt;&lt; 3 或 8 &lt;&lt; 1）</li>
</ol>
<h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><ol>
<li><p>(条件表达式)? 表达式1 : 表达式2</p>
</li>
<li><p>说明：<br>① 条件表达式的结果是boolean类型。<br>② 如果条件表达式的结果是true，则执行表达式1。否则，执行表达式2。<br>③ 表达式1 和 表达式2 需要是相同的类型或能兼容的类型。</p>
</li>
</ol>
<p>④ 开发中，凡是可以使用条件运算符的位置，都可以改写为if-else。<br>          反之，能使用if-else结构，不一定能改写为条件运算符。</p>
<p>  建议，在二者都能使用的情况下，推荐使用条件运算符。因为执行效率稍高。  </p>
<h2 id="企业真题（二）"><a href="#企业真题（二）" class="headerlink" title="企业真题（二）"></a>企业真题（二）</h2><h3 id="1-高效的方式计算2-8的值-文-辉、轮-科技"><a href="#1-高效的方式计算2-8的值-文-辉、轮-科技" class="headerlink" title="1. 高效的方式计算2 * 8的值 (文**辉、轮*科技)"></a>1. 高效的方式计算2 * 8的值 (文**辉、轮*科技)</h3><p>使用 &lt;&lt; </p>
<h3 id="2-amp-和-amp-amp-的区别？-恒-电子、-度"><a href="#2-amp-和-amp-amp-的区别？-恒-电子、-度" class="headerlink" title="2. &amp;和&amp;&amp;的区别？(恒*电子、*度)"></a>2. &amp;和&amp;&amp;的区别？(恒*电子、*度)</h3><p>1、相同点：两个符号表达的都是”且”的关系。只有当符号左右两边的类型值均为true时，结果才为true。<br>2、执行过程：<br>  1）如果符号左边是true，则&amp; 、&amp;&amp; 都会执行符号右边的操作<br>  2）如果符号左边是false，则 &amp; 会继续执行符号右边的操作，&amp;&amp; 不会执行符号右边的操作  </p>
<h3 id="3-Java中的基本类型有哪些？String-是最基本的数据类型吗？-恒-电子"><a href="#3-Java中的基本类型有哪些？String-是最基本的数据类型吗？-恒-电子" class="headerlink" title="3. Java中的基本类型有哪些？String 是最基本的数据类型吗？(恒*电子)"></a>3. Java中的基本类型有哪些？String 是最基本的数据类型吗？(恒*电子)</h3><p>8种基本数据类型。（略）</p>
<p>String不是，属于引用数据类型。</p>
<h3 id="4-Java中的基本数据类型包括哪些？（-米）"><a href="#4-Java中的基本数据类型包括哪些？（-米）" class="headerlink" title="4. Java中的基本数据类型包括哪些？（*米）"></a>4. Java中的基本数据类型包括哪些？（*米）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; Java的基础数据类型有哪些？String是吗？（贝壳）</span><br></pre></td></tr></table></figure>

<p>略</p>
<h3 id="5-Java开发中计算金额时使用什么数据类型？（5-到家）"><a href="#5-Java开发中计算金额时使用什么数据类型？（5-到家）" class="headerlink" title="5. Java开发中计算金额时使用什么数据类型？（5*到家）"></a>5. Java开发中计算金额时使用什么数据类型？（5*到家）</h3><p>不能使用float或double，因为精度不高。</p>
<p>使用BigDecimal类替换，可以实现任意精度的数据的运算。</p>
<h3 id="6-char型变量中能不能存储一个中文汉字，为什么？-通快递"><a href="#6-char型变量中能不能存储一个中文汉字，为什么？-通快递" class="headerlink" title="6. char型变量中能不能存储一个中文汉字，为什么？(*通快递)"></a>6. char型变量中能不能存储一个中文汉字，为什么？(*通快递)</h3><p>可以的。char c1 &#x3D; ‘中’;</p>
<p>char c2 &#x3D; ‘a’。</p>
<p>因为char使用的是unicode字符集，包含了世界范围的所有的字符。</p>
<h3 id="7-代码分析-君-科技、新-陆"><a href="#7-代码分析-君-科技、新-陆" class="headerlink" title="7. 代码分析(君*科技、新*陆)"></a>7. 代码分析(君*科技、新*陆)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> s1=<span class="number">1</span>; </span><br><span class="line">s1=s1+<span class="number">1</span>;  <span class="comment">//有什么错？  =右边是int类型。需要强转</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> s1=<span class="number">1</span>;</span><br><span class="line">s1+=<span class="number">1</span>; <span class="comment">//有什么错?   没错</span></span><br></pre></td></tr></table></figure>



<h3 id="8-int-i-x3D-0-i-x3D-i-执行这两句化后变量-i-的值为（-软）"><a href="#8-int-i-x3D-0-i-x3D-i-执行这两句化后变量-i-的值为（-软）" class="headerlink" title="8. int i&#x3D;0; i&#x3D;i++执行这两句化后变量 i 的值为（*软）"></a>8. int i&#x3D;0; i&#x3D;i++执行这两句化后变量 i 的值为（*软）</h3><p>0。</p>
<h3 id="9-如何将两个变量的值互换（北京-彩、中外-译咨询）"><a href="#9-如何将两个变量的值互换（北京-彩、中外-译咨询）" class="headerlink" title="9. 如何将两个变量的值互换（北京*彩、中外*译咨询）"></a>9. 如何将两个变量的值互换（北京*彩、中外*译咨询）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> s1;</span><br><span class="line">s1 = s2;</span><br><span class="line">s2 = temp;</span><br></pre></td></tr></table></figure>



<h3 id="10-boolean-占几个字节（阿-巴）"><a href="#10-boolean-占几个字节（阿-巴）" class="headerlink" title="10. boolean 占几个字节（阿**巴）"></a>10. boolean 占几个字节（阿**巴）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">编译时不谈占几个字节。</span><br><span class="line"></span><br><span class="line">但是JVM在给boolean类型分配内存空间时，boolean类型的变量占据一个槽位(slot，等于4个字节)。</span><br><span class="line">细节：true:1  false:0</span><br><span class="line"></span><br><span class="line">&gt;拓展：在内存中，byte\short\char\boolean\int\float : 占用1个slot</span><br><span class="line">              double\long :占用2个slot</span><br></pre></td></tr></table></figure>



<h3 id="11-为什么Java中0-1-0-2结果不是0-3？（字-跳动）"><a href="#11-为什么Java中0-1-0-2结果不是0-3？（字-跳动）" class="headerlink" title="11. 为什么Java中0.1 + 0.2结果不是0.3？（字*跳动）"></a>11. 为什么Java中0.1 + 0.2结果不是0.3？（字*跳动）</h3><p>在代码中测试0.1 + 0.2，你会惊讶的发现，结果不是0.3，而是0.3000……4。这是为什么？</p>
<p>几乎所有现代的编程语言都会遇到上述问题，包括 JavaScript、Ruby、Python、Swift 和 Go 等。引发这个问题的原因是，它们都采用了<code>IEEE 754标准</code>。</p>
<blockquote>
<p>IEEE是指“电气与电子工程师协会”，其在1985年发布了一个IEEE 754计算标准，根据这个标准，小数的二进制表达能够有最大的精度上限提升。但无论如何，物理边界是突破不了的，它仍然<code>不能实现“每一个十进制小数，都对应一个二进制小数”</code>。正因如此，产生了0.1 + 0.2不等于0.3的问题。</p>
</blockquote>
<p>具体的：</p>
<p><strong>整数变为二进制，能够做到“每个十进制整数都有对应的二进制数”</strong>，比如数字3，二进制就是11；再比如，数字43就是二进制101011，这个毫无争议。</p>
<p><strong>对于小数，并不能做到“每个小数都有对应的二进制数字”</strong>。举例来说，二进制小数0.0001表示十进制数0.0625 （至于它是如何计算的，不用深究）；二进制小数0.0010表示十进制数0.125；二进制小数0.0011表示十进制数0.1875。看，对于四位的二进制小数，二进制小数虽然是连贯的，但是十进制小数却不是连贯的。比如，你无法用四位二进制小数的形式表示0.125 ~ 0.1875之间的十进制小数。</p>
<p>所以在编程中，遇见小数判断相等情况，比如开发银行、交易等系统，可以采用<code>四舍五入</code>或者“<code>同乘同除</code>”等方式进行验证，避免上述问题。  </p>
<h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式) &#123; </span><br><span class="line">  	语句块<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  	语句块<span class="number">2</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="switch-case"><a href="#switch-case" class="headerlink" title="switch-case"></a>switch-case</h3><ul>
<li><p>在特殊的场景下，分支结构可以考虑使用switch-case</p>
<ul>
<li>指定的数据类型：byte \ short \ char \ int ; 枚举类（jdk5.0）\ String (jdk7.0)</li>
<li>可以考虑的常量值有限且取值情况不多。</li>
</ul>
</li>
<li><p>特别之处：case穿透。</p>
</li>
<li><p>在能使用switch-case的情况下，推荐使用switch-case，因为比if-else效率稍高</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">    <span class="comment">//执行语句1</span></span><br><span class="line">    <span class="comment">//break;</span></span><br><span class="line">  <span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">    <span class="comment">//执行语句2</span></span><br><span class="line">    <span class="comment">//break;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">//执行语句2</span></span><br><span class="line">    <span class="comment">//break;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><ul>
<li>凡是循环结构，都有4个要素：①初始化条件 ②循环条件（是boolean类型） ③ 循环体 ④ 迭代条件</li>
<li>应用场景：有明确的遍历的次数。 for(int i &#x3D; 1;i &lt;&#x3D; 100;i++)</li>
</ul>
<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><ul>
<li>应用场景：没有明确的遍历次数。</li>
</ul>
<h3 id="do-while"><a href="#do-while" class="headerlink" title="do-while"></a>do-while</h3><ul>
<li>至少会执行一次循环体。</li>
<li>开发中，使用的较少</li>
</ul>
<h3 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h3><ul>
<li>break在开发中常用；而continue较少使用</li>
<li>笔试题：break和continue的区别。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. break和continue关键字的使用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">				使用范围			在循环结构中的作用					相同点</span></span><br><span class="line"><span class="comment">break:			switch-case</span></span><br><span class="line"><span class="comment">				循环结构中			结束（或跳出）当前循环结构			在此关键字的后面不能声明执行语句。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">continue:		循环结构中			结束（或跳出）当次循环				在此关键字的后面不能声明执行语句。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">2. 了解带标签的break和continue的使用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. 开发中，break的使用频率要远高于continue。  </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Math类的random"><a href="#Math类的random" class="headerlink" title="Math类的random()"></a>Math类的random()</h3><ol>
<li>random()调用以后，会返回一个[0.0,1.0)范围的double型的随机数  </li>
<li>需求：获取一个[a,b]范围的随机整数？<br>(int)(Math.random() * (b - a + 1)) + a</li>
</ol>
<h2 id="企业真题（三）"><a href="#企业真题（三）" class="headerlink" title="企业真题（三）"></a>企业真题（三）</h2><h3 id="1-break和continue的作用-智-图"><a href="#1-break和continue的作用-智-图" class="headerlink" title="1. break和continue的作用(智*图)"></a>1. break和continue的作用(智*图)</h3><p>略</p>
<h3 id="2-if分支语句和switch分支语句的异同之处-智-图"><a href="#2-if分支语句和switch分支语句的异同之处-智-图" class="headerlink" title="2. if分支语句和switch分支语句的异同之处(智*图)"></a>2. if分支语句和switch分支语句的异同之处(智*图)</h3><ul>
<li>if-else语句优势<ul>
<li>if语句的条件是一个布尔类型值，if条件表达式为true则进入分支，可以用于范围的判断，也可以用于等值的判断，<code>使用范围更广</code>。</li>
<li>switch语句的条件是一个常量值（byte,short,int,char,枚举,String），只能判断某个变量或表达式的结果是否等于某个常量值，<code>使用场景较狭窄</code>。</li>
</ul>
</li>
<li>switch语句优势<ul>
<li>当条件是判断某个变量或表达式是否等于某个固定的常量值时，使用if和switch都可以，习惯上使用switch更多。因为<code>效率稍高</code>。当条件是区间范围的判断时，只能使用if语句。</li>
<li>使用switch可以利用<code>穿透性</code>，同时执行多个分支，而if…else没有穿透性。</li>
</ul>
</li>
</ul>
<h3 id="3-什么时候用语句if，什么时候选用语句switch-灵伴-来科技"><a href="#3-什么时候用语句if，什么时候选用语句switch-灵伴-来科技" class="headerlink" title="3. 什么时候用语句if，什么时候选用语句switch(灵伴*来科技)"></a>3. 什么时候用语句if，什么时候选用语句switch(灵伴*来科技)</h3><p>同上</p>
<h3 id="4-switch语句中忘写break会发生什么-北京-蓝"><a href="#4-switch语句中忘写break会发生什么-北京-蓝" class="headerlink" title="4. switch语句中忘写break会发生什么(北京*蓝)"></a>4. switch语句中忘写break会发生什么(北京*蓝)</h3><p>case穿透</p>
<h3 id="5-Java支持哪些类型循环-上海-睿"><a href="#5-Java支持哪些类型循环-上海-睿" class="headerlink" title="5. Java支持哪些类型循环(上海*睿)"></a>5. Java支持哪些类型循环(上海*睿)</h3><ul>
<li>for;while;do-while</li>
<li>增强for （或foreach），放到集合中讲解</li>
</ul>
<h3 id="6-while和do-while循环的区别-国-科技研究院"><a href="#6-while和do-while循环的区别-国-科技研究院" class="headerlink" title="6. while和do while循环的区别(国*科技研究院)"></a>6. while和do while循环的区别(国*科技研究院)</h3><ul>
<li>do-while至少会执行一次。</li>
</ul>
<h2 id="IDEA的认识"><a href="#IDEA的认识" class="headerlink" title="IDEA的认识"></a>IDEA的认识</h2><ul>
<li>IDEA(集成功能强大、符合人体工程学（设置人性化）)</li>
<li>Eclipse</li>
</ul>
<h2 id="企业真题（四）"><a href="#企业真题（四）" class="headerlink" title="企业真题（四）"></a>企业真题（四）</h2><h3 id="1-开发中你接触过的开发工具都有哪些？"><a href="#1-开发中你接触过的开发工具都有哪些？" class="headerlink" title="1. 开发中你接触过的开发工具都有哪些？"></a>1. 开发中你接触过的开发工具都有哪些？</h3><p>IDEA</p>
<h3 id="2-谈谈你对Eclipse和IDEA使用上的感受？"><a href="#2-谈谈你对Eclipse和IDEA使用上的感受？" class="headerlink" title="2. 谈谈你对Eclipse和IDEA使用上的感受？"></a>2. 谈谈你对Eclipse和IDEA使用上的感受？</h3><p>Eclipse不够人性化。  </p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组的概述"><a href="#数组的概述" class="headerlink" title="数组的概述"></a>数组的概述</h3><ul>
<li>数组，就可以理解为多个相同数据的组合。</li>
<li>是程序中的容器：数组、集合框架（List、Set、Map）</li>
<li>数组存储的数据的特点：依次紧密排列的、有序的、可以重复的</li>
<li>此时的数组、集合框架都是在内存中对多个数据的存储。</li>
<li>数组的其它特点：一旦初始化，其长度就是确定的、不可更改的。</li>
<li>数组名中引用的是这块连续空间的首地址。</li>
</ul>
<h3 id="一维数组的使用（重要）"><a href="#一维数组的使用（重要）" class="headerlink" title="一维数组的使用（重要）"></a>一维数组的使用（重要）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; 数组的声明和初始化</span><br><span class="line">	int[] arr = new int[10];</span><br><span class="line">	String[] arr1 = new String[]&#123;&quot;Tom&quot;,&quot;Jerry&quot;&#125;;  </span><br><span class="line">  注意：Java 语言中声明数组时不能指定其长度(数组中元素的个数)。 例如：int a[5]; //非法</span><br><span class="line">&gt; 调用数组的指定元素:使用角标、索引、index</span><br><span class="line">	&gt;index从0开始！因为第一个元素距离数组首地址间隔 0 个单元格。</span><br><span class="line">&gt; 数组的属性：length,表示数组的长度</span><br><span class="line">&gt; 数组的遍历</span><br><span class="line">&gt; 数组元素的默认初始化值  </span><br><span class="line">对于基本数据类型而言，默认初始化值各有不同。</span><br><span class="line">对于引用数据类型而言，默认初始化值为 null（注意与 0 不同！）</span><br><span class="line">&gt; 一维数组的内存解析（难）</span><br><span class="line">	前提：在main()中声明变量：int[] arr = new int[]&#123;1,2,3&#125;;</span><br><span class="line">	&gt; 虚拟机栈：main()作为一个栈帧，压入栈空间中。在main()栈帧中，存储着arr变量。arr记录着数组实体的首地址值。</span><br><span class="line">	&gt; 堆：数组实体存储在堆空间中。</span><br></pre></td></tr></table></figure>

<h3 id="二维数组的使用（难点）"><a href="#二维数组的使用（难点）" class="headerlink" title="二维数组的使用（难点）"></a>二维数组的使用（难点）</h3><ul>
<li>二维数组：一维数组的元素，又是一个一维数组，则构成了二维数组。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; 数组的声明和初始化</span><br><span class="line">&gt; 调用数组的指定元素</span><br><span class="line">&gt; 数组的属性：length,表示数组的长度</span><br><span class="line">&gt; 数组的遍历</span><br><span class="line">&gt; 数组元素的默认初始化值</span><br><span class="line">&gt; 二维数组的内存解析（难）</span><br></pre></td></tr></table></figure>

<h3 id="数组的常用算法（重要）"><a href="#数组的常用算法（重要）" class="headerlink" title="数组的常用算法（重要）"></a>数组的常用算法（重要）</h3><ul>
<li>数值型数组的特征值的计算：最大值、最小值、总和、平均值等</li>
<li>数组元素的赋值。比如：杨辉三角；彩票随机生成数（6位；1-30；不能重复）；回形数</li>
<li>数组的复制、赋值</li>
<li>数组的反转</li>
<li>数组的扩容、缩容</li>
<li>数组的查找<ul>
<li>线性查找</li>
<li>二分法查找（前提：数组有序）</li>
</ul>
</li>
<li>数组的排序<ul>
<li>冒泡排序：最简单</li>
<li>快速排序：最常用</li>
</ul>
</li>
</ul>
<h3 id="Arrays工具类的使用"><a href="#Arrays工具类的使用" class="headerlink" title="Arrays工具类的使用"></a>Arrays工具类的使用</h3><ul>
<li>熟悉一下内部的常用的方法<ul>
<li>toString() &#x2F; sort() &#x2F; binarySearch()</li>
</ul>
</li>
</ul>
<h3 id="数组中的常见异常"><a href="#数组中的常见异常" class="headerlink" title="数组中的常见异常"></a>数组中的常见异常</h3><ul>
<li>ArrayIndexOutOfBoundsException</li>
<li>NullPointerException</li>
</ul>
<h2 id="企业真题（五）"><a href="#企业真题（五）" class="headerlink" title="企业真题（五）"></a>企业真题（五）</h2><h3 id="1-数组有没有length-这个方法-String有没有length-这个方法？（-蓝）"><a href="#1-数组有没有length-这个方法-String有没有length-这个方法？（-蓝）" class="headerlink" title="1. 数组有没有length()这个方法? String有没有length()这个方法？（*蓝）"></a>1. 数组有没有length()这个方法? String有没有length()这个方法？（*蓝）</h3><p>数组没有length()，是length属性。</p>
<p>String有length()</p>
<h3 id="2-有数组int-arr，用Java代码将数组元素顺序颠倒（闪-购）"><a href="#2-有数组int-arr，用Java代码将数组元素顺序颠倒（闪-购）" class="headerlink" title="2. 有数组int[] arr，用Java代码将数组元素顺序颠倒（闪*购）"></a>2. 有数组int[] arr，用Java代码将数组元素顺序颠倒（闪*购）</h3><p>略</p>
<h3 id="3-为什么数组要从0开始编号，而不是1-中-支付"><a href="#3-为什么数组要从0开始编号，而不是1-中-支付" class="headerlink" title="3. 为什么数组要从0开始编号，而不是1(中*支付)"></a>3. 为什么数组要从0开始编号，而不是1(中*支付)</h3><p>数组的索引，表示了数组元素距离首地址的偏离量。因为第1个元素的地址与首地址相同，所以偏移量就是0。所以从0开始。</p>
<h3 id="4-数组有什么排序的方式，手写一下（平-保险）"><a href="#4-数组有什么排序的方式，手写一下（平-保险）" class="headerlink" title="4. 数组有什么排序的方式，手写一下（平*保险）"></a>4. 数组有什么排序的方式，手写一下（平*保险）</h3><p>冒泡。</p>
<p>快排。（讲完递归方法以后，大家就可以练习一下）</p>
<h3 id="5-常见排序算法，说下快排过程，时间复杂度？（5-到家）"><a href="#5-常见排序算法，说下快排过程，时间复杂度？（5-到家）" class="headerlink" title="5. 常见排序算法，说下快排过程，时间复杂度？（5*到家）"></a>5. 常见排序算法，说下快排过程，时间复杂度？（5*到家）</h3><p>见课件。</p>
<p>快排：O(nlogn)</p>
<h3 id="6-二分算法实现数组的查找（神舟-天软件）"><a href="#6-二分算法实现数组的查找（神舟-天软件）" class="headerlink" title="6. 二分算法实现数组的查找（神舟*天软件）"></a>6. 二分算法实现数组的查找（神舟*天软件）</h3><p>略</p>
<h3 id="7-怎么求数组的最大子序列和（携-）"><a href="#7-怎么求数组的最大子序列和（携-）" class="headerlink" title="7. 怎么求数组的最大子序列和（携*）"></a>7. 怎么求数组的最大子序列和（携*）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 输入一个整形数组，数组里有正数也有负数。数组中连续的一个或多个整数组成一个子数组，每个子数组都有一个和。</span></span><br><span class="line"><span class="comment"> * 求所有子数组的和的最大值。要求时间复杂度为O(n)。</span></span><br><span class="line"><span class="comment"> 例如：输入的数组为1, -2, 3, 10, -4, 7, 2, -5，和最大的子数组为3, 10, -4, 7, 2，</span></span><br><span class="line"><span class="comment"> 因此输出为该子数组的和18。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, -<span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>, -<span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, -<span class="number">5</span>&#125;;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> getGreatestSum(arr);</span><br><span class="line">		System.out.println(i);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getGreatestSum</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">greatestSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> greatestSum;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">			temp += arr[i];</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(temp &lt; <span class="number">0</span>)&#123;</span><br><span class="line">				temp = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(temp &gt; greatestSum)&#123;</span><br><span class="line">				greatestSum = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(greatestSum == <span class="number">0</span>)&#123;</span><br><span class="line">			greatestSum = arr[<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(greatestSum &lt; arr[i])&#123;</span><br><span class="line">					greatestSum = arr[i];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> greatestSum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-Arrays-类的排序方法是什么？如何实现排序的？（阿-、阿-校招）"><a href="#8-Arrays-类的排序方法是什么？如何实现排序的？（阿-、阿-校招）" class="headerlink" title="8. Arrays 类的排序方法是什么？如何实现排序的？（阿*、阿*校招）"></a>8. Arrays 类的排序方法是什么？如何实现排序的？（阿*、阿*校招）</h3><p>略  </p>
<h2 id="面向对象-基础"><a href="#面向对象-基础" class="headerlink" title="面向对象-基础"></a>面向对象-基础</h2><h3 id="面向过程-vs-面向对象（了解）"><a href="#面向过程-vs-面向对象（了解）" class="headerlink" title="面向过程 vs 面向对象（了解）"></a>面向过程 vs 面向对象（了解）</h3><ul>
<li>不管是面向过程、面向对象，都是程序设计的思路。</li>
<li>面向过程：以函数为基本单位，适合解决简单问题。比如：开车</li>
<li>面向对象：以类为基本单位，适合解决复杂问题。比如：造车</li>
</ul>
<h3 id="类、对象"><a href="#类、对象" class="headerlink" title="类、对象"></a>类、对象</h3><ul>
<li>类：抽象的，概念上的定义</li>
<li>对象：具体的，类的一个一个的实例。</li>
<li>面向对象完成具体功能的操作的三步流程（非常重要）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">步骤1：创建类，并设计类的内部成员（属性、方法）</span><br><span class="line">步骤2：创建类的对象。比如：Phone p1 = new Phone();</span><br><span class="line">步骤3：通过对象，调用其内部声明的属性或方法，完成相关的功能</span><br></pre></td></tr></table></figure>

<ul>
<li>对象的内存解析<ul>
<li>创建类的一个对象；创建类的多个对象；方法的调用的内存解析</li>
</ul>
</li>
<li>Java中内存结构的划分<ul>
<li>Java中内存结构划分为：<code>虚拟机栈、堆、方法区</code>；程序计数器、本地方法栈</li>
<li>虚拟机栈：以栈帧为基本单位，有入栈和出栈操作；每个栈帧入栈操作对应一个方法的执行；方法内的局部变量会存储在栈帧中。</li>
<li>堆空间：new 出来的结构（数组、对象）：① 数组，数组的元素在堆中 ② 对象的成员变量在堆中。</li>
<li>方法区：加载的类的模板结构。</li>
</ul>
</li>
</ul>
<h3 id="类的成员之一：属性（或成员变量）"><a href="#类的成员之一：属性（或成员变量）" class="headerlink" title="类的成员之一：属性（或成员变量）"></a>类的成员之一：属性（或成员变量）</h3><ul>
<li>成员变量 vs 局部变量<br>相同点：  </li>
<li>变量声明的格式相同： 数据类型 变量名 &#x3D; 初始化值</li>
<li>变量必须先声明、后初始化、再使用。</li>
<li>变量都有其对应的作用域。只在其作用域内是有效的<br>不同点：</li>
</ul>
<ol>
<li>声明位置和方式 （1）实例变量：在类中方法外 （2）局部变量：在方法体<br>{}中或方法的形参列表、代码块中</li>
<li>在内存中存储的位置不同 （1）实例变量：堆 （2）局部变量：栈</li>
<li>生命周期 （1）实例变量：和对象的生命周期一样，随着对象的创建而存<br>在，随着对象被 GC 回收而消亡， 而且每一个对象的实例变量是独立的。<br>（2）局部变量：和方法调用的生命周期一样，每一次方法被调用而在存在，随<br>着方法执行的结束而消亡， 而且每一次方法调用都是独立。</li>
<li>作用域 （1）实例变量：通过对象就可以使用，本类中直接调用，其他类中<br>“对象.实例变量” （2）局部变量：出了作用域就不能使用</li>
<li>修饰符（后面来讲） （1）实例变量：<br>public,protected,private,final,volatile,transient 等 （2）局部变量：final</li>
<li>默认值 （1）实例变量：有默认值 （2）局部变量：没有，必须手动初始<br>化。其中的形参比较特殊，靠实参给它初始化。</li>
</ol>
<ul>
<li>属性 &lt;&#x3D;&gt; 成员变量 &lt;&#x3D;&gt;field &lt;&#x3D;&gt; 字段、域</li>
</ul>
<h3 id="类的成员之二：方法"><a href="#类的成员之二：方法" class="headerlink" title="类的成员之二：方法"></a>类的成员之二：方法</h3><ul>
<li>方法的声明：权限修饰符 返回值类型 方法名(形参列表){ &#x2F;&#x2F; 方法体}<ul>
<li>重点：返回值类型、形参列表</li>
</ul>
</li>
<li>return关键字的使用</li>
</ul>
<h3 id="再谈方法"><a href="#再谈方法" class="headerlink" title="再谈方法"></a>再谈方法</h3><h4 id="方法的重载-overload"><a href="#方法的重载-overload" class="headerlink" title="方法的重载(overload)"></a>方法的重载(overload)</h4><ul>
<li>方法的重载的要求：“两同一不同”  同类同名参数不同</li>
<li>调用方法时，如何确定调用的是某个指定的方法呢？① 方法名 ② 形参列表</li>
</ul>
<h4 id="可变个数形参的方法"><a href="#可变个数形参的方法" class="headerlink" title="可变个数形参的方法"></a>可变个数形参的方法</h4><p>JDK 5.0 中提供了 Varargs(variable number of arguments)机制</p>
<ul>
<li>格式：(int … args)</li>
</ul>
<h4 id="方法的参数传递机制：值传递-重点、难点"><a href="#方法的参数传递机制：值传递-重点、难点" class="headerlink" title="方法的参数传递机制：值传递(重点、难点)"></a>方法的参数传递机制：值传递(重点、难点)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 如果形参是基本数据类型的变量，则将实参保存的数据值赋给形参。</span><br><span class="line">&gt; 如果形参是引用数据类型的变量，则将实参保存的地址值赋给形参。</span><br></pre></td></tr></table></figure>

<h4 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h4><ul>
<li>递归方法构成了隐式的循环</li>
<li>对比：相较于循环结构，递归方法效率稍低，内存占用偏高。  </li>
<li>递归调用会占用大量的系统堆栈，内存耗用多，在递归调用层次多时速度要比循环慢的多，所以在使用递归时要慎重。</li>
<li>在要求高性能的情况下尽量避免使用递归，递归调用既花时间又耗内存。考虑使用循环迭代</li>
</ul>
<h3 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h3><ul>
<li>String[] ；Person[] ; Customer[]</li>
</ul>
<h3 id="package、import关键字的使用"><a href="#package、import关键字的使用" class="headerlink" title="package、import关键字的使用"></a>package、import关键字的使用</h3><ul>
<li>package：指明声明的类所属的包。</li>
<li>import：当前类中，如果使用其它包下的类（除java.lang包），原则上就需要导入。</li>
</ul>
<ol>
<li>java.lang—-包含一些 Java 语言的核心类，如 String、Math、Integer、System 和 Thread，提供常用功能 </li>
<li>java.net—-包含执行与网络相关的操作的<br>类和接口。 </li>
<li>java.io —-包含能提供多种输入&#x2F;输出功能的类。 </li>
<li>java.util—-包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。 </li>
<li>java.text—-包含了一些 java 格式化相关的类 </li>
<li>java.sql—-包含了 java 进行 JDBC 数据库编程的相关类&#x2F;接口 </li>
<li>java.awt—-包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)</li>
</ol>
<h3 id="oop的特征之一：封装性"><a href="#oop的特征之一：封装性" class="headerlink" title="oop的特征之一：封装性"></a>oop的特征之一：封装性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Java规定了4种权限修饰，分别是：private、缺省、protected、public。</span><br><span class="line">我们可以使用4种权限修饰来修饰类及类的内部成员。当这些成员被调用时，体现可见性的大小。</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 场景1：私有化(private)类的属性，提供公共(public)的get和set方法，对此属性进行获取或修改</span><br><span class="line">&gt; 场景2：将类中不需要对外暴露的方法，设置为private</span><br><span class="line">&gt; 场景3：单例模式中构造器private的了，避免在类的外部创建实例。（放到static关键字后讲）</span><br></pre></td></tr></table></figure>

<p>上理论：程序设计的原则之一</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">理论上：</span><br><span class="line">  -`高内聚`：类的内部数据操作细节自己完成，不允许外部干涉；</span><br><span class="line">    （Java程序通常以类的形态呈现，相关的功能封装到方法中。）</span><br><span class="line">  -`低耦合`：仅暴露少量的方法给外部使用，尽量方便外部调用。</span><br><span class="line">    （给相关的类、方法设置权限，把该隐藏的隐藏起来，该暴露的暴露出去）</span><br></pre></td></tr></table></figure>
<p>注意：<br>开发中，一般成员实例变量都习惯使用 private 修饰，再提供相应的public 权限的 get&#x2F;set 方法访问。<br>对于 final 的实例变量，不提供 set()方法。<br>对于 static final 的成员变量，习惯上使用 public 修饰。</p>
<h3 id="类的成员之三：构造器"><a href="#类的成员之三：构造器" class="headerlink" title="类的成员之三：构造器"></a>类的成员之三：构造器</h3><ul>
<li>如何定义：权限修饰符 类名(形参列表){}</li>
<li>构造器的作用：① 搭配上new，用来创建对象 ② 初始化对象的成员变量</li>
</ul>
<h3 id="三个小知识"><a href="#三个小知识" class="headerlink" title="三个小知识"></a>三个小知识</h3><h4 id="类的实例变量的赋值过程（重要）"><a href="#类的实例变量的赋值过程（重要）" class="headerlink" title="类的实例变量的赋值过程（重要）"></a>类的实例变量的赋值过程（重要）</h4><ol>
<li>在类的属性中，可以有哪些位置给属性赋值？<br>① 默认初始化；<br>② 显式初始化；<br>③ 构造器中初始化；</li>
</ol>
<hr>
<p>④ 通过”对象.方法”的方式赋值；<br>⑤ 通过”对象.属性”的方式赋值；</p>
<ol start="2">
<li>这些位置执行的先后顺序是怎样？<br>① - ② - ③ - ④&#x2F;⑤</li>
</ol>
<h4 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h4><p>所谓JavaBean，是指符合如下标准的Java类：</p>
<ul>
<li>类是公共的</li>
<li>有一个无参的公共的构造器</li>
<li>有属性，且有对应的get、set方法</li>
</ul>
<h4 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h4><p>熟悉。</p>
<h2 id="企业真题（六）"><a href="#企业真题（六）" class="headerlink" title="企业真题（六）"></a>企业真题（六）</h2><h3 id="2-1-类与对象"><a href="#2-1-类与对象" class="headerlink" title="2.1 类与对象"></a>2.1 类与对象</h3><h4 id="1-面向对象，面向过程的理解？（平-金服、英-达）"><a href="#1-面向对象，面向过程的理解？（平-金服、英-达）" class="headerlink" title="1. 面向对象，面向过程的理解？（平*金服、英**达）"></a>1. 面向对象，面向过程的理解？（平*金服、英**达）</h4><p>略。</p>
<h4 id="2-Java-的引用类型有哪几种（阿-校招）"><a href="#2-Java-的引用类型有哪几种（阿-校招）" class="headerlink" title="2. Java 的引用类型有哪几种（阿*校招）"></a>2. Java 的引用类型有哪几种（阿*校招）</h4><p>类、数组、接口；枚举、注解、记录</p>
<h4 id="3-类和对象的区别（凡-科技、上-银行）"><a href="#3-类和对象的区别（凡-科技、上-银行）" class="headerlink" title="3. 类和对象的区别（凡*科技、上*银行）"></a>3. 类和对象的区别（凡*科技、上*银行）</h4><p>略。</p>
<h4 id="4-面向对象，你解释一下，项目中哪些地方用到面向对象？（燕-金融）"><a href="#4-面向对象，你解释一下，项目中哪些地方用到面向对象？（燕-金融）" class="headerlink" title="4. 面向对象，你解释一下，项目中哪些地方用到面向对象？（燕*金融）"></a>4. 面向对象，你解释一下，项目中哪些地方用到面向对象？（燕*金融）</h4><p>“万事万物皆对象”。</p>
<h3 id="2-2-Java内存结构"><a href="#2-2-Java内存结构" class="headerlink" title="2.2 Java内存结构"></a>2.2 Java内存结构</h3><h4 id="1-Java虚拟机中内存划分为哪些区域，详细介绍一下（神-岳、数-互融）"><a href="#1-Java虚拟机中内存划分为哪些区域，详细介绍一下（神-岳、数-互融）" class="headerlink" title="1. Java虚拟机中内存划分为哪些区域，详细介绍一下（神**岳、数*互融）"></a>1. Java虚拟机中内存划分为哪些区域，详细介绍一下（神**岳、数*互融）</h4><p>略。</p>
<h4 id="2-对象存在Java内存的哪块区域里面？（阿-）"><a href="#2-对象存在Java内存的哪块区域里面？（阿-）" class="headerlink" title="2. 对象存在Java内存的哪块区域里面？（阿*）"></a>2. 对象存在Java内存的哪块区域里面？（阿*）</h4><p>堆空间。</p>
<h3 id="2-3-权限修饰符（封装性）"><a href="#2-3-权限修饰符（封装性）" class="headerlink" title="2.3 权限修饰符（封装性）"></a>2.3 权限修饰符（封装性）</h3><h4 id="1-private-、缺省、protected、public的表格化作用区域（爱-信、拓-思、中-瑞飞）"><a href="#1-private-、缺省、protected、public的表格化作用区域（爱-信、拓-思、中-瑞飞）" class="headerlink" title="1. private 、缺省、protected、public的表格化作用区域（爱*信、拓*思、中*瑞飞）"></a>1. private 、缺省、protected、public的表格化作用区域（爱*信、拓*思、中*瑞飞）</h4><p>略</p>
<h4 id="2-main方法的public能不能换成private？为什么？（凡-科技、顺-）"><a href="#2-main方法的public能不能换成private？为什么？（凡-科技、顺-）" class="headerlink" title="2. main方法的public能不能换成private？为什么？（凡*科技、顺*）"></a>2. main方法的public能不能换成private？为什么？（凡*科技、顺*）</h4><p>能。但是改以后就不能作为程序的入口了，就只是一个普通的方法。</p>
<h3 id="2-4-构造器"><a href="#2-4-构造器" class="headerlink" title="2.4 构造器"></a>2.4 构造器</h3><h4 id="1-构造方法和普通方法的区别（凡-科技、软-动力、中-软）"><a href="#1-构造方法和普通方法的区别（凡-科技、软-动力、中-软）" class="headerlink" title="1. 构造方法和普通方法的区别（凡*科技、软*动力、中*软）"></a>1. 构造方法和普通方法的区别（凡*科技、软*动力、中*软）</h4><p>编写代码的角度：没有共同点。声明格式、作用都不同。</p>
<p>字节码文件的角度：构造器会以<code>&lt;init&gt;()方法</code>的形态呈现，用以初始化对象。</p>
<h4 id="2-构造器Constructor是否可被overload-（鸿-网络）"><a href="#2-构造器Constructor是否可被overload-（鸿-网络）" class="headerlink" title="2. 构造器Constructor是否可被overload?（鸿*网络）"></a>2. 构造器Constructor是否可被overload?（鸿*网络）</h4><p>可以。</p>
<h4 id="3-无参构造器和有参构造器的的作用和应用（北京楚-龙）"><a href="#3-无参构造器和有参构造器的的作用和应用（北京楚-龙）" class="headerlink" title="3. 无参构造器和有参构造器的的作用和应用（北京楚*龙）"></a>3. 无参构造器和有参构造器的的作用和应用（北京楚*龙）</h4><p>略</p>
<h3 id="2-5-属性及属性赋值顺序"><a href="#2-5-属性及属性赋值顺序" class="headerlink" title="2.5 属性及属性赋值顺序"></a>2.5 属性及属性赋值顺序</h3><h4 id="1-成员变量与局部变量的区别（艾-软件）"><a href="#1-成员变量与局部变量的区别（艾-软件）" class="headerlink" title="1. 成员变量与局部变量的区别（艾*软件）"></a>1. 成员变量与局部变量的区别（艾*软件）</h4><p>6个点。</p>
<h4 id="2-变量赋值和构造方法加载的优先级问题（凡-科技、博-软件）"><a href="#2-变量赋值和构造方法加载的优先级问题（凡-科技、博-软件）" class="headerlink" title="2. 变量赋值和构造方法加载的优先级问题（凡*科技、博*软件）"></a>2. 变量赋值和构造方法加载的优先级问题（凡*科技、博*软件）</h4><p>变量显式赋值先于构造器中的赋值。</p>
<p>如何证明？我看的字节码文件。  </p>
<h2 id="面向对象-进阶"><a href="#面向对象-进阶" class="headerlink" title="面向对象-进阶"></a>面向对象-进阶</h2><h3 id="this关键字的使用"><a href="#this关键字的使用" class="headerlink" title="this关键字的使用"></a>this关键字的使用</h3><ul>
<li><p>this调用的结构：属性、方法；构造器</p>
</li>
<li><p>this调用属性或方法时，理解为：当前对象或当前正在创建的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123; <span class="comment">//当属性名和形参名同名时，必须使用this来区分</span></span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span>&#123;</span><br><span class="line"> <span class="built_in">this</span>();</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>this()：调用本类的无参构造器。</p>
</li>
<li><p>this(形参列表)的方式，表示调用当前类中其他的重载的构造器。<br>注意：<br>• 不能出现递归调用。比如，调用自身构造器。<br>– 推论：如果一个类中声明了 n 个构造器，则最多有 n - 1 个构造器中使用了”this(形参列表)”<br>• this()和 this(实参列表)只能声明在构造器首行。<br>– 推论：在类的一个构造器中，最多只能声明一个”this(参数列表)”</p>
</li>
</ul>
<h3 id="面向对象的特征二：继承性"><a href="#面向对象的特征二：继承性" class="headerlink" title="面向对象的特征二：继承性"></a>面向对象的特征二：继承性</h3><ul>
<li>继承性的好处<ul>
<li>继承的出现减少了代码冗余，提高了代码的复用性。</li>
<li>继承的出现，更有利于功能的扩展。</li>
<li>继承的出现让类与类之间产生了 is-a 的关系，为多态的使用提供了前提。继承描述事物之间的所属关系，这种关系是：is-a 的关系。可见，父类更通用、更一般，子类更具体。</li>
<li>注意：不要仅为了获取其他类中某个功能而去继承</li>
</ul>
</li>
<li>Java中继承性的特点<ul>
<li>局限性：类的单继承性。后续我们通过类实现接口的方式，解决单继承的局限性。</li>
<li>支持多层继承，一个父类可以声明多个子类。</li>
</ul>
</li>
<li>基础：class A extends B{}<br>类 A，称为子类、派生类(derived class)、SubClass<br>类 B，称为父类、超类、基类(base class)、SuperClass</li>
<li>理解：子类就获取了父类中声明的全部的属性、方法。可能受封装性的影响，不能直接调用。</li>
</ul>
<h3 id="方法的重写（override-x2F-overwrite）"><a href="#方法的重写（override-x2F-overwrite）" class="headerlink" title="方法的重写（override &#x2F; overwrite）"></a>方法的重写（override &#x2F; overwrite）</h3><p>@Override 使用说明：<br>写在方法上面，用来检测是不是满足重写方法的要求。这个注解就算<br>不写，只要满足要求，也是正确的方法覆盖重写。建议保留，这样编<br>译器可以帮助我们检查格式，另外也可以让阅读源代码的程序员清晰<br>的知道这是一个重写的方法。  </p>
<ul>
<li>要求</li>
</ul>
<ol>
<li>子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表。  </li>
<li>子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型。（例如：<br>Student &lt; Person）。注意：如果返回值类型是基本数据类型和 void，那么必须是相同。  </li>
<li>子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限。（public &gt; protected &gt; 缺省 &gt; private）注意：① 父类私有方法不能重写 ② 跨包的父类缺省的方法也不能重写  </li>
<li>子类方法抛出的异常不能大于父类被重写方法的异常  </li>
<li>此外，子类与父类中同名同参数的方法必须同时声明为非 static 的(即为重写)，<br>或者同时声明为 static 的（不是重写）。因为 static 方法是属于类的，子类无法<br>覆盖父类的方法。</li>
</ol>
<ul>
<li>面试题：方法的重载与重写的区别？<ul>
<li>方法的重载：“两同一不同”</li>
<li>方法的重写：<ul>
<li>前提：类的继承关系</li>
<li>子类对父类中同名同参数方法的覆盖、覆写。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="super关键字的使用"><a href="#super关键字的使用" class="headerlink" title="super关键字的使用"></a>super关键字的使用</h3><ul>
<li>super可以调用的结构：属性、方法；构造器</li>
<li>super：父类的</li>
<li>super调用父类的属性、方法：<ul>
<li>如果子父类中出现了同名的属性，此时使用super.的方式，表明调用的是父类中声明的属性。</li>
<li>子类重写了父类的方法。如果子类的任何一个方法中需要调用父类被重写的方法时，需要使用super.</li>
</ul>
</li>
<li>super调用构造器：<ul>
<li>子类继承父类时，不会继承父类的构造器。只能通过“super(形参列表)”的方<br>式调用父类指定的构造器。</li>
<li>在子类的构造器中，首行要么使用了”this(形参列表)”，要么使用了”super(形参列表)”。  </li>
<li>如果在子类构造器的首行既没有显示调用”this(形参列表)”，也没有显式调用<br>“super(形参列表)”， 则子类此构造器默认调用”super()”，即调用父类中空参的<br>构造器。  </li>
<li>一个类中声明有 n 个构造器，最多有 n-1 个构造器中使用了”this(形参列表)”，则剩下的那个一定使用”super(形参列表)”</li>
</ul>
</li>
</ul>
<h3 id="（熟悉）子类对象实例化的全过程"><a href="#（熟悉）子类对象实例化的全过程" class="headerlink" title="（熟悉）子类对象实例化的全过程"></a>（熟悉）子类对象实例化的全过程</h3><ul>
<li>结果上来说：体现为继承性</li>
<li>过程上来说：子类调用构造器创建对象时，一定会直接或间接的调用其父类的构造器，以及父类的父类的构造器，…，直到调用到Object()的构造器。</li>
</ul>
<h3 id="面向对象的特征三：多态性"><a href="#面向对象的特征三：多态性" class="headerlink" title="面向对象的特征三：多态性"></a>面向对象的特征三：多态性</h3><ul>
<li><p>广义上的理解：子类对象的多态性、方法的重写；方法的重载</p>
<p>狭义上的理解：子类对象的多态性。</p>
</li>
<li><p>格式：Object obj &#x3D; new String(“hello”); Person p &#x3D; new Man();<br>父类的引用指向子类的对象。</p>
</li>
<li><p>多态的好处：减少了大量的重载的方法的定义；开闭原则</p>
<ul>
<li>举例：public boolean equals(Object obj)</li>
<li>多态，无处不在！讲了抽象类、接口以后，会有更好的理解。</li>
</ul>
</li>
<li><p>弊端：一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法。</p>
</li>
<li><p>多态的使用：虚拟方法调用。“编译看左边，运行看右边”。属性不存在多态性。</p>
</li>
<li><p>多态的逆过程：向下转型，使用强转符()。</p>
<ul>
<li>为了避免出现强转时的ClassCastException，建议()之前使用instanceOf进行判断。</li>
</ul>
</li>
<li><p>向下转型：（子类类型）父类变量  </p>
<ul>
<li>Person p2 &#x3D; new Man(); Man m1 &#x3D; (Man)p2</li>
<li>建议在向下转型之前，使用instanceof进行判断，避免出现类型转换异常  </li>
<li>格式：a instanceof A ：判断对象a是否是类A的实例</li>
</ul>
</li>
</ul>
<h3 id="Object类的使用"><a href="#Object类的使用" class="headerlink" title="Object类的使用"></a>Object类的使用</h3><ul>
<li><p>根父类，默认的父类，java.lang.Object</p>
</li>
<li><p>equals()</p>
<ul>
<li>只能比较引用类型，Object 类源码中 equals()的作用与“&#x3D;&#x3D;”相同：比较是否指向同一个对象。对类 File、String、Date 及包装类（Wrapper Class）来说，是比较类型及内容而不考虑引用的是否是同一个对象；在这些类中重写了 Object 类的 equals()方法。</li>
<li>重写和不重写的区别</li>
<li>面试题： &#x3D;&#x3D; 和 equals()  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. == 既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型就是比较内存地址</span><br><span class="line"> 2. equals 的话，它是属于 java.lang.Object 类里面的方法，如果该方法没有被重写过默认也是==;我们可以看到 String 等类的 equals 方法是被重写过的，而且 String 类在日常开发中用的比较多，久而久之，形成了 equals 是比较值的错误观点。</span><br><span class="line"> 3. 具体要看自定义类里有没有重写 Object 的 equals 方法来判断。</span><br><span class="line"> 通常情况下，重写 equals 方法，会比较类中的相应属性是否都相等。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>toString()的使用</p>
<ul>
<li>Object中toString()调用后，返回当前对象所属的类和地址值。</li>
<li>开发中常常重写toString()，用于返回当前对象的属性信息。</li>
</ul>
</li>
<li><p>clone()  深拷贝</p>
</li>
<li><p>finalize()  当GC要回收此对象时，调用该方法（从JDK9开始过时），可能导致内部出现循环引用，导致此对象不能被回收</p>
</li>
<li><p>getClass() \ hashCode() \ notify() \ notifyAll() \ wait()</p>
</li>
</ul>
<h2 id="企业真题-七"><a href="#企业真题-七" class="headerlink" title="企业真题(七)"></a>企业真题(七)</h2><h3 id="2-1-继承性"><a href="#2-1-继承性" class="headerlink" title="2.1 继承性"></a>2.1 继承性</h3><h4 id="1-父类哪些成员可以被继承，属性可以被继承吗？可以或者不可以，请举下例子。（北京明-信）"><a href="#1-父类哪些成员可以被继承，属性可以被继承吗？可以或者不可以，请举下例子。（北京明-信）" class="headerlink" title="1. 父类哪些成员可以被继承，属性可以被继承吗？可以或者不可以，请举下例子。（北京明**信）"></a>1. 父类哪些成员可以被继承，属性可以被继承吗？可以或者不可以，请举下例子。（北京明**信）</h4><p>父类的属性、方法可以被继承。构造器可以被子类调用。</p>
<h3 id="2-2-重写"><a href="#2-2-重写" class="headerlink" title="2.2 重写"></a>2.2 重写</h3><h4 id="1-什么是Override，与Overload的区别（顺-、软-力、明-数据、阳-科技、中-软）"><a href="#1-什么是Override，与Overload的区别（顺-、软-力、明-数据、阳-科技、中-软）" class="headerlink" title="1. 什么是Override，与Overload的区别（顺*、软**力、明*数据、阳*科技、中*软）"></a>1. 什么是Override，与Overload的区别（顺*、软**力、明*数据、阳*科技、中*软）</h4><p>略</p>
<h4 id="2-Overload的方法是否可以改变返回值的类型-（新-陆）"><a href="#2-Overload的方法是否可以改变返回值的类型-（新-陆）" class="headerlink" title="2. Overload的方法是否可以改变返回值的类型?（新*陆）"></a>2. Overload的方法是否可以改变返回值的类型?（新*陆）</h4><p>和返回值类型无关。</p>
<p>public void method(int i){}</p>
<p>public int method(int j,int k){}</p>
<h4 id="3-构造器Constructor是否可被override-（鸿-网络、深圳德-技、航-普）"><a href="#3-构造器Constructor是否可被override-（鸿-网络、深圳德-技、航-普）" class="headerlink" title="3. 构造器Constructor是否可被override?（鸿*网络、深圳德**技、航**普）"></a>3. 构造器Constructor是否可被override?（鸿*网络、深圳德**技、航**普）</h4><p>不能！构造器可以重载</p>
<h4 id="4-为什么要有重载，我随便命名一个别的函数名不行吗？谈谈你是怎么理解的。（腾-）"><a href="#4-为什么要有重载，我随便命名一个别的函数名不行吗？谈谈你是怎么理解的。（腾-）" class="headerlink" title="4. 为什么要有重载，我随便命名一个别的函数名不行吗？谈谈你是怎么理解的。（腾*）"></a>4. 为什么要有重载，我随便命名一个别的函数名不行吗？谈谈你是怎么理解的。（腾*）</h4><p>见名知意。</p>
<h3 id="2-3-super关键字"><a href="#2-3-super关键字" class="headerlink" title="2.3 super关键字"></a>2.3 super关键字</h3><h4 id="1-super和this的区别-蚂-服"><a href="#1-super和this的区别-蚂-服" class="headerlink" title="1. super和this的区别(蚂**服)"></a>1. super和this的区别(蚂**服)</h4><p>把两个关键字各自的特点说清楚。</p>
<h4 id="2-this、super关键字分别代表什么-以及他们各自的使用场景和作用。（北京楚-龙）"><a href="#2-this、super关键字分别代表什么-以及他们各自的使用场景和作用。（北京楚-龙）" class="headerlink" title="2. this、super关键字分别代表什么?以及他们各自的使用场景和作用。（北京楚*龙）"></a>2. this、super关键字分别代表什么?以及他们各自的使用场景和作用。（北京楚*龙）</h4><p>略</p>
<h3 id="2-4-多态"><a href="#2-4-多态" class="headerlink" title="2.4 多态"></a>2.4 多态</h3><h4 id="1-谈谈你对多态的理解-三-重工、江-智能、银-数据、君-科技"><a href="#1-谈谈你对多态的理解-三-重工、江-智能、银-数据、君-科技" class="headerlink" title="1. 谈谈你对多态的理解(三*重工、江*智能、银*数据、君*科技)"></a>1. 谈谈你对多态的理解(三*重工、江*智能、银*数据、君*科技)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类似问法：</span><br><span class="line">&gt; Java中实现多态的机制是什么(国*电网)</span><br><span class="line">&gt; 什么是多态？（上*银行）</span><br><span class="line">&gt; Java中的多态是什么意思？（贝*）</span><br></pre></td></tr></table></figure>

<p>理解、格式、好处、弊端。</p>
<h4 id="2-多态new出来的对象跟不多态new出来的对象区别在哪？（万-智能）"><a href="#2-多态new出来的对象跟不多态new出来的对象区别在哪？（万-智能）" class="headerlink" title="2. 多态new出来的对象跟不多态new出来的对象区别在哪？（万*智能）"></a>2. 多态new出来的对象跟不多态new出来的对象区别在哪？（万*智能）</h4><p>Person p &#x3D; new Man();  &#x2F;&#x2F;虚方法调用。屏蔽了子类Man类特有的属性和方法。</p>
<p>Man m &#x3D; new Man(); </p>
<h4 id="3-说说你认为多态在代码中的体现（楚-龙）"><a href="#3-说说你认为多态在代码中的体现（楚-龙）" class="headerlink" title="3. 说说你认为多态在代码中的体现（楚*龙）"></a>3. 说说你认为多态在代码中的体现（楚*龙）</h4><p>无处不在！</p>
<p>略</p>
<h3 id="2-5-Object类"><a href="#2-5-Object类" class="headerlink" title="2.5 Object类"></a>2.5 Object类</h3><h4 id="1-x3D-x3D-与equals的区别（拓-思）"><a href="#1-x3D-x3D-与equals的区别（拓-思）" class="headerlink" title="1. &#x3D;&#x3D;与equals的区别（拓*思）"></a>1. &#x3D;&#x3D;与equals的区别（拓*思）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类似问法：</span><br><span class="line">&gt; 两个对象A和B，A==B，A.equals(B)有什么区别（华油**普）</span><br></pre></td></tr></table></figure>

<p>略</p>
<h4 id="2-重写equals方法要注意什么？（安-网络科技）"><a href="#2-重写equals方法要注意什么？（安-网络科技）" class="headerlink" title="2. 重写equals方法要注意什么？（安**网络科技）"></a>2. 重写equals方法要注意什么？（安**网络科技）</h4><ul>
<li>明确判定两个对象实体equals()的标准。是否需要所有的属性参与。</li>
<li>对象的属性，又是自定义的类型，此属性也需要重写equals()</li>
</ul>
<h4 id="3-Java中所有类的父类是什么？他都有什么方法？（阿-校招）"><a href="#3-Java中所有类的父类是什么？他都有什么方法？（阿-校招）" class="headerlink" title="3. Java中所有类的父类是什么？他都有什么方法？（阿*校招）"></a>3. Java中所有类的父类是什么？他都有什么方法？（阿*校招）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">相关问题：</span><br><span class="line">&gt; Object类有哪些方法？（恒*电子）</span><br></pre></td></tr></table></figure>

<h2 id="面向对象-高级"><a href="#面向对象-高级" class="headerlink" title="面向对象-高级"></a>面向对象-高级</h2><h3 id="关键字：static"><a href="#关键字：static" class="headerlink" title="关键字：static"></a>关键字：static</h3><ul>
<li><p>static：静态的，随着类的加载而加载、执行。</p>
</li>
<li><p>static用来修饰：属性、方法、代码块、内部类  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] class 类&#123;</span><br><span class="line">  [其他修饰符] <span class="keyword">static</span> 数据类型 变量名;  </span><br><span class="line"></span><br><span class="line">  [其他修饰符] <span class="keyword">static</span> 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">方法体</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>被修饰后的成员具备以下特点：</p>
<ol>
<li>随着类的加载而加载</li>
<li>优先于对象存在</li>
<li>修饰的成员，被所有对象所共享</li>
<li>访问权限允许时，可不创建对象，直接被类调用</li>
</ol>
</li>
<li><p>熟悉：static修饰的类变量、类方法与不使用static修饰的区别。</p>
<ul>
<li>类变量：类的生命周期内，只有一个。被类的多个实例共享。</li>
</ul>
</li>
<li><p>掌握：我们遇到属性或方法时，需要考虑是否声明为static的。</p>
</li>
</ul>
<h3 id="单例模式（或单子模式）"><a href="#单例模式（或单子模式）" class="headerlink" title="单例模式（或单子模式）"></a>单例模式（或单子模式）</h3><ul>
<li>经典的设计模式有23种</li>
<li>解决的问题：在整个软件系统中，只存在当前类的唯一实例。</li>
<li>实现方式：饿汉式、懒汉式、枚举类等</li>
<li>对比饿汉式和懒汉式<ul>
<li>饿汉式：“立即加载”，线程安全的。</li>
<li>懒汉式：”延迟加载”，线程不安全。</li>
</ul>
</li>
<li>需要会手写饿汉式和懒汉式  <ul>
<li>饿汉式：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"> <span class="comment">// 1.私有化构造器</span></span><br><span class="line"> <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 2.内部提供一个当前类的实例</span></span><br><span class="line"> <span class="comment">// 4.此实例也必须静态化</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">single</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"> <span class="comment">// 3.提供公共的静态的方法，返回当前类的对象</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> single;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure></li>
<li>懒汉式：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"> <span class="comment">// 1.私有化构造器</span></span><br><span class="line"> <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 2.内部提供一个当前类的实例</span></span><br><span class="line"> <span class="comment">// 4.此实例也必须静态化</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Singleton single;</span><br><span class="line"> <span class="comment">// 3.提供公共的静态的方法，返回当前类的对象</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">if</span>(single == <span class="literal">null</span>) &#123;</span><br><span class="line">     single = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> single;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>优点和应用场景<br>由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比<br>较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时<br>直接产生一个单例对象，然后永久驻留内存的方式来解决。</li>
</ul>
<h3 id="理解main-方法"><a href="#理解main-方法" class="headerlink" title="理解main()方法"></a>理解main()方法</h3><p>由于 JVM 需要调用类的 main()方法，所以该方法的访问权限必须是 public，又<br>因为 JVM 在执行 main()方法时不必创建对象，所以该方法必须是 static 的，该<br>方法接收一个 String 类型的数组参数，该数组中保存执行 Java 命令时传递给所<br>运行的类的参数。<br>又因为 main() 方法是静态的，我们不能直接访问该类中的非静态成员，必须创<br>建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员，这种<br>情况，我们在之前的例子中多次碰到。  </p>
<ul>
<li>public static void main(String[] args){}</li>
<li>理解1：作为程序的入口；普通的静态方法</li>
<li>理解2：如何使用main()与控制台进行数据的交互。<ul>
<li>命令行：java 类名 “Tom” “Jerry” “123”</li>
</ul>
</li>
</ul>
<h3 id="类的成员之四：代码块"><a href="#类的成员之四：代码块" class="headerlink" title="类的成员之四：代码块"></a>类的成员之四：代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] class 类&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">静态代码块</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>分类：静态代码块、非静态代码块</li>
<li>使用频率上来讲：用的比较少。</li>
<li>静态代码块：  <ol>
<li>可以有输出语句。</li>
<li>可以对类的属性、类的声明进行初始化操作。</li>
<li>不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法。</li>
<li>若有多个静态的代码块，那么按照从上到下的顺序依次执行。</li>
<li>静态代码块的执行要先于非静态代码块。</li>
<li>静态代码块随着类的加载而加载，且只执行一次。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String country;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;非静态代码块，country = &quot;</span> + country);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">country = <span class="string">&quot;中国&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>非静态代码块：随着对象的创建而执行</li>
</ul>
<blockquote>
<p>总结：对象的实例变量可以赋值的位置及先后顺序</p>
<p>① 默认初始化<br>② 显式初始化  或 ⑤ 代码块中初始化<br>③ 构造器中初始化</p>
<p>④ 有了对象以后，通过”对象.属性”或”对象.方法”的方法进行赋值</p>
<p>执行的先后顺序：<br>① - ②&#x2F;⑤ - ③ - ④</p>
</blockquote>
<h3 id="关键字：final"><a href="#关键字：final" class="headerlink" title="关键字：final"></a>关键字：final</h3><ul>
<li>用来修饰：类、方法、变量（成员变量、局部变量）<ul>
<li>类：不能被继承，没有子类。提高安全性，提高程序的可读性。</li>
<li>方法：不能被子类重写。</li>
<li>变量：是一个“常量”，一旦赋值不能修改。即常量，常量名建议使用大写字母。如果某个成员变量用 final 修饰后，没有 set 方法，并且必须初始化（可以显式赋值、或在初始化块赋值、实例变量还可以在构造器中赋值）</li>
</ul>
</li>
</ul>
<h3 id="关键字：abstract"><a href="#关键字：abstract" class="headerlink" title="关键字：abstract"></a>关键字：abstract</h3><ul>
<li>抽象的</li>
<li>用来修饰：类、方法<ul>
<li>类：抽象类：不能实例化。</li>
<li>方法：抽象方法：没有方法体，必须由子类实现此方法。</li>
</ul>
</li>
<li>使用说明：  <ol>
<li>抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对<br>象。<br>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方<br>法体，没有意义。</li>
<li>抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法<br>体。若没有重写全部的抽象方法，仍为抽象类。</li>
<li>抽象类中，也有构造方法，是供子类创建对象时，初始化父类成员变量使用的。<br>理解：子类的构造方法中，有默认的 super()或手动的 super(实参列表)，需要<br>访问父类构造方法。</li>
<li>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。<br>理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常<br>用于某些特殊的类结构设计。  </li>
<li>抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。<br>除非该子类也是抽象类。<br>理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象<br>后，调用抽象的方法，没有意义。</li>
</ol>
</li>
<li>注意事项：  <ul>
<li>不能用 abstract 修饰变量、代码块、构造器；</li>
<li>不能用 abstract 修饰私有方法、静态方法、final 的方法、final 的类。</li>
</ul>
</li>
</ul>
<h3 id="关键字：interface"><a href="#关键字：interface" class="headerlink" title="关键字：interface"></a>关键字：interface</h3><ul>
<li><p>interface：接口，用来定义一组规范、一种标准。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] interface 接口名&#123;</span><br><span class="line"><span class="comment">//接口的成员列表：</span></span><br><span class="line"><span class="comment">// 公共的静态常量</span></span><br><span class="line"><span class="comment">// 公共的抽象方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共的默认方法（JDK1.8 以上）</span></span><br><span class="line"><span class="comment">// 公共的静态方法（JDK1.8 以上）</span></span><br><span class="line"><span class="comment">// 私有方法（JDK1.9 以上）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">USB3</span>&#123;</span><br><span class="line">  <span class="comment">//静态常量</span></span><br><span class="line">  <span class="type">long</span> <span class="variable">MAX_SPEED</span> <span class="operator">=</span> <span class="number">500</span>*<span class="number">1024</span>*<span class="number">1024</span>;<span class="comment">//500MB/s</span></span><br><span class="line">  <span class="comment">//抽象方法</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">in</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span>;</span><br><span class="line">  <span class="comment">//默认方法</span></span><br><span class="line">  <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//静态方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;USB 3.0 可以同步全速地进行读写操作&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>掌握：接口中可以声明的结构。</p>
<ul>
<li><p>属性：使用public static final修饰</p>
</li>
<li><p>方法：jdk8之前：只能声明抽象方法，使用public abstract修饰</p>
<p>​            jdk8中：声明static方法、default方法。</p>
<p>​            jdk9中：声明private方法。</p>
</li>
</ul>
</li>
<li><p>类实现接口（implements）：接口不能创建对象，但是可以被类实现（implements ，类似于被继承）。类与接口的关系为实现关系，即类实现接口，该类可以称为接口的实现类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 implements 关键字。  </p>
</li>
<li><p>接口的多实现（implements）：在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的多实现。并且，一个类能继承一个父类，同时实现多个接口。  </p>
</li>
<li><p>接口的多继承(extends)：一个接口能继承另一个或者多个接口。  </p>
</li>
<li><p>JDK8 中相关冲突问题：</p>
</li>
</ul>
<ol>
<li>默认方法冲突问题：<br>（1）类优先原则：当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的抽象方法重名，子类就近选择执行父类的成员方法。<br>（2）接口冲突（左右为难）：当一个类同时实现了多个父接口，而多个父接口中包含方法签名相同的默认方法时，选择保留其中一个，通过“接口名.super.方法名”的方法选择保留哪个接口的默认方法；当一个子接口同时继承了多个接口，而多个父接口中包含方法签名相同的默认方法<br>时，子接口重写默认方法。（子接口重写默认方法时，default 关键字可以保留；子类重写默认方法时，default 关键字不可以保留）</li>
<li>常量冲突问题：<br>当子类继承父类又实现父接口，而父类中存在与父接口常量同名的成员变量，并且该成员变量名在子类中仍然可见。<br>当子类同时实现多个接口，而多个接口存在相同同名常量。<br>此时在子类中想要引用父类或父接口的同名的常量或成员变量时，就会有冲突问题。</li>
</ol>
<ul>
<li>笔试题：抽象类、接口的对比。</li>
</ul>
<h3 id="类的成员之五：内部类"><a href="#类的成员之五：内部类" class="headerlink" title="类的成员之五：内部类"></a>类的成员之五：内部类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 成员内部类的理解</span><br><span class="line">&gt; 如何创建成员内部类的实例</span><br><span class="line">&gt; 如何在成员内部类中调用外部类的结构</span><br><span class="line">&gt; 局部内部类的基本使用（关注：如何在方法内创建匿名局部内部类的对象）</span><br></pre></td></tr></table></figure>

<h3 id="枚举类：enum"><a href="#枚举类：enum" class="headerlink" title="枚举类：enum"></a>枚举类：enum</h3><ul>
<li>枚举类的实现：<br>– 在 JDK5.0 之前，需要程序员自定义枚举类型。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String SEASONNAME;<span class="comment">//季节的名称</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String SEASONDESC;<span class="comment">//季节的描述</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.SEASONNAME = seasonName;</span><br><span class="line"><span class="built_in">this</span>.SEASONDESC = seasonDesc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;白雪皑皑&quot;</span>);</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line"><span class="string">&quot;SEASONNAME=&#x27;&quot;</span> + SEASONNAME + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line"><span class="string">&quot;, SEASONDESC=&#x27;&quot;</span> + SEASONDESC + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line"><span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
– 在 JDK5.0 之后，Java 支持 enum 关键字来快速定义枚举类型。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SeasonEnum</span> &#123;</span><br><span class="line">SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春风又绿江南岸&quot;</span>),</span><br><span class="line">SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;映日荷花别样红&quot;</span>),</span><br><span class="line">AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋水共长天一色&quot;</span>),</span><br><span class="line">WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;窗含西岭千秋雪&quot;</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">SeasonEnum</span><span class="params">(String seasonName, String seasonDesc)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line"><span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> seasonName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> seasonDesc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>enum 中常用方法：<br>String toString(): 默认返回的是常量名（对象名），可以继续手动重写该方法！</li>
</ul>
<p>static 枚举类型[] values():返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值，是一个静态方法  </p>
<p>static 枚举类型 valueOf(String name)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。  </p>
<p>String name():得到当前枚举常量的名称。建议优先使用 toString()。  </p>
<p>int ordinal():返回当前枚举常量的次序号，默认从 0 开始  </p>
<ul>
<li>实现接口的枚举类  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">A</span> implements 接口 <span class="number">1</span>，接口 <span class="number">2</span>&#123;</span><br><span class="line">常量名 <span class="number">1</span>(参数)&#123;</span><br><span class="line"><span class="comment">//抽象方法的实现或重写</span></span><br><span class="line">&#125;,</span><br><span class="line">常量名 <span class="number">2</span>(参数)&#123;</span><br><span class="line"><span class="comment">//抽象方法的实现或重写</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>掌握：使用enum关键字定义枚举类即可。</li>
</ul>
<h3 id="注解-Annotation"><a href="#注解-Annotation" class="headerlink" title="注解:Annotation"></a>注解:Annotation</h3><ul>
<li>框架 &#x3D; 注解 + 反射 + 设计模式</li>
<li>Java基础阶段：简单。@Override(限定重写父类方法，该注解只能用于方法)  、 @Deprecated(用于表示所修饰的元素(类，方法等)已过时)、@SuppressWarnings(抑制编译器警告)</li>
<li>元注解：对现有的注解进行解释说明。<ul>
<li>@Target：表明可以用来修饰的结构</li>
<li>@Retation：表明生命周期</li>
</ul>
</li>
<li>如何自定义注解。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[元注解]</span><br><span class="line">[修饰符] <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">  [成员列表]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>JUnit 单元测试<br>默认情况下，在单元测试方法中使用 Scanner 时，并不能实现控制台数据的输<br>入。需要做如下设置：<br>在 idea64.exe.vmoptions 配置文件中加入下面一行设置，重启 idea 后生效。<br>-Deditable.java.test.console&#x3D;true</li>
</ul>
<h3 id="包装类的使用"><a href="#包装类的使用" class="headerlink" title="包装类的使用"></a>包装类的使用</h3><ul>
<li>掌握：基本数据类型对应的包装类都有哪些？</li>
<li>掌握：基本数据类型、包装类、String三者之间的转换<ul>
<li>基本数据类型 &lt;-&gt; 包装类：自动装箱、自动拆箱（从 JDK5.0 开始）</li>
<li>基本数据类型、包装类 &lt;-&gt; String<ul>
<li>String的valueOf(xxx)</li>
<li>包装类的parseXxx(String str)</li>
</ul>
</li>
</ul>
</li>
<li>包装类的其它 API</li>
</ul>
<ol>
<li>数据类型的最大最小值：Integer.MAX_VALUE 和 Integer.MIN_VALUE; Long.MAX_VALUE 和 Long.MIN_VALUE; Double.MAX_VALUE 和 Double.MIN_VALUE  </li>
<li>字符转大小写：Character.toUpperCase(‘x’); Character.toLowerCase(‘X’);  </li>
<li>整数转进制：Integer.toBinaryString(int i); Integer.toHexString(int i); Integer.toOctalString(int i)  </li>
<li>比较的方法：Double.compare(double d1, double d2);Integer.compare(int x, int y)</li>
</ol>
<ul>
<li>面试题： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"> <span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"> System.out.println(i == j);<span class="comment">//false</span></span><br><span class="line"> <span class="comment">//底层都会调用Integer的valueOf()</span></span><br><span class="line"> <span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"> <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"> System.out.println(m == n);<span class="comment">//true  看源码，如果在[-128,127]间,从现有数组里取，（享元模式）</span></span><br><span class="line"> <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"> <span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"> System.out.println(x == y);<span class="comment">//false</span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="literal">true</span> ? <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>) : <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">2.0</span>);<span class="comment">//三目运算符后面类型必须一致</span></span><br><span class="line">System.out.println(o1);<span class="comment">//1.0</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="企业真题（八）"><a href="#企业真题（八）" class="headerlink" title="企业真题（八）"></a>企业真题（八）</h2><h3 id="2-1-static关键字"><a href="#2-1-static关键字" class="headerlink" title="2.1 static关键字"></a>2.1 static关键字</h3><h4 id="1-静态变量和实例变量的区别？（保-丰、-软国际、-软华-、北京明-信）"><a href="#1-静态变量和实例变量的区别？（保-丰、-软国际、-软华-、北京明-信）" class="headerlink" title="1. 静态变量和实例变量的区别？（保*丰、*软国际、*软华*、北京明**信）"></a>1. 静态变量和实例变量的区别？（保*丰、*软国际、*软华*、北京明**信）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; 说明静态变量和实例变量之间的区别和使用场景（上海*动）</span><br></pre></td></tr></table></figure>

<p>略</p>
<h4 id="2-静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？（-度）"><a href="#2-静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？（-度）" class="headerlink" title="2. 静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？（*度）"></a>2. 静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？（*度）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; 在java中，可以重载一个static方法吗？可以覆盖一个static方法吗？（Vi*o）</span><br></pre></td></tr></table></figure>

<p>静态方法不能被重写。不存在多态性。</p>
<h4 id="3-是否可以从一个static方法内部发出对非static方法的调用？（同-顺）"><a href="#3-是否可以从一个static方法内部发出对非static方法的调用？（同-顺）" class="headerlink" title="3. 是否可以从一个static方法内部发出对非static方法的调用？（同*顺）"></a>3. 是否可以从一个static方法内部发出对非static方法的调用？（同*顺）</h4><p>只能通过对象来对非静态方法的调用。</p>
<h4 id="4-被static修饰的成员-类、方法、成员变量-能否再使用private进行修饰？（联-优势）"><a href="#4-被static修饰的成员-类、方法、成员变量-能否再使用private进行修饰？（联-优势）" class="headerlink" title="4. 被static修饰的成员(类、方法、成员变量)能否再使用private进行修饰？（联*优势）"></a>4. 被static修饰的成员(类、方法、成员变量)能否再使用private进行修饰？（联*优势）</h4><p>完全可以。除了代码块。</p>
<h3 id="2-2-设计模式"><a href="#2-2-设计模式" class="headerlink" title="2.2 设计模式"></a>2.2 设计模式</h3><h4 id="1-知道哪些设计模式？（-通快递、蚂-服）"><a href="#1-知道哪些设计模式？（-通快递、蚂-服）" class="headerlink" title="1. 知道哪些设计模式？（*通快递、蚂**服）"></a>1. 知道哪些设计模式？（*通快递、蚂**服）</h4><p>单例模式、模板方法、享元设计模式</p>
<h4 id="2-开发中都用到了那些设计模式-用在什么场合-（久-国际物流）"><a href="#2-开发中都用到了那些设计模式-用在什么场合-（久-国际物流）" class="headerlink" title="2. 开发中都用到了那些设计模式?用在什么场合? （久*国际物流）"></a>2. 开发中都用到了那些设计模式?用在什么场合? （久*国际物流）</h4><p>略</p>
<h3 id="2-3-main"><a href="#2-3-main" class="headerlink" title="2.3 main()"></a>2.3 main()</h3><h4 id="1-main-方法的public能不能换成private，为什么（凡-科技、顺-）"><a href="#1-main-方法的public能不能换成private，为什么（凡-科技、顺-）" class="headerlink" title="1. main()方法的public能不能换成private，为什么（凡*科技、顺*）"></a>1. main()方法的public能不能换成private，为什么（凡*科技、顺*）</h4><p>可以改。但是改完以后就不是程序入口了。</p>
<h4 id="2-main-方法中是否可以调用非静态方法？（浩-科技）"><a href="#2-main-方法中是否可以调用非静态方法？（浩-科技）" class="headerlink" title="2. main()方法中是否可以调用非静态方法？（浩*科技）"></a>2. main()方法中是否可以调用非静态方法？（浩*科技）</h4><p>只能通过对象来对非静态方法的调用。</p>
<h3 id="2-4-代码块"><a href="#2-4-代码块" class="headerlink" title="2.4 代码块"></a>2.4 代码块</h3><h4 id="1-类的组成和属性赋值执行顺序-（航-拓普）"><a href="#1-类的组成和属性赋值执行顺序-（航-拓普）" class="headerlink" title="1. 类的组成和属性赋值执行顺序?（航*拓普）"></a>1. 类的组成和属性赋值执行顺序?（航*拓普）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; Java中类的变量初始化的顺序？（*壳）</span><br></pre></td></tr></table></figure>

<p>略。</p>
<h4 id="2-静态代码块，普通代码块，构造方法，从类加载开始的执行顺序？（恒-电子）"><a href="#2-静态代码块，普通代码块，构造方法，从类加载开始的执行顺序？（恒-电子）" class="headerlink" title="2. 静态代码块，普通代码块，构造方法，从类加载开始的执行顺序？（恒*电子）"></a>2. 静态代码块，普通代码块，构造方法，从类加载开始的执行顺序？（恒*电子）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; 类加载成员变量、静态代码块、构造器的加载顺序（*科软、软**力、同*顺）</span><br><span class="line">&gt; static代码块(静态代码块)是否在类的构造函数之前被执行（联*优势）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>静态代码块 –&gt; 普通代码块 –&gt; 构造器</p>
<h3 id="2-5-final关键字"><a href="#2-5-final关键字" class="headerlink" title="2.5 final关键字"></a>2.5 final关键字</h3><h4 id="1-描述一下对final理解（华-博普）"><a href="#1-描述一下对final理解（华-博普）" class="headerlink" title="1. 描述一下对final理解（华**博普）"></a>1. 描述一下对final理解（华**博普）</h4><p>略</p>
<h4 id="2-判断题：使用final修饰一个变量时，是引用不能改变，引用指向的对象可以改变？（-米）"><a href="#2-判断题：使用final修饰一个变量时，是引用不能改变，引用指向的对象可以改变？（-米）" class="headerlink" title="2. 判断题：使用final修饰一个变量时，是引用不能改变，引用指向的对象可以改变？（*米）"></a>2. 判断题：使用final修饰一个变量时，是引用不能改变，引用指向的对象可以改变？（*米）</h4><p>引用不能改变。</p>
<p>引用指向的对象实体中的属性，如果没有使用final修饰，则可以改变。</p>
<h4 id="3-判断题：final不能用于修饰构造方法？（联-优势）"><a href="#3-判断题：final不能用于修饰构造方法？（联-优势）" class="headerlink" title="3. 判断题：final不能用于修饰构造方法？（联*优势）"></a>3. 判断题：final不能用于修饰构造方法？（联*优势）</h4><p>是的。</p>
<h4 id="4-final或static-final-修饰成员变量，能不能进行-操作？（佳-贸易）"><a href="#4-final或static-final-修饰成员变量，能不能进行-操作？（佳-贸易）" class="headerlink" title="4. final或static final 修饰成员变量，能不能进行++操作？（佳*贸易）"></a>4. final或static final 修饰成员变量，能不能进行++操作？（佳*贸易）</h4><p>不能。</p>
<h3 id="2-6-抽象类与接口"><a href="#2-6-抽象类与接口" class="headerlink" title="2.6 抽象类与接口"></a>2.6 抽象类与接口</h3><h4 id="1-什么是抽象类？如何识别一个抽象类？（易-支付）"><a href="#1-什么是抽象类？如何识别一个抽象类？（易-支付）" class="headerlink" title="1. 什么是抽象类？如何识别一个抽象类？（易*支付）"></a>1. 什么是抽象类？如何识别一个抽象类？（易*支付）</h4><p>使用abstract修饰。</p>
<h4 id="2-为什么不能用abstract修饰属性、私有方法、构造器、静态方法、final的方法？（止-善）"><a href="#2-为什么不能用abstract修饰属性、私有方法、构造器、静态方法、final的方法？（止-善）" class="headerlink" title="2. 为什么不能用abstract修饰属性、私有方法、构造器、静态方法、final的方法？（止**善）"></a>2. 为什么不能用abstract修饰属性、私有方法、构造器、静态方法、final的方法？（止**善）</h4><p>略。 为了语言的自洽。</p>
<h4 id="3-接口与抽象类的区别？（字-跳动、阿-校招、-度校招、-计算机技术及应用研究所、航-拓普、纬-、招-晟、汇-云通、数信-科技、北京永-鼎力、上海-连科技）"><a href="#3-接口与抽象类的区别？（字-跳动、阿-校招、-度校招、-计算机技术及应用研究所、航-拓普、纬-、招-晟、汇-云通、数信-科技、北京永-鼎力、上海-连科技）" class="headerlink" title="3. 接口与抽象类的区别？（字*跳动、阿*校招、*度校招、**计算机技术及应用研究所、航*拓普、纬*、招**晟、汇*云通、数信**科技、北京永*鼎力、上海*连科技）"></a>3. 接口与抽象类的区别？（字*跳动、阿*校招、*度校招、**计算机技术及应用研究所、航*拓普、纬*、招**晟、汇*云通、数信**科技、北京永*鼎力、上海*连科技）</h4><p>略。</p>
<h4 id="4-接口是否可继承接口？抽象类是否可实现（implements）接口？抽象类是否可继承实现类（concrete-class）？（航-拓普、-蝶、深圳德-科技）"><a href="#4-接口是否可继承接口？抽象类是否可实现（implements）接口？抽象类是否可继承实现类（concrete-class）？（航-拓普、-蝶、深圳德-科技）" class="headerlink" title="4. 接口是否可继承接口？抽象类是否可实现（implements）接口？抽象类是否可继承实现类（concrete class）？（航*拓普、*蝶、深圳德*科技）"></a>4. 接口是否可继承接口？抽象类是否可实现（implements）接口？抽象类是否可继承实现类（concrete class）？（航*拓普、*蝶、深圳德*科技）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; 接口A可以继承接口B吗?接口A可以实现接口B吗?（久*国际物流）</span><br></pre></td></tr></table></figure>

<p>是；是；是；</p>
<h4 id="5-接口可以有自己属性吗？（华-中盛）"><a href="#5-接口可以有自己属性吗？（华-中盛）" class="headerlink" title="5. 接口可以有自己属性吗？（华*中盛）"></a>5. 接口可以有自己属性吗？（华*中盛）</h4><p>可以。必须是public static final的</p>
<h4 id="6-访问接口的默认方法如何使用-上海-思"><a href="#6-访问接口的默认方法如何使用-上海-思" class="headerlink" title="6. 访问接口的默认方法如何使用(上海*思)"></a>6. 访问接口的默认方法如何使用(上海*思)</h4><p>使用实现类的对象进行调用。而且实现还可以重写此默认方法。</p>
<h3 id="2-7-内部类"><a href="#2-7-内部类" class="headerlink" title="2.7 内部类"></a>2.7 内部类</h3><h4 id="1-内部类有哪几种？（华油-普、来-科技）"><a href="#1-内部类有哪几种？（华油-普、来-科技）" class="headerlink" title="1. 内部类有哪几种？（华油**普、来*科技）"></a>1. 内部类有哪几种？（华油**普、来*科技）</h4><p>略。</p>
<h4 id="2-内部类的特点说一下（招通-）"><a href="#2-内部类的特点说一下（招通-）" class="headerlink" title="2. 内部类的特点说一下（招通**）"></a>2. 内部类的特点说一下（招通**）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; 说一下内部类的好处（北京楚*龙）</span><br><span class="line">&gt; 使用过内部类编程吗，有什么作用（软**力）</span><br></pre></td></tr></table></figure>





<h4 id="8-匿名类说一下（阿-校招、上海立-网络）"><a href="#8-匿名类说一下（阿-校招、上海立-网络）" class="headerlink" title="8.匿名类说一下（阿*校招、上海立*网络）"></a>8.匿名类说一下（阿*校招、上海立*网络）</h4><p>略</p>
<h3 id="2-8-枚举类"><a href="#2-8-枚举类" class="headerlink" title="2.8 枚举类"></a>2.8 枚举类</h3><h4 id="1-枚举可以继承吗-（顺-）"><a href="#1-枚举可以继承吗-（顺-）" class="headerlink" title="1. 枚举可以继承吗?（顺*）"></a>1. 枚举可以继承吗?（顺*）</h4><p>使用enum定义的，其父类就是Enum类，就不要再继承其他的类了。</p>
<h3 id="2-9-包装类"><a href="#2-9-包装类" class="headerlink" title="2.9 包装类"></a>2.9 包装类</h3><h4 id="1-Java基本类型与包装类的区别（凡-科技）"><a href="#1-Java基本类型与包装类的区别（凡-科技）" class="headerlink" title="1. Java基本类型与包装类的区别（凡*科技）"></a>1. Java基本类型与包装类的区别（凡*科技）</h4><p>略。</p>
<h3 id="2-10-综合"><a href="#2-10-综合" class="headerlink" title="2.10 综合"></a>2.10 综合</h3><h4 id="1-谈谈你对面向对象的理解-君-科技、航-拓普、…"><a href="#1-谈谈你对面向对象的理解-君-科技、航-拓普、…" class="headerlink" title="1. 谈谈你对面向对象的理解(君*科技、航*拓普、…)"></a>1. 谈谈你对面向对象的理解(君*科技、航*拓普、…)</h4><ul>
<li>面向对象的两个要素：类、对象  —&gt; 面向对象编程。“万事万物皆对象”。</li>
<li>面向对象的三大特征</li>
<li>接口，与类并列的结构，作为一个补充：类可以实现多个接口。</li>
</ul>
<h4 id="2-面向对象的特征有哪些方面-（北京楚-龙、深圳德-科技、直-科技、米-奇网络、航-拓普）"><a href="#2-面向对象的特征有哪些方面-（北京楚-龙、深圳德-科技、直-科技、米-奇网络、航-拓普）" class="headerlink" title="2. 面向对象的特征有哪些方面? （北京楚*龙、深圳德*科技、直*科技、米*奇网络、航*拓普）"></a>2. 面向对象的特征有哪些方面? （北京楚*龙、深圳德*科技、直*科技、米*奇网络、航*拓普）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; 面向对象核心是什么？（平**服）</span><br></pre></td></tr></table></figure>

<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="异常的概述"><a href="#异常的概述" class="headerlink" title="异常的概述"></a>异常的概述</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. 什么是异常？</span><br><span class="line">指的是程序在执行过程中，出现的非正常情况，如果不处理最终会导致JVM的非正常停止。</span><br><span class="line"></span><br><span class="line">2. 异常的抛出机制</span><br><span class="line">Java中把不同的异常用不同的类表示，一旦发生某种异常，就`创建该异常类型的对象`，并且抛出（throw）。</span><br><span class="line">然后程序员可以捕获(catch)到这个异常对象，并处理；如果没有捕获(catch)这个异常对象，那么这个异常</span><br><span class="line">对象将会导致程序终止。</span><br><span class="line"></span><br><span class="line">3. 如何对待异常</span><br><span class="line"> 对于程序出现的异常，一般有两种解决方法：一是遇到错误就终止程序的运行。另一种方法是程序员在编写程序时，</span><br><span class="line"> 就充分考虑到各种可能发生的异常和错误，极力预防和避免。实在无法避免的，要编写相应的代码进行异常的检测、</span><br><span class="line"> 以及`异常的处理`，保证代码的`健壮性`。</span><br></pre></td></tr></table></figure>

<h3 id="异常的体系结构及常见的异常"><a href="#异常的体系结构及常见的异常" class="headerlink" title="异常的体系结构及常见的异常"></a>异常的体系结构及常见的异常</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Throwable:异常体系的根父类</span><br><span class="line">    • public void printStackTrace()：打印异常的详细信息。</span><br><span class="line">    包含了异常的类型、异常的原因、异常出现的位置、在开发和调试阶段都得使用printStackTrace。</span><br><span class="line">    • public String getMessage()：获取发生异常的原因。</span><br><span class="line">    |---java.lang.Error:错误。Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。</span><br><span class="line">                         一般不编写针对性的代码进行处理。</span><br><span class="line">               |---- StackOverflowError（栈内存溢出）和 OutOfMemoryError（堆内存溢出，简称OOM）</span><br><span class="line"></span><br><span class="line">    |---java.lang.Exception:异常。我们可以编写针对性的代码进行处理。</span><br><span class="line">               |----编译时异常：(受检异常)在执行javac.exe命令时，出现的异常。</span><br><span class="line">                    |----- ClassNotFoundException</span><br><span class="line">                    |----- FileNotFoundException</span><br><span class="line">                    |----- IOException</span><br><span class="line">               |----运行时异常：(非受检异常)在执行java.exe命令时，出现的异常。</span><br><span class="line">                    |---- ArrayIndexOutOfBoundsException</span><br><span class="line">                    |---- NullPointerException</span><br><span class="line">                    |---- ClassCastException</span><br><span class="line">                    |---- NumberFormatException</span><br><span class="line">                    |---- InputMismatchException</span><br><span class="line">                    |---- ArithmeticException</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">【面试题】说说你在开发中常见的异常都有哪些？</span><br><span class="line"></span><br><span class="line">开发1-2年：</span><br><span class="line">|----编译时异常：(受检异常)在执行javac.exe命令时，出现的异常。</span><br><span class="line">    |----- ClassNotFoundException</span><br><span class="line">    |----- FileNotFoundException</span><br><span class="line">    |----- IOException</span><br><span class="line">|----运行时异常：(非受检异常)在执行java.exe命令时，出现的异常。</span><br><span class="line">    |---- ArrayIndexOutOfBoundsException</span><br><span class="line">    |---- NullPointerException</span><br><span class="line">    |---- ClassCastException</span><br><span class="line">    |---- NumberFormatException</span><br><span class="line">    |---- InputMismatchException</span><br><span class="line">    |---- ArithmeticException</span><br><span class="line"></span><br><span class="line">开发3年以上：</span><br><span class="line">OOM。</span><br></pre></td></tr></table></figure>

<h3 id="异常处理的方式"><a href="#异常处理的方式" class="headerlink" title="异常处理的方式"></a>异常处理的方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">过程1：“抛”</span><br><span class="line"> &gt;&quot;自动抛&quot; ： 程序在执行的过程当中，一旦出现异常，就会在出现异常的代码处，自动生成对应异常类的对象，并将此对象抛出。</span><br><span class="line"></span><br><span class="line"> &gt;&quot;手动抛&quot; ：程序在执行的过程当中，不满足指定条件的情况下，我们主动的使用&quot;throw + 异常类的对象&quot;方式抛出异常对象。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">过程2：“抓”</span><br><span class="line">    狭义上讲：try-catch的方式捕获异常，并处理。</span><br><span class="line">    广义上讲：把“抓”理解为“处理”。则此时对应着异常处理的两种方式：① try-catch-finally ② throws</span><br></pre></td></tr></table></figure>

<h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1. 基本结构：</span><br><span class="line">try&#123;</span><br><span class="line">   ...... //可能产生异常的代码</span><br><span class="line">&#125;</span><br><span class="line">catch( 异常类型1 e )&#123;</span><br><span class="line">   ...... //当产生异常类型1型异常时的处置措施</span><br><span class="line">&#125;</span><br><span class="line">catch( 异常类型2 e )&#123;</span><br><span class="line">   ......     //当产生异常类型2型异常时的处置措施</span><br><span class="line">&#125;</span><br><span class="line">finally&#123;</span><br><span class="line">   ...... //无论是否发生异常，都无条件执行的语句</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2. 使用细节：</span><br><span class="line">&gt; 将可能出现异常的代码声明在try语句中。一旦代码出现异常，就会自动生成一个对应异常类的对象。并将此对象抛出。</span><br><span class="line">&gt; 针对于try中抛出的异常类的对象，使用之后的catch语句进行匹配。一旦匹配上，就进入catch语句块进行处理。</span><br><span class="line">  一旦处理接触，代码就可继续向下执行。</span><br><span class="line">&gt; 如果声明了多个catch结构，不同的异常类型在不存在子父类关系的情况下，谁声明在上面，谁声明在下面都可以。</span><br><span class="line">  如果多个异常类型满足子父类的关系，则必须将子类声明在父类结构的上面。否则，报错。</span><br><span class="line">&gt; catch中异常处理的方式：</span><br><span class="line">   ① 自己编写输出的语句。</span><br><span class="line">   ② printStackTrace()：打印异常的详细信息。 （推荐）</span><br><span class="line">   ③ getMessage()：获取发生异常的原因。</span><br><span class="line">&gt; try中声明的变量，出了try结构之后，就不可以进行调用了。</span><br><span class="line">&gt; try-catch结构是可以嵌套使用的。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">3. finally的使用说明：</span><br><span class="line">3.1 finally的理解</span><br><span class="line">&gt; 我们将一定要被执行的代码声明在finally结构中。</span><br><span class="line">&gt; 更深刻的理解：无论try中或catch中是否存在仍未被处理的异常，无论try中或catch中是否存在return语句等，finally</span><br><span class="line">  中声明的语句都一定要被执行。</span><br><span class="line"></span><br><span class="line">&gt; finally语句和catch语句是可选的，但finally不能单独使用。</span><br><span class="line"></span><br><span class="line">3.2 什么样的代码我们一定要声明在finally中呢？</span><br><span class="line">&gt; 我们在开发中，有一些资源（比如：输入流、输出流，数据库连接、Socket连接等资源），在使用完以后，必须显式的进行</span><br><span class="line">关闭操作，否则，GC不会自动的回收这些资源。进而导致内存的泄漏。</span><br><span class="line">  为了保证这些资源在使用完以后，不管是否出现了未被处理的异常的情况下，这些资源能被关闭。我们必须将这些操作声明</span><br><span class="line">在finally中！</span><br></pre></td></tr></table></figure>

<h4 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. 格式：在方法的声明处，使用&quot;throws 异常类型1,异常类型2,...&quot;</span><br><span class="line"></span><br><span class="line">2. 举例：</span><br><span class="line"></span><br><span class="line">public void test() throws 异常类型1,异常类型2,.. &#123;</span><br><span class="line">    //可能存在编译时异常</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. 是否真正处理了异常？</span><br><span class="line">&gt; 从编译是否能通过的角度看，看成是给出了异常万一要是出现时候的解决方案。此方案就是，继续向上抛出(throws)。</span><br><span class="line">&gt; 但是，此throws的方式，仅是将可能出现的异常抛给了此方法的调用者。此调用者仍然需要考虑如何处理相关异常。</span><br><span class="line">  从这个角度来看，throws的方式不算是真正意义上处理了异常。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4. 方法的重写的要求：(针对于编译时异常来说的)</span><br><span class="line">子类重写的方法抛出的异常类型可以与父类被重写的方法抛出的异常类型相同，或是父类被重写的方法抛出的异常类型的子类。</span><br></pre></td></tr></table></figure>

<p>开发中的经验之谈：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">开发中，如何选择异常处理的两种方式？(重要、经验之谈)</span><br><span class="line">- 如果程序代码中，涉及到资源的调用（流、数据库连接、网络连接等），则必须考虑使用try-catch-finally来处理，</span><br><span class="line">  保证不出现内存泄漏。</span><br><span class="line">- 如果父类被重写的方法没有throws异常类型，则子类重写的方法中如果出现异常，只能考虑使用try-catch-finally</span><br><span class="line">  进行处理，不能throws。</span><br><span class="line">- 开发中，方法a中依次调用了方法b,c,d等方法，方法b,c,d之间是递进关系。此时，如果方法b,c,d中有异常，</span><br><span class="line">  我们通常选择使用throws，而方法a中通常选择使用try-catch-finally。</span><br></pre></td></tr></table></figure>

<h3 id="手动throw异常对象"><a href="#手动throw异常对象" class="headerlink" title="手动throw异常对象"></a>手动throw异常对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在方法内部，满足指定条件的情况下，使用&quot;throw 异常类的对象&quot;的方式抛出。</span><br></pre></td></tr></table></figure>

<h3 id="如何自定义异常类"><a href="#如何自定义异常类" class="headerlink" title="如何自定义异常类"></a>如何自定义异常类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">① 继承于现有的异常体系。通常继承于RuntimeException \ Exception</span><br><span class="line">② 通常提供几个重载的构造器</span><br><span class="line">③ 提供一个全局常量，声明为：static final long serialVersionUID;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为什么需要自定义异常类？</span><br><span class="line">我们其实更关心的是，通过异常的名称就能直接判断此异常出现的原因。既然如此，我们就有必要在实际开发场景中，</span><br><span class="line">不满足我们指定的条件时，指明我们自己特有的异常类。通过此异常类的名称，就能判断出具体出现的问题。</span><br></pre></td></tr></table></figure>

<h2 id="企业真题（九）"><a href="#企业真题（九）" class="headerlink" title="企业真题（九）"></a>企业真题（九）</h2><h3 id="2-1-异常概述"><a href="#2-1-异常概述" class="headerlink" title="2.1 异常概述"></a>2.1 异常概述</h3><h4 id="1-Java的异常体系简单介绍下（网-）"><a href="#1-Java的异常体系简单介绍下（网-）" class="headerlink" title="1. Java的异常体系简单介绍下（网*）"></a>1. Java的异常体系简单介绍下（网*）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">包含问题：</span><br><span class="line">&gt; 4.异常的顶级接口是什么（软**力）</span><br><span class="line">&gt; 异常类的继承关系,exception下都有哪些类？（上海*冉信息）</span><br></pre></td></tr></table></figure>

<p>略</p>
<h4 id="2-Java异常处理机制（-科软）"><a href="#2-Java异常处理机制（-科软）" class="headerlink" title="2. Java异常处理机制（*科软）"></a>2. Java异常处理机制（*科软）</h4><p>两种处理方案：try-catch-finally ；throws</p>
<h4 id="3-异常的两种类型，Error和Exception的区别-上海冠-新创、北京中-译、-度"><a href="#3-异常的两种类型，Error和Exception的区别-上海冠-新创、北京中-译、-度" class="headerlink" title="3. 异常的两种类型，Error和Exception的区别(上海冠*新创、北京中**译、*度)"></a>3. 异常的两种类型，Error和Exception的区别(上海冠*新创、北京中**译、*度)</h4><p>略</p>
<h4 id="4-运行时异常与一般异常有何异同？（华-思为）"><a href="#4-运行时异常与一般异常有何异同？（华-思为）" class="headerlink" title="4. 运行时异常与一般异常有何异同？（华*思为）"></a>4. 运行时异常与一般异常有何异同？（华*思为）</h4><p>运行时异常：RuntimeException</p>
<ul>
<li>编译可以通过。在运行时可能抛出。出现的概率高一些；一般针对于运行时异常，都不处理。</li>
</ul>
<p>一般异常：Exception</p>
<ul>
<li>编译不能通过。要求必须在编译之前，考虑异常的处理。不处理编译不通过。</li>
</ul>
<h4 id="5-说几个你常见到的异常（华油-普）"><a href="#5-说几个你常见到的异常（华油-普）" class="headerlink" title="5. 说几个你常见到的异常（华油**普）"></a>5. 说几个你常见到的异常（华油**普）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; 请列出Java中常见的几种异常？（百*园）</span><br><span class="line">&gt; 给我一个你最常见到的runtime exception。（*蝶）</span><br></pre></td></tr></table></figure>

<p>略</p>
<h3 id="2-2-try-catch-finally"><a href="#2-2-try-catch-finally" class="headerlink" title="2.2 try-catch-finally"></a>2.2 try-catch-finally</h3><h4 id="1-说说final、finally、finalize的区别（北京中-译、艾-软件、拓-思、-科软）"><a href="#1-说说final、finally、finalize的区别（北京中-译、艾-软件、拓-思、-科软）" class="headerlink" title="1. 说说final、finally、finalize的区别（北京中**译、艾*软件、拓*思、*科软）"></a>1. 说说final、finally、finalize的区别（北京中**译、艾*软件、拓*思、*科软）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; 1. finally和final的区别（*科软）</span><br></pre></td></tr></table></figure>

<p>略。</p>
<h4 id="2-如果不使用try-catch，程序出现异常会如何？-上海冠-新创科技"><a href="#2-如果不使用try-catch，程序出现异常会如何？-上海冠-新创科技" class="headerlink" title="2. 如果不使用try-catch，程序出现异常会如何？(上海冠*新创科技)"></a>2. 如果不使用try-catch，程序出现异常会如何？(上海冠*新创科技)</h4><p>对于当前方法来讲，如果不使用try-catch，则在出现异常对象以后会抛出此对象。如果没有处理方案，就会终止程序的执行。</p>
<h4 id="3-try-…-catch捕捉的是什么异常？（北京亿-东方）"><a href="#3-try-…-catch捕捉的是什么异常？（北京亿-东方）" class="headerlink" title="3. try … catch捕捉的是什么异常？（北京亿*东方）"></a>3. try … catch捕捉的是什么异常？（北京亿*东方）</h4><p>Exception。非Error</p>
<h4 id="4-如果执行finally代码块之前方法返回了结果或者jvm退出了，这时finally块中的代码还会执行吗-恒-电子"><a href="#4-如果执行finally代码块之前方法返回了结果或者jvm退出了，这时finally块中的代码还会执行吗-恒-电子" class="headerlink" title="4. 如果执行finally代码块之前方法返回了结果或者jvm退出了，这时finally块中的代码还会执行吗?(恒*电子)"></a>4. 如果执行finally代码块之前方法返回了结果或者jvm退出了，这时finally块中的代码还会执行吗?(恒*电子)</h4><p>特别的：System.exit(0);</p>
<h4 id="5-在try语句中有return语句，最后写finally语句，finally语句中的code会不会执行？何时执行？如果执行是在return前还是后（拓-思、华-为）"><a href="#5-在try语句中有return语句，最后写finally语句，finally语句中的code会不会执行？何时执行？如果执行是在return前还是后（拓-思、华-为）" class="headerlink" title="5. 在try语句中有return语句，最后写finally语句，finally语句中的code会不会执行？何时执行？如果执行是在return前还是后（拓*思、华**为）"></a>5. 在try语句中有return语句，最后写finally语句，finally语句中的code会不会执行？何时执行？如果执行是在return前还是后（拓*思、华**为）</h4><p>略</p>
<h4 id="6-捕获异常在catch块里一定会进入finally吗？catch里能return吗？catch里return还会进finally吗？在try里return是什么情况？（-蓝）"><a href="#6-捕获异常在catch块里一定会进入finally吗？catch里能return吗？catch里return还会进finally吗？在try里return是什么情况？（-蓝）" class="headerlink" title="6. 捕获异常在catch块里一定会进入finally吗？catch里能return吗？catch里return还会进finally吗？在try里return是什么情况？（*蓝）"></a>6. 捕获异常在catch块里一定会进入finally吗？catch里能return吗？catch里return还会进finally吗？在try里return是什么情况？（*蓝）</h4><p>略</p>
<h3 id="2-3-throw与throws"><a href="#2-3-throw与throws" class="headerlink" title="2.3 throw与throws"></a>2.3 throw与throws</h3><h4 id="1-throw和throws的区别？（北京亿-方、北京新-阳光）"><a href="#1-throw和throws的区别？（北京亿-方、北京新-阳光）" class="headerlink" title="1. throw和throws的区别？（北京亿**方、北京新*阳光）"></a>1. throw和throws的区别？（北京亿**方、北京新*阳光）</h4><p>角度1：”形”，即使用的格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">throw:使用在方法内部，“throw 异常类的对象”</span><br><span class="line">throws:使用在方法的声明处，&quot;throws 异常类1,异常类2,...&quot;</span><br></pre></td></tr></table></figure>

<p>角度2：”角色”或作用不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">上游排污，下游治污。</span><br><span class="line"></span><br><span class="line">过程1：“抛”</span><br><span class="line">	&gt;throw</span><br><span class="line">过程2：“抓”</span><br><span class="line">    &gt; try-catch ; throws</span><br></pre></td></tr></table></figure>



<h4 id="2-子类重写父类抛出异常的方法，能否抛出比父类更高级别的异常类（顺-）"><a href="#2-子类重写父类抛出异常的方法，能否抛出比父类更高级别的异常类（顺-）" class="headerlink" title="2. 子类重写父类抛出异常的方法，能否抛出比父类更高级别的异常类（顺*）"></a>2. 子类重写父类抛出异常的方法，能否抛出比父类更高级别的异常类（顺*）</h4><p>不能！</p>
<h3 id="2-4-自定义异常"><a href="#2-4-自定义异常" class="headerlink" title="2.4 自定义异常"></a>2.4 自定义异常</h3><h4 id="1-如何自定义一个异常？（-软国际）"><a href="#1-如何自定义一个异常？（-软国际）" class="headerlink" title="1. 如何自定义一个异常？（*软国际）"></a>1. 如何自定义一个异常？（*软国际）</h4><p>略</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">程序(program)：为完成特定任务，用某种语言编写的`一组指令的集合`。即指一段静态的代码。</span><br><span class="line"></span><br><span class="line">进程(process)：程序的一次执行过程，或是正在内存中运行的应用程序。程序是静态的，进程是动态的。</span><br><span class="line">              进程作为操作系统调度和分配资源的最小单位。</span><br><span class="line"></span><br><span class="line">线程(thread)：进程可进一步细化为线程，是程序内部的一条执行路径。</span><br><span class="line">             线程作为CPU调度和执行的最小单位</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">线程调度策略</span><br><span class="line">分时调度：所有线程`轮流使用` CPU 的使用权，并且平均分配每个线程占用 CPU 的时间。</span><br><span class="line"></span><br><span class="line">抢占式调度：让`优先级高`的线程以`较大的概率`优先使用 CPU。如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; 单核CPU与多核CPU</span><br><span class="line">• 单核 CPU，在一个时间单元内，只能执行一个线程的任务。</span><br><span class="line">&gt; 并行与并发</span><br><span class="line">• 并行（parallel）：指两个或多个事件在同一时刻发生（同时发生）。指在同一时刻，有多条指令在多个 CPU 上同时执行。比如：多个人同时做不同的事。  </span><br><span class="line">• 并发（concurrency）：指两个或多个事件在同一个时间段内发生。即在一段时间</span><br><span class="line">内，有多条指令在单个 CPU 上快速轮换、交替执行，使得在宏观上具有多个进程同时执行的效果。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-如何创建多线程（重点）"><a href="#2-如何创建多线程（重点）" class="headerlink" title="2. 如何创建多线程（重点）"></a>2. 如何创建多线程（重点）</h3><p>Java 语言的 JVM 允许程序运行多个线程，使用 java.lang.Thread 类代表线程，所有的线程对象都必须是 Thread 类或其子类的实例。  </p>
<ul>
<li>方式1：继承Thread类<br>  Thread 类的特性：<ol>
<li>每个线程都是通过某个特定 Thread 对象的 run()方法来完成操作的，因此<br>  把 run()方法体称为线程执行体。</li>
<li>通过该 Thread 对象的 start()方法来启动这个线程，而非直接调用 run()</li>
<li>要想实现多线程，必须在主线程中创建新的线程对象。</li>
</ol>
</li>
<li>方式2：实现Runnable接口  <ul>
<li>Java 有单继承的限制，当我们无法继承 Thread 类时，那么该如何做呢？在核心<br>类库中提供了 Runnable 接口，我们可以实现 Runnable 接口，重写 run()方法，<br>然后再通过 Thread 类的对象代理启动和执行我们的线程体 run()方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">//创建自定义类对象 线程任务对象</span></span><br><span class="line"><span class="type">MyRunnable</span> <span class="variable">mr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"><span class="comment">//创建线程对象</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr, <span class="string">&quot;长江&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>使用匿名内部类对象来实现线程的创建和启动  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;新的线程！&quot;</span>)&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      System.out.println(getName()+<span class="string">&quot;：正在执行！&quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName()+<span class="string">&quot;：&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>方式3：实现Callable接口 （jdk5.0新增）  <ul>
<li>与使用 Runnable 相比， Callable 功能更强大些<ol>
<li>相比 run()方法，可以有返回值</li>
<li>方法可以抛出异常</li>
<li>支持泛型的返回值（需要借助 FutureTask 类，获取返回结果）</li>
</ol>
</li>
<li>Future 接口（了解）<ol>
<li>可以对具体 Runnable、Callable 任务的执行结果进行取消、查询是否完成、获取结果等。</li>
<li>FutureTask 是 Futrue 接口的唯一的实现类</li>
<li>FutureTask 同时实现了 Runnable, Future 接口。它既可以作为Runnable 被线程执行，又可以作为 Future 得到 Callable 的返回值</li>
</ol>
</li>
<li>缺点：在获取分线程执行结果的时候，当前线程（或是主线程）受阻塞，效率较低。</li>
</ul>
</li>
<li>方式4：使用线程池（jdk5.0新增）  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">• ExecutorService：真正的线程池接口。常见子类 ThreadPoolExecutor</span><br><span class="line">– <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> ：执行任务/命令，没有返回值，一般用来执行 Runnable</span><br><span class="line">– &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>：执行任务，有返回值，一般又来执行 Callable</span><br><span class="line">– <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> ：关闭连接池</span><br><span class="line">• Executors：一个线程池的工厂类，通过此类的静态工厂方法可以创建多种类型的线程池对象。</span><br><span class="line">– Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池</span><br><span class="line">– Executors.newFixedThreadPool(<span class="type">int</span> nThreads); 创建一个可重用固定线程数的线程池</span><br><span class="line">– Executors.newSingleThreadExecutor() ：创建一个只有一个线程的线程池</span><br><span class="line">– Executors.newScheduledThreadPool(<span class="type">int</span> corePoolSize)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-Thread类的常用方法、线程的生命周期"><a href="#3-Thread类的常用方法、线程的生命周期" class="headerlink" title="3. Thread类的常用方法、线程的生命周期"></a>3. Thread类的常用方法、线程的生命周期</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">熟悉常用的构造器和方法：</span><br><span class="line">1. 线程中的构造器</span><br><span class="line">- public Thread() :分配一个新的线程对象。</span><br><span class="line">- public Thread(String name) :分配一个指定名字的新的线程对象。</span><br><span class="line">- public Thread(Runnable target) :指定创建线程的目标对象，它实现了Runnable接口中的run方法</span><br><span class="line">- public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字。</span><br><span class="line"></span><br><span class="line">2.线程中的常用方法：</span><br><span class="line">&gt; start():①启动线程 ②调用线程的run()</span><br><span class="line">&gt; run():将线程要执行的操作，声明在run()中。</span><br><span class="line">&gt; currentThread():获取当前执行代码对应的线程</span><br><span class="line">&gt; getName(): 获取线程名</span><br><span class="line">&gt; setName(): 设置线程名</span><br><span class="line">&gt; sleep(long millis):静态方法，调用时，可以使得当前线程睡眠指定的毫秒数</span><br><span class="line">&gt; yield():静态方法，一旦执行此方法，就释放CPU的执行权，让系统的线程调度器重新调度一次</span><br><span class="line">&gt; join(): 在线程a中通过线程b调用join()，意味着线程a进入阻塞状态，直到线程b执行结束，线程a才结束阻塞状态，继续执行。</span><br><span class="line">&gt; isAlive():判断当前线程是否存活</span><br><span class="line"></span><br><span class="line">3. 线程的优先级：</span><br><span class="line">getPriority():获取线程的优先级</span><br><span class="line">setPriority():设置线程的优先级。范围[1,10]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread类内部声明的三个常量：</span><br><span class="line">- MAX_PRIORITY（10）：最高优先级</span><br><span class="line">- MIN _PRIORITY （1）：最低优先级</span><br><span class="line">- NORM_PRIORITY （5）：普通优先级，默认情况下main线程具有普通优先级。</span><br></pre></td></tr></table></figure>

<p>线程的生命周期：</p>
<p>jdk5.0之前：</p>
<p>线程的生命周期有五种状态：新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）、死亡（Dead）</p>
<p>jdk5.0及之后：Thread类中定义了一个内部类State</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">        </span><br><span class="line">        NEW,</span><br><span class="line">    </span><br><span class="line">        RUNNABLE,</span><br><span class="line"></span><br><span class="line">        BLOCKED,</span><br><span class="line"></span><br><span class="line">        WAITING,</span><br><span class="line"></span><br><span class="line">        TIMED_WAITING,</span><br><span class="line"> </span><br><span class="line">        TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="4-如何解决线程安全问题-重点、难点"><a href="#4-如何解决线程安全问题-重点、难点" class="headerlink" title="4. 如何解决线程安全问题(重点、难点)"></a>4. 如何解决线程安全问题(重点、难点)</h3><ul>
<li><p>什么是线程的安全问题？多个线程操作共享数据，就有可能出现安全问题。</p>
</li>
<li><p>如何解决线程的安全问题？有几种方式？</p>
<ul>
<li>同步机制：① 同步代码块 ② 同步方法</li>
</ul>
<ol>
<li>同步代码块：synchronized 关键字可以用于某个区块前面，表示只对这个区块</li>
</ol>
</li>
</ul>
<p>的资源实行互斥访问  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步锁)&#123;</span><br><span class="line">需要同步操作的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>同步方法：synchronized 关键字直接修饰方法，表示同一时刻只有一个线程能<br>进入这个方法，其他线程在外面等着。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">可能会产生线程安全问题的代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<pre><code>- 重点关注两个事：共享数据及操作共享数据的代码；同步监视器（保证唯一性）

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在实现Runnable接口的方式中，同步监视器可以考虑使用：this。</span><br><span class="line">在继承Thread类的方式中，同步监视器要慎用this，可以考虑使用：当前类.class。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">非静态的同步方法，默认同步监视器是this</span><br><span class="line">静态的同步方法，默认同步监视器是当前类本身。</span><br></pre></td></tr></table></figure>
</code></pre>
<ul>
<li>jdk5.0新增：Lock接口及其实现类。（保证多个线程共用同一个Lock的实例）<br>  Lock 锁也称同步锁，加锁与释放锁方法，如下：<ul>
<li>public void lock() :加同步锁。</li>
<li>public void unlock() :释放同步锁。</li>
<li>synchronized 与 Lock 的对比<ol>
<li>Lock 是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized 是隐式锁，出了<br>作用域、遇到异常等自动解锁</li>
<li>Lock 只有代码块锁，synchronized 有代码块锁和方法锁</li>
<li>使用 Lock 锁，JVM 将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性<br>（提供更多的子类），更体现面向对象。</li>
<li>（了解）Lock 锁可以对读不加锁，对写加锁，synchronized 不可以</li>
<li>（了解）Lock 锁可以有多种获取锁的方式，可以从 sleep 的线程中抢到锁，<br>synchronized 不可以<br>说明：开发建议中处理线程安全问题优先使用顺序为：<br>Lock —-&gt; 同步代码块 —-&gt; 同步方法</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="5-同步机制相关的问题"><a href="#5-同步机制相关的问题" class="headerlink" title="5. 同步机制相关的问题"></a>5. 同步机制相关的问题</h3><ul>
<li>懒汉式的线程安全的写法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyOne</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> LazyOne instance;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">LazyOne</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="comment">//方式 1：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazyOne <span class="title function_">getInstance1</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">instance = <span class="keyword">new</span> <span class="title class_">LazyOne</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方式 2：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LazyOne <span class="title function_">getInstance2</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(LazyOne.class) &#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> <span class="title class_">LazyOne</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方式 3：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LazyOne <span class="title function_">getInstance3</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (LazyOne.class) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">10</span>);<span class="comment">//加这个代码，暴露问题</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">instance = <span class="keyword">new</span> <span class="title class_">LazyOne</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意：上述方式 3 中，有指令重排问题</span></span><br><span class="line"><span class="comment">mem = allocate(); 为单例对象分配内存空间</span></span><br><span class="line"><span class="comment">instance = mem; instance 引用现在非空，但还未初始化</span></span><br><span class="line"><span class="comment">ctorSingleton(instance); 为单例对象通过 instance 调用构造器</span></span><br><span class="line"><span class="comment">从 JDK2 开始，分配空间、初始化、调用构造器会在线程的工作存储区一次性完</span></span><br><span class="line"><span class="comment">成，然后复制到主存储区。但是需要 </span></span><br><span class="line"><span class="comment">volatile 关键字，避免指令重排。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>同步机制会带来的问题：死锁<ul>
<li>死锁产生的条件及规避方式<br>• 互斥条件<br>• 占用且等待<br>• 不可抢夺（或不可抢占）<br>• 循环等待<br>以上 4 个条件，同时出现就会触发死锁。</li>
</ul>
</li>
</ul>
<h3 id="6-线程间的通信"><a href="#6-线程间的通信" class="headerlink" title="6. 线程间的通信"></a>6. 线程间的通信</h3><ul>
<li><p>在同步机制下，考虑线程间的通信</p>
</li>
<li><p>wait() 、notify() 、notifyAll() 都需要使用在同步代码块或同步方法中。</p>
</li>
<li><p>高频笔试题：wait() &#x2F; sleep()<br>相同点：一旦执行，都会使得当前线程结束执行状态，进入阻塞状态。<br>不同点：<br>① 定义方法所属的类：sleep():Thread 中定义。 wait():Object 中定义<br>② 使用范围的不同：sleep()可以在任何需要使用的位置被调用； wait():必须使<br>用在同步代码块或同步方法中<br>③ 都在同步结构中使用的时候，是否释放同步监视器的操作不同：sleep():不会<br>释放同步监视器 ;wait():会释放同步监视器<br>④ 结束等待的方式不同：sleep()：指定时间一到就结束阻塞。 wait():可以指定<br>时间也可以无限等待直到 notify 或 notifyAll。</p>
</li>
</ul>
<h2 id="企业真题（十）"><a href="#企业真题（十）" class="headerlink" title="企业真题（十）"></a>企业真题（十）</h2><h3 id="2-1-线程概述"><a href="#2-1-线程概述" class="headerlink" title="2.1 线程概述"></a>2.1 线程概述</h3><h4 id="1-什么是线程-云网络"><a href="#1-什么是线程-云网络" class="headerlink" title="1. 什么是线程(*云网络)"></a>1. 什么是线程(*云网络)</h4><p>略</p>
<h4 id="2-线程和进程有什么区别-团、腾-、-云网络、神-岳、言-有物、直-科技"><a href="#2-线程和进程有什么区别-团、腾-、-云网络、神-岳、言-有物、直-科技" class="headerlink" title="2. 线程和进程有什么区别(*团、腾*、*云网络、神**岳、言*有物、直*科技)"></a>2. 线程和进程有什么区别(*团、腾*、*云网络、神**岳、言*有物、直*科技)</h4><p>进程：对应一个运行中的程序。</p>
<p>线程：运行中的进程的一条或多条执行路径。</p>
<h4 id="3-多线程使用场景（嘉-医疗）"><a href="#3-多线程使用场景（嘉-医疗）" class="headerlink" title="3. 多线程使用场景（嘉*医疗）"></a>3. 多线程使用场景（嘉*医疗）</h4><ul>
<li>手机app应用的图片的下载</li>
<li>迅雷的下载</li>
<li>Tomcat服务器上web应用，多个客户端发起请求，Tomcat针对多个请求开辟多个线程处理</li>
</ul>
<h3 id="2-2-如何实现多线程"><a href="#2-2-如何实现多线程" class="headerlink" title="2.2 如何实现多线程"></a>2.2 如何实现多线程</h3><h4 id="1-如何在Java中出实现多线程？-阿-校招、当-置业、鸿-网络、奥-医药、-科软、慧-、上海驿-软件、海-科"><a href="#1-如何在Java中出实现多线程？-阿-校招、当-置业、鸿-网络、奥-医药、-科软、慧-、上海驿-软件、海-科" class="headerlink" title="1. 如何在Java中出实现多线程？(阿*校招、当*置业、鸿*网络、奥*医药、*科软、慧*、上海驿*软件、海*科)"></a>1. 如何在Java中出实现多线程？(阿*校招、当*置业、鸿*网络、奥*医药、*科软、慧*、上海驿*软件、海*科)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; 创建多线程用Runnable还是Thread(北京中*瑞飞)</span><br><span class="line">&gt; 多线程有几种实现方法，都是什么？（锐*（上海）企业管理咨询）</span><br></pre></td></tr></table></figure>

<p>四种。</p>
<h4 id="2-Thread类中的start-和run-有什么区别？-北京中油-、爱-信、神-泰岳、直-科技，-软国际，上海-学网络"><a href="#2-Thread类中的start-和run-有什么区别？-北京中油-、爱-信、神-泰岳、直-科技，-软国际，上海-学网络" class="headerlink" title="2. Thread类中的start()和run()有什么区别？(北京中油**、爱*信、神*泰岳、直*科技，*软国际，上海*学网络)"></a>2. Thread类中的start()和run()有什么区别？(北京中油**、爱*信、神*泰岳、直*科技，*软国际，上海*学网络)</h4><p>start()：① 开启线程 ② 调用线程的run()</p>
<h4 id="3-启动一个线程是用run-还是start-（-度）"><a href="#3-启动一个线程是用run-还是start-（-度）" class="headerlink" title="3. 启动一个线程是用run()还是start()?（*度）"></a>3. 启动一个线程是用run()还是start()?（*度）</h4><p>start()</p>
<h4 id="4-Java中Runnable和Callable有什么不同？-平-金服、银-数据、好-在、亿-征信、花儿-网络"><a href="#4-Java中Runnable和Callable有什么不同？-平-金服、银-数据、好-在、亿-征信、花儿-网络" class="headerlink" title="4. Java中Runnable和Callable有什么不同？(平*金服、银*数据、好*在、亿*征信、花儿**网络)"></a>4. Java中Runnable和Callable有什么不同？(平*金服、银*数据、好*在、亿*征信、花儿**网络)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">与之前的方式的对比：与Runnable方式的对比的好处</span><br><span class="line">&gt; call()可以有返回值，更灵活</span><br><span class="line">&gt; call()可以使用throws的方式处理异常，更灵活</span><br><span class="line">&gt; Callable使用了泛型参数，可以指明具体的call()的返回值类型，更灵活</span><br><span class="line"></span><br><span class="line">有缺点吗？如果在主线程中需要获取分线程call()的返回值，则此时的主线程是阻塞状态的。</span><br></pre></td></tr></table></figure>

<h4 id="5-什么是线程池，为什么要使用它？-上海明-物联网科技"><a href="#5-什么是线程池，为什么要使用它？-上海明-物联网科技" class="headerlink" title="5. 什么是线程池，为什么要使用它？(上海明*物联网科技)"></a>5. 什么是线程池，为什么要使用它？(上海明*物联网科技)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">此方式的好处：</span><br><span class="line">&gt; 提高了程序执行的效率。（因为线程已经提前创建好了）</span><br><span class="line">&gt; 提高了资源的复用率。（因为执行完的线程并未销毁，而是可以继续执行其他的任务）</span><br><span class="line">&gt; 可以设置相关的参数，对线程池中的线程的使用进行管理</span><br></pre></td></tr></table></figure>

<h3 id="2-3-常用方法、生命周期"><a href="#2-3-常用方法、生命周期" class="headerlink" title="2.3 常用方法、生命周期"></a>2.3 常用方法、生命周期</h3><h4 id="1-sleep-和-yield-区别？-神-泰岳"><a href="#1-sleep-和-yield-区别？-神-泰岳" class="headerlink" title="1. sleep() 和 yield()区别？(神*泰岳)"></a>1. sleep() 和 yield()区别？(神*泰岳)</h4><p>sleep()：一旦调用，就进入“阻塞”（或TIMED_WAITING状态）</p>
<p>yield():释放cpu的执行权，处在RUNNABLE的状态</p>
<h4 id="2-线程创建中的方法、属性情况？-招通-、数-互融"><a href="#2-线程创建中的方法、属性情况？-招通-、数-互融" class="headerlink" title="2. 线程创建中的方法、属性情况？(招通**、数*互融)"></a>2. 线程创建中的方法、属性情况？(招通**、数*互融)</h4><p>略</p>
<h4 id="3-线程的生命周期？-中国-电子商务中心、-科软、慧"><a href="#3-线程的生命周期？-中国-电子商务中心、-科软、慧" class="headerlink" title="3. 线程的生命周期？(中国**电子商务中心、*科软、慧*)"></a>3. 线程的生命周期？(中国**电子商务中心、*科软、慧*)</h4><p>略</p>
<h4 id="4-线程的基本状态以及状态之间的关系？-直-科技"><a href="#4-线程的基本状态以及状态之间的关系？-直-科技" class="headerlink" title="4. 线程的基本状态以及状态之间的关系？(直*科技)"></a>4. 线程的基本状态以及状态之间的关系？(直*科技)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; 线程有哪些状态？如何让线程进入阻塞？（华*中*，*兴）</span><br><span class="line">&gt; 线程有几个状态，就绪和阻塞有什么不同。（美*）</span><br><span class="line">&gt; Java的线程都有哪几种状态（字*跳动、*东、*手）</span><br></pre></td></tr></table></figure>

<p>略</p>
<h4 id="5-stop-和suspend-方法为何不推荐使用？（上海驿-软件）"><a href="#5-stop-和suspend-方法为何不推荐使用？（上海驿-软件）" class="headerlink" title="5. stop()和suspend()方法为何不推荐使用？（上海驿*软件）"></a>5. stop()和suspend()方法为何不推荐使用？（上海驿*软件）</h4><p>stop()：一旦执行，线程就结束了，导致run()有未执行结束的代码。stop()会导致释放同步监视器，导致线程安全问题。</p>
<p>suspend()：与resume()搭配使用，导致死锁。</p>
<h4 id="6-Java-线程优先级是怎么定义的？（软-动力）"><a href="#6-Java-线程优先级是怎么定义的？（软-动力）" class="headerlink" title="6. Java 线程优先级是怎么定义的？（软*动力）"></a>6. Java 线程优先级是怎么定义的？（软*动力）</h4><p>三个常量。[1,10]</p>
<h3 id="2-4-线程安全与同步机制"><a href="#2-4-线程安全与同步机制" class="headerlink" title="2.4 线程安全与同步机制"></a>2.4 线程安全与同步机制</h3><h4 id="1-你如何理解线程安全的？线程安全问题是如何造成的？（-软国际）"><a href="#1-你如何理解线程安全的？线程安全问题是如何造成的？（-软国际）" class="headerlink" title="1. 你如何理解线程安全的？线程安全问题是如何造成的？（*软国际）"></a>1. 你如何理解线程安全的？线程安全问题是如何造成的？（*软国际）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; 线程安全说一下？（奥*医药）</span><br><span class="line">&gt; 对线程安全的理解（*度校招）</span><br><span class="line">&gt; 什么是线程安全？(银*数据)</span><br></pre></td></tr></table></figure>

<p>略</p>
<h4 id="2-多线程共用一个数据变量需要注意什么？（史-夫软件）"><a href="#2-多线程共用一个数据变量需要注意什么？（史-夫软件）" class="headerlink" title="2. 多线程共用一个数据变量需要注意什么？（史*夫软件）"></a>2. 多线程共用一个数据变量需要注意什么？（史*夫软件）</h4><p>线程安全问题</p>
<h4 id="3-多线程保证线程安全一般有几种方式？（来-科技、北京-信天-）"><a href="#3-多线程保证线程安全一般有几种方式？（来-科技、北京-信天-）" class="headerlink" title="3. 多线程保证线程安全一般有几种方式？（来*科技、北京*信天*）"></a>3. 多线程保证线程安全一般有几种方式？（来*科技、北京*信天*）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; 如何解决其线程安全问题，并且说明为什么这样子去解决？（北京联合**）</span><br><span class="line">&gt; 请说出你所知道的线程同步的方法。（天*伟业）</span><br><span class="line">&gt; 哪些方法实现线程安全？（阿*）   </span><br><span class="line">&gt; 同步有几种实现方法，都是什么? （锐*企业管理咨询）</span><br><span class="line">&gt; 你在实际编码过程中如何避免线程安全问题？（*软国际）</span><br><span class="line">&gt; 如何让线程同步?（*手）</span><br><span class="line">&gt; 多线程下有什么同步措施（阿*校招）</span><br><span class="line">&gt; 同步有几种实现方法，都是什么？（海*科）</span><br></pre></td></tr></table></figure>

<ul>
<li>同步机制</li>
<li>Lock接口</li>
</ul>
<h4 id="4-用什么关键字修饰同步方法-（上海驿-软件）"><a href="#4-用什么关键字修饰同步方法-（上海驿-软件）" class="headerlink" title="4. 用什么关键字修饰同步方法?（上海驿*软件）"></a>4. 用什么关键字修饰同步方法?（上海驿*软件）</h4><p>synchronized</p>
<h4 id="5-synchronized加在静态方法和普通方法区别（来-科技）"><a href="#5-synchronized加在静态方法和普通方法区别（来-科技）" class="headerlink" title="5. synchronized加在静态方法和普通方法区别（来*科技）"></a>5. synchronized加在静态方法和普通方法区别（来*科技）</h4><p>同步监视器不同。静态：当前类本身   非静态：this</p>
<h4 id="6-Java中synchronized和ReentrantLock有什么不同-三-重工"><a href="#6-Java中synchronized和ReentrantLock有什么不同-三-重工" class="headerlink" title="6. Java中synchronized和ReentrantLock有什么不同(三*重工)"></a>6. Java中synchronized和ReentrantLock有什么不同(三*重工)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; 多线程安全机制中 synchronized和lock的区别（中*国际、*美、鸿*网络）</span><br><span class="line">&gt; 怎么实现线程安全，各个实现方法有什么区别？（美*、字*跳动）</span><br><span class="line">&gt; synchronized 和 lock 区别（阿*、*壳）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized不管是同步代码块还是同步方法，都需要在结束一对&#123;&#125;之后，释放对同步监视器的调用。</span><br><span class="line">Lock是通过两个方法控制需要被同步的代码，更灵活一些。</span><br><span class="line">Lock作为接口，提供了多种实现类，适合更多更复杂的场景，效率更高。</span><br></pre></td></tr></table></figure>



<h4 id="7-当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法-（鸿-网络）"><a href="#7-当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法-（鸿-网络）" class="headerlink" title="7. 当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?（鸿*网络）"></a>7. 当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?（鸿*网络）</h4><p>需要看其他方法是否使用synchronized修饰，同步监视器的this是否是同一个。</p>
<p>只有当使用了synchronized，且this是同一个的情况下，就不能访问了。</p>
<h4 id="8-线程同步与阻塞的关系？同步一定阻塞吗？阻塞一定同步吗？（阿-校招、西安-创佳-）"><a href="#8-线程同步与阻塞的关系？同步一定阻塞吗？阻塞一定同步吗？（阿-校招、西安-创佳-）" class="headerlink" title="8. 线程同步与阻塞的关系？同步一定阻塞吗？阻塞一定同步吗？（阿*校招、西安*创佳*）"></a>8. 线程同步与阻塞的关系？同步一定阻塞吗？阻塞一定同步吗？（阿*校招、西安*创佳*）</h4><p>同步一定阻塞；阻塞不一定同步。</p>
<h3 id="2-5-死锁"><a href="#2-5-死锁" class="headerlink" title="2.5 死锁"></a>2.5 死锁</h3><h4 id="1-什么是死锁，产生死锁的原因及必要条件（腾-、阿-）"><a href="#1-什么是死锁，产生死锁的原因及必要条件（腾-、阿-）" class="headerlink" title="1. 什么是死锁，产生死锁的原因及必要条件（腾*、阿*）"></a>1. 什么是死锁，产生死锁的原因及必要条件（腾*、阿*）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1. 如何看待死锁？</span><br><span class="line">不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。</span><br><span class="line">我们编写程序时，要避免出现死锁。</span><br><span class="line"></span><br><span class="line">2. 诱发死锁的原因？</span><br><span class="line">- 互斥条件</span><br><span class="line">- 占用且等待</span><br><span class="line">- 不可抢夺（或不可抢占）</span><br><span class="line">- 循环等待</span><br><span class="line"></span><br><span class="line">以上4个条件，同时出现就会触发死锁。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. 如何避免死锁？</span><br><span class="line">针对条件1：互斥条件基本上无法被破坏。因为线程需要通过互斥解决安全问题。</span><br><span class="line">针对条件2：可以考虑一次性申请所有所需的资源，这样就不存在等待的问题。</span><br><span class="line">针对条件3：占用部分资源的线程在进一步申请其他资源时，如果申请不到，就主动释放掉已经占用的资源。</span><br><span class="line">针对条件4：可以将资源改为线性顺序。申请资源时，先申请序号较小的，这样避免循环等待问题。</span><br></pre></td></tr></table></figure>

<h4 id="2-如何避免死锁？-阿-、北京-蓝、-手"><a href="#2-如何避免死锁？-阿-、北京-蓝、-手" class="headerlink" title="2. 如何避免死锁？(阿*、北京*蓝、*手)"></a>2. 如何避免死锁？(阿*、北京*蓝、*手)</h4><p>见上。</p>
<h3 id="2-6-线程通信"><a href="#2-6-线程通信" class="headerlink" title="2.6 线程通信"></a>2.6 线程通信</h3><h4 id="1-Java中notify-和notifyAll-有什么区别-汇-天下"><a href="#1-Java中notify-和notifyAll-有什么区别-汇-天下" class="headerlink" title="1. Java中notify()和notifyAll()有什么区别(汇*天下)"></a>1. Java中notify()和notifyAll()有什么区别(汇*天下)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">notify():一旦执行此方法，就会唤醒被wait()的线程中优先级最高的那一个线程。（如果被wait()的多个线程的优先级相同，则</span><br><span class="line">         随机唤醒一个）。被唤醒的线程从当初被wait的位置继续执行。</span><br><span class="line">notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。</span><br></pre></td></tr></table></figure>

<h4 id="2-为什么wait-和notify-方法要在同步块中调用-北京-智"><a href="#2-为什么wait-和notify-方法要在同步块中调用-北京-智" class="headerlink" title="2. 为什么wait()和notify()方法要在同步块中调用(北京*智)"></a>2. 为什么wait()和notify()方法要在同步块中调用(北京*智)</h4><p>因为调用者必须是同步监视器。</p>
<h4 id="3-多线程：生产者，消费者代码（同步、wait、notifly编程）（猫-娱乐）"><a href="#3-多线程：生产者，消费者代码（同步、wait、notifly编程）（猫-娱乐）" class="headerlink" title="3. 多线程：生产者，消费者代码（同步、wait、notifly编程）（猫*娱乐）"></a>3. 多线程：生产者，消费者代码（同步、wait、notifly编程）（猫*娱乐）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; 如何写代码来解决生产者消费者问题(上海明*物联网)</span><br><span class="line">&gt; 多线程中生产者和消费者如何保证同步（*为）</span><br><span class="line">&gt; 消费者生产者，写写伪代码（字*）</span><br></pre></td></tr></table></figure>

<p>略</p>
<h4 id="4-wait-和sleep-有什么区别？调用这两个函数后，线程状态分别作何改变？（字-、-东）"><a href="#4-wait-和sleep-有什么区别？调用这两个函数后，线程状态分别作何改变？（字-、-东）" class="headerlink" title="4. wait()和sleep()有什么区别？调用这两个函数后，线程状态分别作何改变？（字*、*东）"></a>4. wait()和sleep()有什么区别？调用这两个函数后，线程状态分别作何改变？（字*、*东）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; 线程中sleep()和wait()有什么区别？（外派*度）</span><br><span class="line">&gt; Java线程阻塞调用 wait 函数和 sleep 区别和联系（阿*）</span><br><span class="line">&gt; wait和sleep的区别，他们两个谁会释放锁（软*动力、*创）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">相同点：一旦执行，当前线程都会进入阻塞状态</span><br><span class="line"></span><br><span class="line">不同点：</span><br><span class="line">&gt; 声明的位置：wait():声明在Object类中</span><br><span class="line">            sleep():声明在Thread类中，静态的</span><br><span class="line">&gt; 使用的场景不同：wait():只能使用在同步代码块或同步方法中</span><br><span class="line">               sleep():可以在任何需要使用的场景</span><br><span class="line">&gt; 使用在同步代码块或同步方法中：wait():一旦执行，会释放同步监视器</span><br><span class="line">                          sleep():一旦执行，不会释放同步监视器</span><br><span class="line">&gt; 结束阻塞的方式：wait(): 到达指定时间自动结束阻塞 或 通过被notify唤醒，结束阻塞</span><br><span class="line">               sleep(): 到达指定时间自动结束阻塞</span><br></pre></td></tr></table></figure>



<h3 id="2-7-单例模式（线程安全）"><a href="#2-7-单例模式（线程安全）" class="headerlink" title="2.7 单例模式（线程安全）"></a>2.7 单例模式（线程安全）</h3><h4 id="1-手写一个单例模式-Singleton-，还要安全的（-通快递、君-科技）"><a href="#1-手写一个单例模式-Singleton-，还要安全的（-通快递、君-科技）" class="headerlink" title="1. 手写一个单例模式(Singleton)，还要安全的（*通快递、君*科技）"></a>1. 手写一个单例模式(Singleton)，还要安全的（*通快递、君*科技）</h4><p>饿汉式；安全的懒汉式；内部类；</p>
<h4 id="2-手写一个懒汉式的单例模式-amp-解决其线程安全问题，并且说明为什么这样子去解决（5-）"><a href="#2-手写一个懒汉式的单例模式-amp-解决其线程安全问题，并且说明为什么这样子去解决（5-）" class="headerlink" title="2. 手写一个懒汉式的单例模式&amp;解决其线程安全问题，并且说明为什么这样子去解决（5*）"></a>2. 手写一个懒汉式的单例模式&amp;解决其线程安全问题，并且说明为什么这样子去解决（5*）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; 手写一个懒汉式的单例模式（北京联合**）</span><br></pre></td></tr></table></figure>

<p>同上。</p>
<h2 id="常用类与基础API"><a href="#常用类与基础API" class="headerlink" title="常用类与基础API"></a>常用类与基础API</h2><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p>java.lang.String，字符串是常量，用双引号引起来表示。它们的值在创建之后不能更改</p>
<ul>
<li>String的声明：final修饰、实现了Comparable接口</li>
<li>String的不可变性<ol>
<li>当对字符串变量重新赋值时，需要重新指定一个字符串常量的位置进行赋值，不能在原有的位置修改  </li>
<li>当对现有的字符串进行拼接或replace()操作时，需要重新开辟空间保存操作后的字符串，不能在原有的位置修改</li>
</ol>
</li>
<li>String的两种定义方式：① 字面量的定义方式 String s &#x3D; “hello” ② new 的方式：String s &#x3D; new String(“hello”); <ul>
<li>String的内存解析：字符串常量池、堆内存的使用</li>
<li>String s &#x3D; new String(“hello”);在内存中创建的对象的个数。→ 创建了两个对象</li>
</ul>
</li>
<li>String的连接操作：+<ul>
<li>常量 + 常量：结果仍然存储在字符串常量池中，返回此字面量地址，此时的常量可能是字面量，也可能是final修饰的变量 、变量 + 常量 or 变量 + 变量：都会通过new的方式创建一个新的字符串，返回堆空间中此字符串对象的地址、concat(String otherString)：调用完都返回一个新new的对象</li>
<li>String intern()：返回的是字符串常量池中字面量的地址</li>
</ul>
</li>
<li>熟悉String的构造器、与其他结构之间的转换<ul>
<li>字符串 –&gt; 基本数据类型、包装类 public static int parseInt(String s)  </li>
<li>基本数据类型、包装类 –&gt; 字符串 public String valueOf(int n)  </li>
<li>字符串 –&gt; 字符数组 public char[] toCharArray()：将字符串中的全部字符存放在一个字符数组中的方法。public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)：提供了将指定索引范围内的字符串存放到数组中的方法  </li>
<li>字符数组 –&gt; 字符串 String 类的构造器</li>
<li>编码和解码<ul>
<li>编码：字符、字符串 –&gt; 字节、字节数组。对应着编码集</li>
<li>解码：字节、字节数组 –&gt; 字符、字符串。对应着解码集 在utf-8字符集中，一个汉字占用3个字节，一个字母1个字节，在gbk字符集中，一个汉字占用2个字节，一个字母1个字节 均向下兼容ASCII码</li>
<li>规则：解码集必须使用当初编码时使用的编码集。只要不一致，就可能出现乱码！</li>
</ul>
</li>
</ul>
</li>
<li>String常用方法  <ol>
<li>boolean isEmpty()：字符串是否为空  </li>
<li>int length()：返回字符串的长度  </li>
<li>String concat(xx)：拼接  </li>
<li>boolean equals(Object obj)：比较字符串是否相等，区分大小写  </li>
<li>boolean equalsIgnoreCase(Object obj)：比较字符串是否相等，不区分大小写  </li>
<li>int compareTo(String other)：比较字符串大小，区分大小写，按照 Unicode 编码值比较大小  </li>
<li>int compareToIgnoreCase(String other)：比较字符串大小，不区分大小写  </li>
<li>String toLowerCase()：将字符串中大写字母转为小写  </li>
<li>String toUpperCase()：将字符串中小写字母转为大写  </li>
<li>String trim()：去掉字符串前后空白符  </li>
<li>public String intern()：结果在常量池中共享  </li>
<li>boolean contains(xx)：是否包含 xx  </li>
<li>int indexOf(xx)：从前往后找当前字符串中 xx，即如果有返回第一次出现的下标，要是没有返回-1  </li>
<li>int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始  </li>
<li>int lastIndexOf(xx)：从后往前找当前字符串中 xx，即如果有返回最后一次出现的下标，要是没有返回-1  </li>
<li>int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。  </li>
<li>String substring(int beginIndex) ：返回一个新的字符串，它是此字符串<br>的从 beginIndex 开始截取到最后的一个子字符串。  </li>
<li>String substring(int beginIndex, int endIndex) ：返回一个新字符串，它是此字符串从 beginIndex 开始截取到 endIndex(不包含)的一个子字符串。  </li>
<li>char charAt(index)：返回index位置的字符  </li>
<li>char[] toCharArray()： 将此字符串转换为一个新的字符数组返回  </li>
<li>static String valueOf(char[] data) ：返回指定数组中表示该字符序列的 String  </li>
<li>static String valueOf(char[] data, int offset, int count) ： 返回指定数组中表示该字符序列的 String  </li>
<li>static String copyValueOf(char[] data)： 返回指定数组中表示该字符序列的 String  </li>
<li>static String copyValueOf(char[] data, int offset, int count)：返回指定数组中表示该字符序列的 String  </li>
<li>boolean startsWith(xx)：测试此字符串是否以指定的前缀开始  </li>
<li>boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始  </li>
<li>boolean endsWith(xx)：测试此字符串是否以指定的后缀结束  </li>
<li>String replace(char oldChar, char newChar)：返回一个新的字符串，它是<br>通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 不支持正则。  </li>
<li>String replace(CharSequence target, CharSequence replacement)：<br>使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。  </li>
<li>String replaceAll(String regex, String replacement)：使用给定的replacement 替换此字符串所有匹配给定的正则表达式的子字符串。  </li>
<li>String replaceFirst(String regex, String replacement)：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</li>
</ol>
</li>
<li>String相关的算法问题。  <ol>
<li>模拟一个 trim 方法，去除字符串两端的空格。  </li>
<li>将一个字符串进行反转。将字符串中指定部分进行反转。比如“abcdefg”反转为”abfedcg”  </li>
<li>获取一个字符串在另一个字符串中出现的次数。 比如：获取“ ab”在“abkkcadkabkebfkabkskab” 中出现的次数  </li>
<li>获取两个字符串中最大相同子串。比如： str1 &#x3D; “abcwerthelloyuiodef”;str2 &#x3D; “cvhellobnm” 提示：将短的那个串进行长度依次递减的子串与较长的串比较。  </li>
<li>对字符串中字符进行自然顺序排序。 提示： 1）字符串变成字符数组。 2）对数组排序，选择，冒泡，Arrays.sort(); 3）将排序后的数组变成字符串。</li>
</ol>
</li>
</ul>
<h3 id="StringBuffer、StringBuilder类"><a href="#StringBuffer、StringBuilder类" class="headerlink" title="StringBuffer、StringBuilder类"></a>StringBuffer、StringBuilder类</h3><p>因为 String 对象是不可变对象，虽然可以共享常量对象，但是对于频繁字符串的修改和拼接操作，效率极低，空间消耗也比较高。因此，JDK 又在 java.lang包提供了可变字符序列 StringBuffer 和 StringBuilder 类型。</p>
<ul>
<li><p>[面试题]String、StringBuffer、StringBuilder的区别  </p>
<blockquote>
<p>String:不可变的字符序列;底层使用char[] （jdk8及之前），底层使用byte[] （jdk9及之后）<br>StringBuffer:可变的字符序列;JDK1.0声明，线程安全的，效率低;底层使用char[] （jdk8及之前），底层使用byte[] （jdk9及之后）<br>StringBuilder:可变的字符序列;JDK5.0声明，线程不安全的,效率高;底层使用char[] （jdk8及之前），底层使用byte[] （jdk9及之后）</p>
</blockquote>
</li>
<li><p>知道什么场景下使用StringBuffer、StringBuilder  </p>
<blockquote>
<p>如果开发中需要频繁的针对于字符串进行增、删、改等操作，建议使用StringBuffer或StringBuilder替换String.<br>因为使用String效率低。<br>如果开发中，不涉及到线程安全问题，建议使用StringBuilder替换StringBuffer。因为使用StringBuilder效率高<br>如果开发中大体确定要操作的字符的个数，建议使用带int capacity参数的构造器。因为可以避免底层多次扩容操作，性能更高。  </p>
</blockquote>
</li>
<li><p>StringBuffer和StringBuilder中的常用方法<br>增：<br>  append(xx)<br>删：<br>  delete(int start, int end)<br>  deleteCharAt(int index)<br>改：<br>  replace(int start, int end, String str)<br>  setCharAt(int index, char c)<br>查：<br>  charAt(int index)<br>插：<br>  insert(int index, xx)<br>长度：<br>  length()  </p>
</li>
<li><p>执行效率：StringBuilder &gt; StringBuffer &gt; String（从高到低）</p>
</li>
</ul>
<h3 id="jdk8之前的日期、时间API"><a href="#jdk8之前的日期、时间API" class="headerlink" title="jdk8之前的日期、时间API"></a>jdk8之前的日期、时间API</h3><ul>
<li>System的currentTimeMillis()</li>
<li>两个Date的使用  <ol>
<li>java.util.Date:getTime(),toString(),很多过时的方法  </li>
<li>java.sql.Date</li>
</ol>
</li>
<li>java.text.SimpleDateFormat,SimpleDateFormat类是一个不与语言环境有关的方式来格式化和解析日期的具体类</li>
<li>Calendar日历类的使用,使用 Calendar.getInstance()方法获取 Calendar 实例<ul>
<li>public int get(int field)：返回给定日历字段的值</li>
<li>public void set(int field,int value) ：将给定的日历字段设置为指定的值</li>
<li>public void add(int field,int amount)：根据日历的规则，为给定的日历字段添加或者减去指定的时间量</li>
<li>public final Date getTime()：将 Calendar 转成 Date 对象</li>
<li>public final void setTime(Date date)：使用指定的 Date 对象重置 Calendar的时间</li>
</ul>
</li>
</ul>
<h3 id="jdk8中新的日期、时间API"><a href="#jdk8中新的日期、时间API" class="headerlink" title="jdk8中新的日期、时间API"></a>jdk8中新的日期、时间API</h3><p>之前API面临的问题：  </p>
<ol>
<li>可变性：像日期和时间这样的类应该是不可变的。</li>
<li>偏移性：Date 中的年份是从 1900 开始的，而月份都从 0 开始。</li>
<li>格式化：格式化只对 Date 有用，Calendar 则不行。</li>
<li>此外，它们也不是线程安全的；不能处理闰秒等。</li>
</ol>
<ul>
<li>LocalDate、LocalTime、LocalDateTime –&gt;类似于Calendar</li>
<li>Instant  –&gt;类似于Date</li>
<li>DateTimeFormatter —&gt;类似于SimpleDateFormat</li>
</ul>
<h3 id="比较器-重点"><a href="#比较器-重点" class="headerlink" title="比较器(重点)"></a>比较器(重点)</h3><ul>
<li>自然排序</li>
</ul>
<ol>
<li>涉及到java.lang.Comparable，实现 Comparable 的类必须实现 compareTo(Object obj)方法，两个对象即通过<br>compareTo(Object obj) 方法的返回值来比较大小。如果当前对象 this 大于形参对象obj，则返回正整数，如果当前对象 this 小于形参对象 obj，则返回负整数，如果当前对象 this 等于形参对象 obj，则返回零。  </li>
<li>实现 Comparable 接口的对象列表（和数组）可以通过 Collections.sort 或Arrays.sort 进行自动排序。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。  </li>
<li>Comparable 的典型实现：</li>
</ol>
<ul>
<li><p>String：按照字符串中字符的 Unicode 值进行比较</p>
</li>
<li><p>Character：按照字符的 Unicode 值来进行比较</p>
</li>
<li><p>数值类型对应的包装类以及 BigInteger、BigDecimal：按照它们对应的数值大小进行比较</p>
</li>
<li><p>Boolean：true 对应的包装类实例大于 false 对应的包装类实例</p>
</li>
<li><p>Date、Time 等：后面的日期时间比前面的日期时间大</p>
</li>
<li><p>定制排序<br>场景：</p>
</li>
</ul>
<ol>
<li>当元素的类型没有实现 java.lang.Comparable 接口而又不方便修改代码（例如：一些第三方的类，你只有.class 文件，没有源文件）</li>
<li>如果一个类，实现了 Comparable 接口，也指定了两个对象的比较大小的规则，但是此时此刻我不想按照它预定义的方法比较大小，但是我又不能随意修改，因为会影响其他地方的使用，怎么办？</li>
</ol>
<p>涉及到java.util.Comparator</p>
<ul>
<li>重写 compare(Object o1,Object o2)方法，比较 o1 和 o2 的大小：如果方法返回正整数，则表示 o1 大于 o2；如果返回 0，表示相等；返回负整数，表示 o1 小于 o2。  </li>
<li>可以将 Comparator 传递给 sort 方法（如 Collections.sort 或 Arrays.sort），从而允许在排序顺序上实现精确控制。</li>
</ul>
<h3 id="其它API"><a href="#其它API" class="headerlink" title="其它API"></a>其它API</h3><h4 id="java-lang-System-类"><a href="#java-lang-System-类" class="headerlink" title="java.lang.System 类"></a>java.lang.System 类</h4><ul>
<li><p>System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于<code>java.lang包</code>。</p>
</li>
<li><p>由于该类的构造器是private的，所以无法创建该类的对象。其内部的成员变量和成员方法都是<code>static的</code>，所以也可以很方便的进行调用。</p>
</li>
<li><p>成员变量   Scanner scan &#x3D; new Scanner(System.in);</p>
<ul>
<li>System类内部包含<code>in</code>、<code>out</code>和<code>err</code>三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。</li>
</ul>
</li>
<li><p>成员方法</p>
<ul>
<li><p><code>native long currentTimeMillis()</code>：<br>该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。</p>
</li>
<li><p><code>void exit(int status)</code>：<br>该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。</p>
</li>
<li><p><code>void gc()</code>：<br>该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。</p>
</li>
<li><p><code>String getProperty(String key)</code>：<br>该方法的作用是获得系统中属性名为key的属性对应的值。</p>
</li>
</ul>
</li>
</ul>
<h4 id="java-lang-Runtime类"><a href="#java-lang-Runtime类" class="headerlink" title="java.lang.Runtime类"></a>java.lang.Runtime类</h4><p>每个 Java 应用程序都有一个 <code>Runtime</code> 类实例，使应用程序能够与其运行的环境相连接。</p>
<p><code>public static Runtime getRuntime()</code>： 返回与当前 Java 应用程序相关的运行时对象。应用程序不能创建自己的 Runtime 类实例。</p>
<p><code>public long totalMemory()</code>：返回 Java 虚拟机中初始化时的内存总量。此方法返回的值可能随时间的推移而变化，这取决于主机环境。默认为物理电脑内存的1&#x2F;64。</p>
<p><code>public long maxMemory()</code>：返回 Java 虚拟机中最大程度能使用的内存总量。默认为物理电脑内存的1&#x2F;4。</p>
<p><code>public long freeMemory()</code>：回 Java 虚拟机中的空闲内存量。调用 gc 方法可能导致 freeMemory 返回值的增加。</p>
<h4 id="和数学相关的类"><a href="#和数学相关的类" class="headerlink" title="和数学相关的类"></a>和数学相关的类</h4><ol>
<li><code>java.lang.Math</code> 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具类，其所有方法均为静态方法，并且不会创建对象，调用起来非常简单。</li>
</ol>
<ul>
<li><code>public static double abs(double a) </code> ：返回 double 值的绝对值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> Math.abs(-<span class="number">5</span>); <span class="comment">//d1的值为5</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> Math.abs(<span class="number">5</span>); <span class="comment">//d2的值为5</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>public static double ceil(double a)</code> ：返回大于等于参数的最小的整数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> Math.ceil(<span class="number">3.3</span>); <span class="comment">//d1的值为 4.0</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> Math.ceil(-<span class="number">3.3</span>); <span class="comment">//d2的值为 -3.0</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d3</span> <span class="operator">=</span> Math.ceil(<span class="number">5.1</span>); <span class="comment">//d3的值为 6.0</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>public static double floor(double a) </code> ：返回小于等于参数最大的整数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> Math.floor(<span class="number">3.3</span>); <span class="comment">//d1的值为3.0</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> Math.floor(-<span class="number">3.3</span>); <span class="comment">//d2的值为-4.0</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d3</span> <span class="operator">=</span> Math.floor(<span class="number">5.1</span>); <span class="comment">//d3的值为 5.0</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>public static long round(double a)</code> ：返回最接近参数的 long。(相当于四舍五入方法)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">d1</span> <span class="operator">=</span> Math.round(<span class="number">5.5</span>); <span class="comment">//d1的值为6</span></span><br><span class="line"><span class="type">long</span> <span class="variable">d2</span> <span class="operator">=</span> Math.round(<span class="number">5.4</span>); <span class="comment">//d2的值为5</span></span><br><span class="line"><span class="type">long</span> <span class="variable">d3</span> <span class="operator">=</span> Math.round(-<span class="number">3.3</span>); <span class="comment">//d3的值为-3</span></span><br><span class="line"><span class="type">long</span> <span class="variable">d4</span> <span class="operator">=</span> Math.round(-<span class="number">3.8</span>); <span class="comment">//d4的值为-4</span></span><br></pre></td></tr></table></figure>

<ul>
<li>public static double pow(double a,double b)：返回a的b幂次方法</li>
<li>public static double sqrt(double a)：返回a的平方根</li>
<li><code>public static double random()</code>：返回[0,1)的随机值</li>
<li>public static final double PI：返回圆周率</li>
<li>public static double max(double x, double y)：返回x,y中的最大值</li>
<li>public static double min(double x, double y)：返回x,y中的最小值</li>
<li>其它：acos,asin,atan,cos,sin,tan 三角函数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> Math.pow(<span class="number">2</span>,<span class="number">31</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">sqrt</span> <span class="operator">=</span> Math.sqrt(<span class="number">256</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">rand</span> <span class="operator">=</span> Math.random();</span><br><span class="line"><span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> Math.PI;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>java.math包<br>BigInteger</li>
</ol>
<ul>
<li><p>Integer类作为int的包装类，能存储的最大整型值为2^31-1，Long类也是有限的，最大为2^63-1。如果要表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力，更不用说进行运算了。</p>
</li>
<li><p>java.math包的BigInteger可以表示<code>不可变的任意精度的整数</code>。BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。 </p>
</li>
<li><p>构造器</p>
<ul>
<li>BigInteger(String val)：根据字符串构建BigInteger对象</li>
</ul>
</li>
<li><p>方法</p>
<ul>
<li>public BigInteger <code>abs</code>()：返回此 BigInteger 的绝对值的 BigInteger。</li>
<li>BigInteger <code>add</code>(BigInteger val) ：返回其值为 (this + val) 的 BigInteger</li>
<li>BigInteger <code>subtract</code>(BigInteger val) ：返回其值为 (this - val) 的 BigInteger</li>
<li>BigInteger <code>multiply</code>(BigInteger val) ：返回其值为 (this * val) 的 BigInteger</li>
<li>BigInteger <code>divide</code>(BigInteger val) ：返回其值为 (this &#x2F; val) 的 BigInteger。整数相除只保留整数部分。</li>
<li>BigInteger <code>remainder</code>(BigInteger val) ：返回其值为 (this % val) 的 BigInteger。</li>
<li>BigInteger[] <code>divideAndRemainder</code>(BigInteger val)：返回包含 (this &#x2F; val) 后跟 (this % val) 的两个 BigInteger 的数组。</li>
<li>BigInteger <code>pow</code>(int exponent) ：返回其值为 (this^exponent) 的 BigInteger。</li>
</ul>
</li>
</ul>
<p>BigDecimal  </p>
<ul>
<li><p>一般的Float类和Double类可以用来做科学计算或工程计算，但在<strong>商业计算中，要求数字精度比较高，故用到java.math.BigDecimal类。</strong></p>
</li>
<li><p>BigDecimal类支持不可变的、任意精度的有符号十进制定点数。</p>
</li>
<li><p>构造器</p>
<ul>
<li>public BigDecimal(double val)</li>
<li>public BigDecimal(String val) –&gt; 推荐</li>
</ul>
</li>
<li><p>常用方法</p>
<ul>
<li>public BigDecimal <code>add</code>(BigDecimal augend)</li>
<li>public BigDecimal <code>subtract</code>(BigDecimal subtrahend)</li>
<li>public BigDecimal <code>multiply</code>(BigDecimal multiplicand)</li>
<li>public BigDecimal <code>divide</code>(BigDecimal divisor, int scale, int roundingMode)：divisor是除数，scale指明保留几位小数，roundingMode指明舍入模式（ROUND_UP :向上加1、ROUND_DOWN :直接舍去、ROUND_HALF_UP:四舍五入）</li>
</ul>
</li>
</ul>
<ol start="3">
<li>java.util.Random<br>用于产生随机数</li>
</ol>
<ul>
<li><p><code>boolean nextBoolean()</code>:返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的 boolean 值。 </p>
</li>
<li><p><code>void nextBytes(byte[] bytes)</code>:生成随机字节并将其置于用户提供的 byte 数组中。 </p>
</li>
<li><p><code>double nextDouble()</code>:返回下一个伪随机数，它是取自此随机数生成器序列的、在 0.0 和 1.0 之间均匀分布的 double 值。 </p>
</li>
<li><p><code>float nextFloat()</code>:返回下一个伪随机数，它是取自此随机数生成器序列的、在 0.0 和 1.0 之间均匀分布的 float 值。 </p>
</li>
<li><p><code>double nextGaussian()</code>:返回下一个伪随机数，它是取自此随机数生成器序列的、呈高斯（“正态”）分布的 double 值，其平均值是 0.0，标准差是 1.0。 </p>
</li>
<li><p><code>int nextInt()</code>:返回下一个伪随机数，它是此随机数生成器的序列中均匀分布的 int 值。 </p>
</li>
<li><p><code>int nextInt(int n)</code>:返回一个伪随机数，它是取自此随机数生成器序列的、在 0（包括）和指定值（不包括）之间均匀分布的 int 值。 </p>
</li>
<li><p><code>long nextLong()</code>:返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的 long 值。</p>
</li>
</ul>
<h2 id="企业真题（十一）"><a href="#企业真题（十一）" class="headerlink" title="企业真题（十一）"></a>企业真题（十一）</h2><h3 id="2-1-String"><a href="#2-1-String" class="headerlink" title="2.1 String"></a>2.1 String</h3><h4 id="1-以下两种方式创建的String对象有什么不同？（-团）"><a href="#1-以下两种方式创建的String对象有什么不同？（-团）" class="headerlink" title="1. 以下两种方式创建的String对象有什么不同？（*团）"></a>1. 以下两种方式创建的String对象有什么不同？（*团）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>略</p>
<h4 id="2-String-s-x3D-new-String-“xyz”-创建了几个String-Object-（新-陆）"><a href="#2-String-s-x3D-new-String-“xyz”-创建了几个String-Object-（新-陆）" class="headerlink" title="2. String s &#x3D; new String(“xyz”);创建了几个String Object? （新*陆）"></a>2. String s &#x3D; new String(“xyz”);创建了几个String Object? （新*陆）</h4><p>两个</p>
<h4 id="3-String-a-x3D-”abc”-String-b-x3D-”a”-”bc”-问a-x3D-x3D-b-（网-邮箱）"><a href="#3-String-a-x3D-”abc”-String-b-x3D-”a”-”bc”-问a-x3D-x3D-b-（网-邮箱）" class="headerlink" title="3. String a&#x3D;”abc” String b&#x3D;”a”+”bc” 问a&#x3D;&#x3D;b?（网*邮箱）"></a>3. String a&#x3D;”abc” String b&#x3D;”a”+”bc” 问a&#x3D;&#x3D;b?（网*邮箱）</h4><p>是！</p>
<h4 id="4-String-中-“-”-怎样实现-（阿-）"><a href="#4-String-中-“-”-怎样实现-（阿-）" class="headerlink" title="4. String 中 “+” 怎样实现?（阿*）"></a>4. String 中 “+” 怎样实现?（阿*）</h4><p>常量 + 常量 ：略</p>
<p>变量 + 常量 、变量+变量：创建一个StringBuilder的实例，通过append()添加字符串，最后调用toString()返回一个字符串。（toString()内部new 一个String的实例）</p>
<h4 id="5-Java中String是不是final的？（凡-科技）"><a href="#5-Java中String是不是final的？（凡-科技）" class="headerlink" title="5. Java中String是不是final的？（凡*科技）"></a>5. Java中String是不是final的？（凡*科技）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; String被哪些类继承？（网*邮箱）</span><br><span class="line">&gt; 是否可以继承String类?（湖南*利软件）</span><br><span class="line">&gt; String 是否可以继承?（阿*）</span><br></pre></td></tr></table></figure>

<p>是</p>
<h4 id="6-String为啥不可变，在内存中的具体形态？（阿-）"><a href="#6-String为啥不可变，在内存中的具体形态？（阿-）" class="headerlink" title="6. String为啥不可变，在内存中的具体形态？（阿*）"></a>6. String为啥不可变，在内存中的具体形态？（阿*）</h4><p>规定不可变。</p>
<p>String：提供字符串常量池。</p>
<h4 id="7-String-可以在-switch中使用吗-上海-睿"><a href="#7-String-可以在-switch中使用吗-上海-睿" class="headerlink" title="7. String 可以在 switch中使用吗?(上海*睿)"></a>7. String 可以在 switch中使用吗?(上海*睿)</h4><p>可以。从jdk7开始可以使用</p>
<h4 id="8-String中有哪些方法-列举几个（闪-购）"><a href="#8-String中有哪些方法-列举几个（闪-购）" class="headerlink" title="8. String中有哪些方法?列举几个（闪*购）"></a>8. String中有哪些方法?列举几个（闪*购）</h4><p>。。。</p>
<h4 id="9-subString-到底做了什么-银-数据"><a href="#9-subString-到底做了什么-银-数据" class="headerlink" title="9. subString()到底做了什么?(银*数据)"></a>9. subString()到底做了什么?(银*数据)</h4><p>String str &#x3D; “hello”;</p>
<p>String subStr &#x3D; str.subString(1,3);  &#x2F;&#x2F;底层是new的方式返回一个subStr，实体内容是”el”</p>
<h3 id="2-2-String、StringBuffer、StringBuilder"><a href="#2-2-String、StringBuffer、StringBuilder" class="headerlink" title="2.2 String、StringBuffer、StringBuilder"></a>2.2 String、StringBuffer、StringBuilder</h3><h4 id="1-Java中操作字符串有哪些类？他们之间有什么区别。（南-电网）"><a href="#1-Java中操作字符串有哪些类？他们之间有什么区别。（南-电网）" class="headerlink" title="1. Java中操作字符串有哪些类？他们之间有什么区别。（南*电网）"></a>1. Java中操作字符串有哪些类？他们之间有什么区别。（南*电网）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; String 和 StringBuffer区别？(亿*国际、天*隆、*团)</span><br><span class="line">&gt; StringBuilder和StrignBuffer的区别？（平*金服）</span><br><span class="line">&gt; StringBuilder和StringBuffer的区别以及实现？（*为）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; String:不可变的字符序列;底层使用char[] （jdk8及之前），底层使用byte[] （jdk9及之后）</span><br><span class="line">&gt; StringBuffer:可变的字符序列;JDK1.0声明，线程安全的，效率低;底层使用char[] （jdk8及之前），底层使用byte[] （jdk9及之后）</span><br><span class="line">&gt; StringBuilder:可变的字符序列;JDK5.0声明，线程不安全的,效率高;底层使用char[] （jdk8及之前），底层使用byte[] （jdk9及之后）</span><br></pre></td></tr></table></figure>

<h4 id="2-String的线程安全问题（闪-购）"><a href="#2-String的线程安全问题（闪-购）" class="headerlink" title="2. String的线程安全问题（闪*购）"></a>2. String的线程安全问题（闪*购）</h4><p>线程不安全的</p>
<h4 id="3-StringBuilder和StringBuffer的线程安全问题（润-软件）"><a href="#3-StringBuilder和StringBuffer的线程安全问题（润-软件）" class="headerlink" title="3. StringBuilder和StringBuffer的线程安全问题（润*软件）"></a>3. StringBuilder和StringBuffer的线程安全问题（润*软件）</h4><p>略</p>
<h3 id="2-3-Comparator与Comparable"><a href="#2-3-Comparator与Comparable" class="headerlink" title="2.3 Comparator与Comparable"></a>2.3 Comparator与Comparable</h3><h4 id="1-简单说说-Comparable-和-Comparator-的区别和场景？（软-力）"><a href="#1-简单说说-Comparable-和-Comparator-的区别和场景？（软-力）" class="headerlink" title="1. 简单说说 Comparable 和 Comparator 的区别和场景？（软**力）"></a>1. 简单说说 Comparable 和 Comparator 的区别和场景？（软**力）</h4><p>略</p>
<h4 id="2-Comparable-接口和-Comparator-接口实现比较（阿-）"><a href="#2-Comparable-接口和-Comparator-接口实现比较（阿-）" class="headerlink" title="2. Comparable 接口和 Comparator 接口实现比较（阿*）"></a>2. Comparable 接口和 Comparator 接口实现比较（阿*）</h4><p>略</p>
<h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><h3 id="数组存储数据方面的特点和弊端"><a href="#数组存储数据方面的特点和弊端" class="headerlink" title="数组存储数据方面的特点和弊端"></a>数组存储数据方面的特点和弊端</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">数组存储多个数据方面的特点：</span><br><span class="line">&gt; 数组一旦初始化，其长度就是确定的。</span><br><span class="line">&gt; 数组中的多个元素是依次紧密排列的，有序的，可重复的</span><br><span class="line">&gt; (优点) 数组一旦初始化完成，其元素的类型就是确定的。不是此类型的元素，就不能添加到此数组中。</span><br><span class="line">   int[] arr = new int[10];</span><br><span class="line">   arr[0] = 1;</span><br><span class="line">   arr[1] = &quot;AA&quot;;//编译报错</span><br><span class="line"></span><br><span class="line">   Object[] arr1 = new Object[10];</span><br><span class="line">   arr1[0] = new String();</span><br><span class="line">   arr1[1] = new Date();</span><br><span class="line">&gt; (优点)元素的类型既可以是基本数据类型，也可以是引用数据类型。</span><br><span class="line"></span><br><span class="line">数组存储多个数据方面的弊端：</span><br><span class="line">&gt; 数组一旦初始化，其长度就不可变了。</span><br><span class="line">&gt; 数组中存储数据特点的单一性。对于无序的、不可重复的场景的多个数据就无能为力了。</span><br><span class="line">&gt; 数组中可用的方法、属性都极少。具体的需求，都需要自己来组织相关的代码逻辑。</span><br><span class="line">&gt; 针对于数组中元素的删除、插入操作，性能较差。</span><br></pre></td></tr></table></figure>

<h3 id="Java集合框架体系（java-util包下）"><a href="#Java集合框架体系（java-util包下）" class="headerlink" title="Java集合框架体系（java.util包下）"></a>Java集合框架体系（java.util包下）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java.util.Collection:存储一个一个的数据</span><br><span class="line">    |-----子接口：List:存储有序的、可重复的数据 (&quot;动态&quot;数组)</span><br><span class="line">           |---- ArrayList(主要实现类)、LinkedList、Vector</span><br><span class="line"></span><br><span class="line">    |-----子接口：Set:存储无序的、不可重复的数据(高中学习的集合)</span><br><span class="line">           |---- HashSet(主要实现类)、LinkedHashSet、TreeSet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">java.util.Map:存储一对一对的数据(key-value键值对，(x1,y1)、(x2,y2) --&gt; y=f(x),类似于高中的函数)</span><br><span class="line">    |---- HashMap(主要实现类)、LinkedHashMap、TreeMap、Hashtable、Properties</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">学习的程度把握：</span><br><span class="line">层次1：针对于具体特点的多个数据，知道选择相应的适合的接口的主要实现类，会实例化，会调用常用的方法。</span><br><span class="line">层次2：区分接口中不同的实现类的区别。</span><br><span class="line">*****************</span><br><span class="line">层次3：① 针对于常用的实现类，需要熟悉底层的源码 ② 熟悉常见的数据结构 （第14章讲）</span><br></pre></td></tr></table></figure>

<h3 id="Collection的常用方法"><a href="#Collection的常用方法" class="headerlink" title="Collection的常用方法"></a>Collection的常用方法</h3><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">add(Object obj)</span><br><span class="line">addAll(Collection coll)</span><br><span class="line">clear()</span><br><span class="line">isEmpty()</span><br><span class="line">size()</span><br><span class="line">contains(Object obj)</span><br><span class="line">containsAll(Collection coll)</span><br><span class="line">retainAll(Collection coll)</span><br><span class="line">remove(Object obj)</span><br><span class="line">removeAll(Collection coll)</span><br><span class="line">hashCode()</span><br><span class="line">equals()</span><br><span class="line">toArray()</span><br><span class="line">**************</span><br><span class="line">iterator() ---&gt; 引出了迭代器接口</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">向Collection中添加元素的要求：</span><br><span class="line">&gt; 要求元素所属的类一定要重写equals()!</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">集合与数组的相互转换：</span><br><span class="line">集合 ---&gt; 数组：toArray()</span><br><span class="line">数组 ---&gt; 集合：调用Arrays的静态方法asList(Object ... objs)，返回一个List</span><br></pre></td></tr></table></figure>

<h4 id="迭代器接口"><a href="#迭代器接口" class="headerlink" title="迭代器接口"></a>迭代器接口</h4><ul>
<li>设计模式的一种</li>
<li>迭代器不负责数据的存储；负责对集合类的遍历</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 如何获取迭代器(Iterator)对象？</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 如何实现遍历(代码实现)</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next()); <span class="comment">//next():①指针下移 ② 将下移以后集合位置上的元素返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>增强for循环(foreach循环)的使用（jdk5.0新特性）  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(要遍历的集合或数组元素的类型 临时变量 : 要遍历的集合或数组变量)&#123;</span><br><span class="line">    操作临时变量的输出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>针对于集合来讲，增强for循环的底层仍然使用的是迭代器。<br>增强for循环的执行过程中，是将集合或数组中的元素依次赋值给临时变量，注意，循环体中对临时变量的修改，可能不会导致原有集合或数组中元素的修改。</p>
</blockquote>
</li>
</ul>
<h3 id="Collection的子接口：List"><a href="#Collection的子接口：List" class="headerlink" title="Collection的子接口：List"></a>Collection的子接口：List</h3><p>List接口中存储数据的特点：用于存储有序的、可以重复的数据。—&gt; 使用List替代数组，”动态”数组</p>
<ul>
<li>常用方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">小结：</span><br><span class="line">    增</span><br><span class="line">        add(Object obj)</span><br><span class="line">        addAll(Collection coll)</span><br><span class="line">    删</span><br><span class="line">        remove(Object obj)</span><br><span class="line">        remove(<span class="type">int</span> index)</span><br><span class="line">    改</span><br><span class="line">        set(<span class="type">int</span> index, Object ele)</span><br><span class="line">    查</span><br><span class="line">        get(<span class="type">int</span> index)</span><br><span class="line">    插</span><br><span class="line">        add(<span class="type">int</span> index, Object ele)</span><br><span class="line">        addAll(<span class="type">int</span> index, Collection eles)</span><br><span class="line">    长度</span><br><span class="line">        size()</span><br><span class="line">    遍历</span><br><span class="line">        iterator() ：使用迭代器进行遍历</span><br><span class="line">        增强<span class="keyword">for</span>循环</span><br><span class="line">        一般的<span class="keyword">for</span>循环</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List及其实现类特点</span><br><span class="line">java.util.Collection:存储一个一个的数据</span><br><span class="line">    |-----子接口：List:存储有序的、可重复的数据 (&quot;动态&quot;数组)</span><br><span class="line">           |---- ArrayList:List的主要实现类；线程不安全的、效率高；底层使用Object[]数组存储</span><br><span class="line">                           在添加数据、查找数据时，效率较高；在插入、删除数据时，效率较低</span><br><span class="line">           |---- LinkedList:底层使用双向链表的方式进行存储；在对集合中的数据进行频繁的删除、插入操作时，建议							使用此类在插入、删除数据时，效率较高；在添加数据、查找数据时，效率较低；</span><br><span class="line">           |---- Vector:List的古老实现类；线程安全的、效率低；底层使用Object[]数组存储</span><br><span class="line"></span><br><span class="line">[面试题] ArrayList、Vector的区别？  ArrayList、LinkedList的区别？</span><br></pre></td></tr></table></figure>



<h3 id="Collection的子接口：Set"><a href="#Collection的子接口：Set" class="headerlink" title="Collection的子接口：Set"></a>Collection的子接口：Set</h3><ul>
<li>Set中的常用的方法都是Collection中声明的方法，没有新增的方法</li>
<li>常见的实现类的对比</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.util.Collection:存储一个一个的数据</span><br><span class="line">    |-----子接口：Set:存储无序的、不可重复的数据(高中学习的集合)</span><br><span class="line">           |---- HashSet：主要实现类；底层使用的是HashMap，即使用数组+单向链表+红黑树结构进行存储。（jdk8中）</span><br><span class="line">                |---- LinkedHashSet：是HashSet的子类；在现有的数组+单向链表+红黑树结构的基础上，又添加了</span><br><span class="line">                                     一组双向链表，用于记录添加元素的先后顺序。即：我们可以按照添加元素的顺序实现遍历。便于频繁的查询操作。</span><br><span class="line">           |---- TreeSet：底层使用红黑树存储。可以按照添加的元素的指定的属性的大小顺序进行遍历。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>开发中的使用频率及场景：  </p>
<blockquote>
<p>较List、Map来说，Set使用的频率比较少。<br>用来过滤重复数据</p>
</blockquote>
</li>
<li><p>难点： Set中无序性、不可重复性的理解（以HashSet及其子类为例说明）</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;无序性： != 随机性。</span><br><span class="line">         添加元素的顺序和遍历元素的顺序不一致,是不是就是无序性呢？ No!</span><br><span class="line">         到底什么是无序性？与添加的元素的位置有关，不像ArrayList一样是依次紧密排列的。</span><br><span class="line">         这里是根据添加的元素的哈希值，计算的其在数组中的存储位置。此位置不是依次排列的，表现为无序性。</span><br><span class="line"></span><br><span class="line">&gt;不可重复性：添加到Set中的元素是不能相同的。</span><br><span class="line">          比较的标准，需要判断hashCode()得到的哈希值以及equals()得到的boolean型的结果。</span><br><span class="line">          哈希值相同且equals()返回true，则认为元素是相同的。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">添加到HashSet/LinkedHashSet中元素的要求:</span><br><span class="line">&gt;要求元素所在的类要重写两个方法：equals() 和 hashCode()。</span><br><span class="line">&gt;同时，要求equals() 和 hashCode()要保持一致性！我们只需要在IDEA中自动生成两个方法的重写即可，即能保证两个方法的一致性。</span><br></pre></td></tr></table></figure>

<ul>
<li>TreeSet的使用  <ol>
<li>底层的数据结构：红黑树  </li>
<li>添加数据后的特点：可以按照添加的元素的指定的属性的大小顺序进行遍历。  </li>
<li>向TreeSet中添加的元素的要求：<blockquote>
<p>要求添加到TreeSet中的元素必须是同一个类型的对象，否则会ClassCastException.<br>添加的元素需要考虑排序：① 自然排序 ② 定制排序  </p>
</blockquote>
</li>
<li>判断数据是否相同的标准  <blockquote>
<p>不再是考虑hashCode()和equals()方法了，也就意味着添加到TreeSet中的元素所在的类不需要重写hashCode()和equals()方法了<br>比较元素大小的或比较元素是否相等的标准就是考虑自然排序或定制排序中，compareTo()或compare()的返回值。如果compareTo()或compare()的返回值为0，则认为两个对象是相等的。由于TreeSet中不能存放相同的元素，则后一个相等的元素就不能添加到TreeSet中。</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><ul>
<li>常用的方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">增：</span><br><span class="line">    put(Object key,Object value)</span><br><span class="line">    putAll(Map m)</span><br><span class="line">删：</span><br><span class="line">    Object remove(Object key)</span><br><span class="line">改：</span><br><span class="line">    put(Object key,Object value)</span><br><span class="line">    putAll(Map m)</span><br><span class="line">查：</span><br><span class="line">    Object get(Object key)</span><br><span class="line">长度：</span><br><span class="line">    size()</span><br><span class="line">遍历：</span><br><span class="line">   遍历key集：Set keySet()</span><br><span class="line">   遍历value集：Collection values()</span><br><span class="line">   遍历entry集：Set entrySet()</span><br></pre></td></tr></table></figure>

<ul>
<li>常用的实现类</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java.util.Map:存储一对一对的数据(key-value键值对，(x1,y1)、(x2,y2) --&gt; y=f(x),类似于高中的函数)</span><br><span class="line">    |---- HashMap:主要实现类;线程不安全的，效率高;可以添加null的key和value值;底层使用数组+单向链表+红黑树结构存储（jdk8）</span><br><span class="line">        |---- LinkedHashMap:是HashMap的子类；在HashMap使用的数据结构的基础上，增加了一对双向链表，用于记录添加的元素的先后顺序，进而我们在遍历元素时，就可以按照添加的顺序显示。开发中，对于频繁的遍历操作，建议使用此类。</span><br><span class="line">    |---- TreeMap:底层使用红黑树存储;可以按照添加的key-value中的key元素的指定的属性的大小顺序进行遍历。需要考虑使用①自然排序 ②定制排序。</span><br><span class="line">    |---- Hashtable:古老实现类;线程安全的，效率低;不可以添加null的key或value值;底层使用数组+单向链表结构存储（jdk8）</span><br><span class="line">        |---- Properties:其key和value都是String类型。常用来处理属性文件。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[面试题] 区别HashMap和Hashtable、区别HashMap和LinkedHashMap、HashMap的底层实现（① new HashMap() ② put(key,value)）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HashMap中元素的特点:</span><br><span class="line">&gt; HashMap中的所有的key彼此之间是不可重复的、无序的。所有的key就构成一个Set集合。---&gt;key所在的类要重写hashCode()和equals()</span><br><span class="line">&gt; HashMap中的所有的value彼此之间是可重复的、无序的。所有的value就构成一个Collection集合。---&gt;value所在的类要重写equals()</span><br><span class="line">&gt; HashMap中的一个key-value,就构成了一个entry。</span><br><span class="line">&gt; HashMap中的所有的entry彼此之间是不可重复的、无序的。所有的entry就构成了一个Set集合。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>（了解）TreeMap的使用  </p>
<blockquote>
<p>底层使用红黑树存储;<br>可以按照添加的key-value中的key元素的指定的属性的大小顺序进行遍历。<br>需要考虑使用①自然排序 ②定制排序。<br>要求:向TreeMap中添加的key必须是同一个类型的对象。</p>
</blockquote>
</li>
<li><p>（重要）Properties的使用<br>Properties:是Hashtable的子类，其key和value都是String类型的，常用来处理属性文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123; <span class="comment">//注意：因为设计到流的操作，为了确保流能关闭，建议使用try-catch-finally</span></span><br><span class="line">        <span class="comment">//方式1：数据和代码耦合度高；如果修改的话，需要重写的编译代码、打包发布，繁琐</span></span><br><span class="line">        <span class="comment">//数据</span></span><br><span class="line"><span class="comment">//        String name = &quot;Tom&quot;;</span></span><br><span class="line"><span class="comment">//        String password = &quot;abc123&quot;;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//代码：用于操作name,password</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式2：将数据封装到具体的配置文件中，在程序中读取配置文件中的信息。实现了</span></span><br><span class="line">        <span class="comment">//数据和代码的解耦；由于我们没有修改代码，就省去了重新编译和打包的过程。</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;info.properties&quot;</span>); <span class="comment">//注意，要提前创建好</span></span><br><span class="line"><span class="comment">//        System.out.println(file.getAbsolutePath());</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        pros.load(fis); <span class="comment">//加载流中的文件中的数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(name + <span class="string">&quot;:&quot;</span> + pwd);</span><br><span class="line"></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Collections工具类的使用"><a href="#Collections工具类的使用" class="headerlink" title="Collections工具类的使用"></a>Collections工具类的使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">区分Collection 和 Collections</span><br><span class="line">Collection：集合框架中的用于存储一个一个元素的接口，又分为List和Set等子接口。</span><br><span class="line">Collections：用于操作集合框架的一个工具类。此时的集合框架包括：Set、List、Map</span><br></pre></td></tr></table></figure>

<ul>
<li>Collections中的常用方法  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">排序操作：</span><br><span class="line">- reverse(List)：反转 List 中元素的顺序</span><br><span class="line">- shuffle(List)：对 List 集合元素进行随机排序</span><br><span class="line">- sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序</span><br><span class="line">- sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</span><br><span class="line">- swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</span><br><span class="line"></span><br><span class="line">查找</span><br><span class="line">- Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素</span><br><span class="line">- Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素</span><br><span class="line">- Object min(Collection)：根据元素的自然顺序，返回给定集合中的最小元素</span><br><span class="line">- Object min(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最小元素</span><br><span class="line">- int binarySearch(List list,T key)在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象，而且必须是可比较大小的，即支持自然排序的。而且集合也事先必须是有序的，否则结果不确定。</span><br><span class="line">- int binarySearch(List list,T key,Comparator c)在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象，而且集合也事先必须是按照c比较器规则进行排序过的，否则结果不确定。</span><br><span class="line">- int frequency(Collection c，Object o)：返回指定集合中指定元素的出现次数</span><br><span class="line"></span><br><span class="line">复制、替换</span><br><span class="line">- void copy(List dest,List src)：将src中的内容复制到dest中</span><br><span class="line">- boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值</span><br><span class="line">- 提供了多个unmodifiableXxx()方法，该方法返回指定 Xxx的不可修改的视图。</span><br><span class="line"></span><br><span class="line">添加</span><br><span class="line">- boolean addAll(Collection  c,T... elements)将所有指定元素添加到指定 collection 中。</span><br><span class="line"></span><br><span class="line">同步</span><br><span class="line">- Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="企业真题（十二）"><a href="#企业真题（十二）" class="headerlink" title="企业真题（十二）"></a>企业真题（十二）</h2><h3 id="2-1-集合概述"><a href="#2-1-集合概述" class="headerlink" title="2.1 集合概述"></a>2.1 集合概述</h3><h4 id="1-List，Set，Map是否继承自collection接口？（北京中-译咨询、思-贸易）"><a href="#1-List，Set，Map是否继承自collection接口？（北京中-译咨询、思-贸易）" class="headerlink" title="1. List，Set，Map是否继承自collection接口？（北京中*译咨询、思*贸易）"></a>1. List，Set，Map是否继承自collection接口？（北京中*译咨询、思*贸易）</h4><p>Map不是。</p>
<h4 id="2-说说List-Set-Map三者的区别-民-银行"><a href="#2-说说List-Set-Map三者的区别-民-银行" class="headerlink" title="2. 说说List,Set,Map三者的区别(民*银行)"></a>2. 说说List,Set,Map三者的区别(民*银行)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; Map与Set、List的区别（纬*）</span><br></pre></td></tr></table></figure>

<p>略</p>
<h4 id="3-写出list、map、set接口的实现类，并说出其特点（华-为）"><a href="#3-写出list、map、set接口的实现类，并说出其特点（华-为）" class="headerlink" title="3. 写出list、map、set接口的实现类，并说出其特点（华**为）"></a>3. 写出list、map、set接口的实现类，并说出其特点（华**为）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; 集合有哪些， 各自有哪些特点， 各自的API有哪些？（湖**利软件）</span><br><span class="line">&gt; List Map Set三个接口在存储元素时个有什么特点（*软）</span><br></pre></td></tr></table></figure>

<p>略</p>
<h4 id="4-常见集合类的区别和适用场景（饿-）"><a href="#4-常见集合类的区别和适用场景（饿-）" class="headerlink" title="4. 常见集合类的区别和适用场景（饿**）"></a>4. 常见集合类的区别和适用场景（饿**）</h4><p>略</p>
<h4 id="5-集合的父类是谁？哪些安全的？（北京中-信）"><a href="#5-集合的父类是谁？哪些安全的？（北京中-信）" class="headerlink" title="5. 集合的父类是谁？哪些安全的？（北京中**信）"></a>5. 集合的父类是谁？哪些安全的？（北京中**信）</h4><p>略。 不安全：ArrayList、HashMap、HashSet ； 安全：Vector、Hashtable</p>
<h4 id="6-集合说一下哪些是线程不安全的（-科软）"><a href="#6-集合说一下哪些是线程不安全的（-科软）" class="headerlink" title="6. 集合说一下哪些是线程不安全的（*科软）"></a>6. 集合说一下哪些是线程不安全的（*科软）</h4><p>略</p>
<h4 id="7-遍历集合的方式有哪些？（恒-电子）"><a href="#7-遍历集合的方式有哪些？（恒-电子）" class="headerlink" title="7. 遍历集合的方式有哪些？（恒*电子）"></a>7. 遍历集合的方式有哪些？（恒*电子）</h4><ul>
<li><p>迭代器Iterator用来遍历Collection，不能用来遍历Map！</p>
</li>
<li><p>增强for</p>
</li>
<li><p>一般的for：可以用来遍历List</p>
</li>
</ul>
<h3 id="2-2-List接口"><a href="#2-2-List接口" class="headerlink" title="2.2 List接口"></a>2.2 List接口</h3><h4 id="1-List下面有哪些实现（软-力）"><a href="#1-List下面有哪些实现（软-力）" class="headerlink" title="1. List下面有哪些实现（软**力）"></a>1. List下面有哪些实现（软**力）</h4><p>略</p>
<h4 id="2-ArrayList与LinkedList区别？-O-O、滴-、汇-天下、拓-软件、博纳-软件、上海-进天下，北京永生-信息、-联、在-途游"><a href="#2-ArrayList与LinkedList区别？-O-O、滴-、汇-天下、拓-软件、博纳-软件、上海-进天下，北京永生-信息、-联、在-途游" class="headerlink" title="2. ArrayList与LinkedList区别？(O**O、滴*、汇*天下、拓*软件、博纳**软件、上海*进天下，北京永生**信息、*联、在*途游)"></a>2. ArrayList与LinkedList区别？(O**O、滴*、汇*天下、拓*软件、博纳**软件、上海*进天下，北京永生**信息、*联、在*途游)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; ArrayList跟LinkedList的区别详细说出？（阿*校招、*东）</span><br></pre></td></tr></table></figure>

<p>略。 补充上第14章中的源码（底层的数据结构）</p>
<h4 id="3-ArrayList与Vector区别呢？为什么要用ArrayList取代Vector呢？-湖-利软件"><a href="#3-ArrayList与Vector区别呢？为什么要用ArrayList取代Vector呢？-湖-利软件" class="headerlink" title="3. ArrayList与Vector区别呢？为什么要用ArrayList取代Vector呢？(湖**利软件)"></a>3. ArrayList与Vector区别呢？为什么要用ArrayList取代Vector呢？(湖**利软件)</h4><p>Vector效率低。</p>
<h4 id="4-Java-util-ArrayList常用的方法有哪些？（华-为）"><a href="#4-Java-util-ArrayList常用的方法有哪些？（华-为）" class="headerlink" title="4. Java.util.ArrayList常用的方法有哪些？（华**为）"></a>4. Java.util.ArrayList常用的方法有哪些？（华**为）</h4><p>略</p>
<h4 id="5-Arraylist-是有序还是无序？为什么？（蜜-信息）"><a href="#5-Arraylist-是有序还是无序？为什么？（蜜-信息）" class="headerlink" title="5. Arraylist 是有序还是无序？为什么？（蜜*信息）"></a>5. Arraylist 是有序还是无序？为什么？（蜜*信息）</h4><p>有序；底层使用数组：Object[]</p>
<h3 id="2-3-Set接口"><a href="#2-3-Set接口" class="headerlink" title="2.3 Set接口"></a>2.3 Set接口</h3><h4 id="1-Set集合有哪些实现类，分别有什么特点？（拓-软件）"><a href="#1-Set集合有哪些实现类，分别有什么特点？（拓-软件）" class="headerlink" title="1. Set集合有哪些实现类，分别有什么特点？（拓*软件）"></a>1. Set集合有哪些实现类，分别有什么特点？（拓*软件）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; Set的实现类有哪些？（博*科技）</span><br></pre></td></tr></table></figure>

<p>略</p>
<h4 id="2-List集合和Set集合的区别？（亚-科技、-海-翼科技，-华电-系统，达-贷）"><a href="#2-List集合和Set集合的区别？（亚-科技、-海-翼科技，-华电-系统，达-贷）" class="headerlink" title="2. List集合和Set集合的区别？（亚*科技、*海*翼科技，*华电*系统，达*贷）"></a>2. List集合和Set集合的区别？（亚*科技、*海*翼科技，*华电*系统，达*贷）</h4><p>略</p>
<h4 id="3-Set里的元素是不能重复的，那么用什么方法来区分重复与否呢-是用-x3D-x3D-还是equals-它们有何区别-（鸿-网络）"><a href="#3-Set里的元素是不能重复的，那么用什么方法来区分重复与否呢-是用-x3D-x3D-还是equals-它们有何区别-（鸿-网络）" class="headerlink" title="3. Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用&#x3D;&#x3D;还是equals()? 它们有何区别?（鸿*网络）"></a>3. Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用&#x3D;&#x3D;还是equals()? 它们有何区别?（鸿*网络）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; 1.HashSet如何检查重复(创*科技)</span><br><span class="line">&gt; 3.Set使用哪个区分不能重复的元素的？（北京创**荣信息）</span><br></pre></td></tr></table></figure>

<p>hashCode()  、 equals()</p>
<h4 id="4-TreeSet两种排序方式在使用的时候怎么起作用？（拓-软件）"><a href="#4-TreeSet两种排序方式在使用的时候怎么起作用？（拓-软件）" class="headerlink" title="4. TreeSet两种排序方式在使用的时候怎么起作用？（拓*软件）"></a>4. TreeSet两种排序方式在使用的时候怎么起作用？（拓*软件）</h4><p>在添加新的元素时，需要调用compareTo() 或 compare()</p>
<h4 id="5-TreeSet的数据结构（-米）"><a href="#5-TreeSet的数据结构（-米）" class="headerlink" title="5. TreeSet的数据结构（*米）"></a>5. TreeSet的数据结构（*米）</h4><p>红黑树</p>
<h3 id="2-4-Map接口"><a href="#2-4-Map接口" class="headerlink" title="2.4 Map接口"></a>2.4 Map接口</h3><h4 id="1-说一下Java的集合Map有哪些Map？（奥-医药）"><a href="#1-说一下Java的集合Map有哪些Map？（奥-医药）" class="headerlink" title="1. 说一下Java的集合Map有哪些Map？（奥*医药）"></a>1. 说一下Java的集合Map有哪些Map？（奥*医药）</h4><p>略</p>
<h4 id="2-final怎么用，修饰Map可以继续添加数据吗？（-深蓝）"><a href="#2-final怎么用，修饰Map可以继续添加数据吗？（-深蓝）" class="headerlink" title="2. final怎么用，修饰Map可以继续添加数据吗？（*深蓝）"></a>2. final怎么用，修饰Map可以继续添加数据吗？（*深蓝）</h4><p>final HashMap map &#x3D; new HashMap();</p>
<p>map.put(“AA”,123);</p>
<p>可以！</p>
<h4 id="3-Set和Map的比较（亚-科技）"><a href="#3-Set和Map的比较（亚-科技）" class="headerlink" title="3. Set和Map的比较（亚*科技）"></a>3. Set和Map的比较（亚*科技）</h4><p>HashSet底层就是HashMap</p>
<p>LinkedHashSet底层就是LinkedHashMap</p>
<p>TreeSet底层就是TreeMap</p>
<h4 id="4-HashMap说一下，线程安全吗？（-米）"><a href="#4-HashMap说一下，线程安全吗？（-米）" class="headerlink" title="4. HashMap说一下，线程安全吗？（*米）"></a>4. HashMap说一下，线程安全吗？（*米）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; HashMap为什么线程不安全？（微*银行）</span><br><span class="line">&gt; HashMap是线程安全的吗？为什么不安全？（*团、*东、顺*）</span><br></pre></td></tr></table></figure>

<p>不安全</p>
<h4 id="5-HashMap和Hashbable的区别？-银-数据、阿-巴芝麻信用、-众银行、爱-信、杭州-智公司"><a href="#5-HashMap和Hashbable的区别？-银-数据、阿-巴芝麻信用、-众银行、爱-信、杭州-智公司" class="headerlink" title="5. HashMap和Hashbable的区别？(银*数据、阿**巴芝麻信用、*众银行、爱*信、杭州*智公司)"></a>5. HashMap和Hashbable的区别？(银*数据、阿**巴芝麻信用、*众银行、爱*信、杭州*智公司)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; HashMap 和 HashTable 有什么区别，以及如何使用，以及他的一些方法？（阿*校招、*东、*度校招、顺*）</span><br></pre></td></tr></table></figure>

<p>略</p>
<h4 id="6-Hashtable是怎么实现的，为什么线程安全？（迪-创新）"><a href="#6-Hashtable是怎么实现的，为什么线程安全？（迪-创新）" class="headerlink" title="6. Hashtable是怎么实现的，为什么线程安全？（迪*创新）"></a>6. Hashtable是怎么实现的，为什么线程安全？（迪*创新）</h4><p>数组+单向链表；底层方法使用synchronized修饰</p>
<h4 id="7-HashMap和LinkedHashMap的区别（北京-晨阳光）"><a href="#7-HashMap和LinkedHashMap的区别（北京-晨阳光）" class="headerlink" title="7. HashMap和LinkedHashMap的区别（北京*晨阳光）"></a>7. HashMap和LinkedHashMap的区别（北京*晨阳光）</h4><p>略。</p>
<h4 id="8-HashMap-和-TreeMap-的区别（-度，太极-、-线途游、阿-校招）"><a href="#8-HashMap-和-TreeMap-的区别（-度，太极-、-线途游、阿-校招）" class="headerlink" title="8. HashMap 和 TreeMap 的区别（*度，太极**、*线途游、阿*校招）"></a>8. HashMap 和 TreeMap 的区别（*度，太极**、*线途游、阿*校招）</h4><p>底层的数据结构截然不同。</p>
<h4 id="9-HashMap里面实际装的是什么？（惠-）"><a href="#9-HashMap里面实际装的是什么？（惠-）" class="headerlink" title="9. HashMap里面实际装的是什么？（惠*）"></a>9. HashMap里面实际装的是什么？（惠*）</h4><p>JDK7：HashMap内部声明了Entry，实现了Map中的Entry接口。（key，value作为Entry的两个属性出现）</p>
<p>JDK8：HashMap内部声明了Node，实现了Map中的Entry接口。（key，value作为Node的两个属性出现）</p>
<h4 id="10-HashMap的key存储在哪里？和value存储在一起吗？那么value存储在哪里？说具体点？（湖-利软件、天-伟业）"><a href="#10-HashMap的key存储在哪里？和value存储在一起吗？那么value存储在哪里？说具体点？（湖-利软件、天-伟业）" class="headerlink" title="10. HashMap的key存储在哪里？和value存储在一起吗？那么value存储在哪里？说具体点？（湖**利软件、天*伟业）"></a>10. HashMap的key存储在哪里？和value存储在一起吗？那么value存储在哪里？说具体点？（湖**利软件、天*伟业）</h4><p>数组+链表+红黑树。 key、value作为Node的属性出现</p>
<h4 id="11-自定义类型可以作为Key么？（阿-）"><a href="#11-自定义类型可以作为Key么？（阿-）" class="headerlink" title="11. 自定义类型可以作为Key么？（阿*）"></a>11. 自定义类型可以作为Key么？（阿*）</h4><p>可以！ 要重写hashCode() 和equals()</p>
<h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><h4 id="1-集合类的工具类是谁？用过工具类哪些方法？（顺-）"><a href="#1-集合类的工具类是谁？用过工具类哪些方法？（顺-）" class="headerlink" title="1. 集合类的工具类是谁？用过工具类哪些方法？（顺*）"></a>1. 集合类的工具类是谁？用过工具类哪些方法？（顺*）</h4><p>Collections。略</p>
<h4 id="2-Collection-和-Collections的区别？（平-金服、-软）"><a href="#2-Collection-和-Collections的区别？（平-金服、-软）" class="headerlink" title="2. Collection 和 Collections的区别？（平*金服、*软）"></a>2. Collection 和 Collections的区别？（平*金服、*软）</h4><p>略</p>
<h4 id="3-ArrayList-如何实现排序（阿-）"><a href="#3-ArrayList-如何实现排序（阿-）" class="headerlink" title="3. ArrayList 如何实现排序（阿*）"></a>3. ArrayList 如何实现排序（阿*）</h4><p>Collections.sort(list) 或 Collections.sort(list,comparator)</p>
<h4 id="4-HashMap是否线程安全，怎样解决HashMap的线程不安全（中-卫星）"><a href="#4-HashMap是否线程安全，怎样解决HashMap的线程不安全（中-卫星）" class="headerlink" title="4. HashMap是否线程安全，怎样解决HashMap的线程不安全（中*卫星）"></a>4. HashMap是否线程安全，怎样解决HashMap的线程不安全（中*卫星）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; 怎么实现HashMap线程安全？（*团、*东、顺*）</span><br></pre></td></tr></table></figure>

<p>略</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="泛型的理解"><a href="#泛型的理解" class="headerlink" title="泛型的理解"></a>泛型的理解</h3><ul>
<li><E> ，泛型参数，使用引用数据类型来赋值。</li>
</ul>
<h3 id="泛型在集合、比较器中的使用（重点）"><a href="#泛型在集合、比较器中的使用（重点）" class="headerlink" title="泛型在集合、比较器中的使用（重点）"></a>泛型在集合、比较器中的使用（重点）</h3><ul>
<li>在集合中使用泛型之前可能存在的问题<br>问题1：类型不安全。因为add()的参数是Object类型，意味着任何类型的对象都可以添加成功<br>问题2：需要使用强转操作，繁琐。还有可能导致ClassCastException异常。</li>
<li>集合：ArrayList、HashMap、Iterator</li>
<li>比较器：Comparable、Comparator</li>
</ul>
<h3 id="自定义泛型类-x2F-泛型接口、泛型方法（熟悉）"><a href="#自定义泛型类-x2F-泛型接口、泛型方法（熟悉）" class="headerlink" title="自定义泛型类&#x2F;泛型接口、泛型方法（熟悉）"></a>自定义泛型类&#x2F;泛型接口、泛型方法（熟悉）</h3><ul>
<li>class Order<T>{ }</li>
<li>public <E> 返回值类型 方法名(形参列表){}</li>
<li>具体的细节，见IDEA中的笔记。</li>
</ul>
<h3 id="泛型在继承上的体现"><a href="#泛型在继承上的体现" class="headerlink" title="泛型在继承上的体现"></a>泛型在继承上的体现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 类SuperA是类A的父类，则G&lt;SuperA&gt; 与 G&lt;A&gt;的关系：G&lt;SuperA&gt; 和 G&lt;A&gt;是并列的两个类，没有任何子父类的关系。</span><br><span class="line"></span><br><span class="line">比如：ArrayList&lt;Object&gt; 、ArrayList&lt;String&gt;没有关系</span><br><span class="line"></span><br><span class="line">2. 类SuperA是类A的父类或接口，SuperA&lt;G&gt; 与 A&lt;G&gt;的关系：SuperA&lt;G&gt; 与A&lt;G&gt; 有继承或实现的关系。</span><br><span class="line">即A&lt;G&gt;的实例可以赋值给SuperA&lt;G&gt;类型的引用（或变量）</span><br><span class="line"></span><br><span class="line">比如：List&lt;String&gt; 与 ArrayList&lt;String&gt;</span><br></pre></td></tr></table></figure>

<h3 id="通配符的使用"><a href="#通配符的使用" class="headerlink" title="通配符的使用"></a>通配符的使用</h3><ul>
<li>? 的使用 （重点）<ul>
<li>以集合为例：可以读取数据、不能写入数据（例外：null）</li>
</ul>
</li>
<li>? extends A<ul>
<li>以集合为例：可以读取数据、不能写入数据（例外：null）</li>
</ul>
</li>
<li>? super A<ul>
<li>以集合为例：可以读取数据、可以写入A类型或A类型子类的数据（例外：null）</li>
</ul>
</li>
</ul>
<h2 id="企业真题（十三）"><a href="#企业真题（十三）" class="headerlink" title="企业真题（十三）"></a>企业真题（十三）</h2><h4 id="1-Java-的泛型是什么？有什么好处和优点？JDK-不同版本的泛型有什么区别？（软-动力）"><a href="#1-Java-的泛型是什么？有什么好处和优点？JDK-不同版本的泛型有什么区别？（软-动力）" class="headerlink" title="1. Java 的泛型是什么？有什么好处和优点？JDK 不同版本的泛型有什么区别？（软*动力）"></a>1. Java 的泛型是什么？有什么好处和优点？JDK 不同版本的泛型有什么区别？（软*动力）</h4><p>泛型，是程序中出现的不确定的类型。</p>
<p>以集合来举例：把一个集合中的内容限制为一个特定的数据类型，这就是generic背后的核心思想。</p>
<p>jdk7.0新特性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">//类型推断</span></span><br></pre></td></tr></table></figure>

<p>后续版本的新特性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Employee&gt; comparator = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;&gt;()&#123;&#125; <span class="comment">//类型推断</span></span><br></pre></td></tr></table></figure>



<h4 id="2-说说你对泛型的了解（-软国际）"><a href="#2-说说你对泛型的了解（-软国际）" class="headerlink" title="2. 说说你对泛型的了解（*软国际）"></a>2. 说说你对泛型的了解（*软国际）</h4><p>略</p>
<h2 id="数据结构与集合源码"><a href="#数据结构与集合源码" class="headerlink" title="数据结构与集合源码"></a>数据结构与集合源码</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li><p>概念：数据结构，就是一种程序设计优化的方法论，研究数据的<code>逻辑结构</code>和<code>物理结构</code>以及它们之间相互关系，并对这种结构定义相应的<code>运算</code>，目的是加快程序的执行速度、减少内存占用的空间。</p>
</li>
<li><p>数据结构的研究对象：</p>
<ul>
<li>① 数据间的逻辑关系（集合关系、一对一、一对多、多对多）</li>
<li>② 数据的存储结构（或物理结构）<ul>
<li>角度一：顺序结构、链式结构、索引结构、哈希结构</li>
<li>角度二：线性表（一维数组、链表、栈、队列）、树（二叉树、B+树）、图（多对多）、哈希表（HashMap、HashSet）</li>
</ul>
</li>
<li>③ 相关运算</li>
</ul>
</li>
</ul>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><ul>
<li><p>逻辑结构：线性结构</p>
</li>
<li><p>物理结构：不要求连续的存储空间</p>
</li>
<li><p>存储特点：链表由一系列结点node（链表中每一个元素称为结点）组成，结点可以在代码执行过程中动态创建。每个结点包括两个部分：一个是存储数据元素的<code>数据域</code>，另一个是存储下一个结点地址的<code>指针域</code>。</p>
</li>
</ul>
<p><img src="/images/image-20220511113744772-1661445988505.png" alt="image-20220511113744772"></p>
<ul>
<li>常见的链表结构有如下的形式：</li>
</ul>
<p><img src="/images/1563448858180-1661445988506.png" alt="1563448858180"></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8.png"></p>
<!-- <img src="images/数据结构-链表.png" alt="数据结构-链表" style="zoom:50%;" />   -->

<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><ul>
<li><p>栈（Stack）又称为堆栈或堆叠，是限制仅在表的一端进行插入和删除运算的线性表。</p>
</li>
<li><p>栈按照<code>先进后出(FILO,first in last out)</code>的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶。每次删除（退栈）的总是删除当前栈中最后插入（进栈）的元素，而最先插入的是被放在栈的底部，要到最后才能删除。</p>
</li>
<li><p>核心类库中的栈结构有Stack和LinkedList。</p>
<ul>
<li>Stack就是顺序栈，它是Vector的子类。</li>
<li>LinkedList是链式栈。</li>
</ul>
</li>
<li><p>体现栈结构的操作方法：</p>
<ul>
<li>peek()方法：查看栈顶元素，不弹出</li>
<li>pop()方法：弹出栈</li>
<li>push(E e)方法：压入栈</li>
</ul>
</li>
<li><p>时间复杂度:</p>
<ul>
<li>索引: <code>O(n)</code></li>
<li>搜索: <code>O(n)</code></li>
<li>插入: <code>O(1)</code></li>
<li>移除: <code>O(1)</code></li>
</ul>
</li>
<li><p>图示：</p>
</li>
</ul>
<p><img src="/images/image-20220826010258638.png">  </p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88.png">  </p>
<!-- <img src="images/image-20220826010258638.png" alt="image-20220826010258638" style="zoom:80%;" />

<img src="images/数据结构-栈.png" alt="数据结构-栈" style="zoom:50%;" />   -->

<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul>
<li><p>队列（Queue）是只允许在一端进行插入，而在另一端进行删除的运算受限的线性表。</p>
</li>
<li><p>队列是逻辑结构，其物理结构可以是数组，也可以是链表。</p>
</li>
<li><p>队列的修改原则：队列的修改是依<code>先进先出（FIFO）的原则</code>进行的。新来的成员总是加入队尾（即不允许”加塞”），每次离开的成员总是队列头上的（不允许中途离队），即当前”最老的”成员离队。</p>
</li>
<li><p>图示：</p>
</li>
</ul>
<p><img src="/images/image-20220826010241172.png" alt="image-20220826010241172">  </p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97.png"></p>
<!-- <img src="images/数据结构-队列.png" alt="数据结构-队列" style="zoom:50%;" />   -->

<h4 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h4><ol>
<li>树的理解</li>
</ol>
<p><img src="/images/image-20220521111904272.png"></p>
<!-- <img src="images/image-20220521111904272.png" alt="image-20220521111904272" style="zoom:67%;" /> -->

<p><strong>专有名词解释：</strong></p>
<p><code>结点</code>：树中的数据元素都称之为结点</p>
<p><code>根节点</code>：最上面的结点称之为根，一颗树只有一个根且由根发展而来，从另外一个角度来说，每个结点都可以认为是其子树的根</p>
<p><code>父节点</code>：结点的上层结点，如图中，结点K的父节点是E、结点L的父节点是G</p>
<p><code>子节点</code>：节点的下层结点，如图中，节点E的子节点是K节点、节点G的子节点是L节点</p>
<p><code>兄弟节点</code>：具有相同父节点的结点称为兄弟节点，图中F、G、H互为兄弟节点</p>
<p><code>结点的度数</code>：每个结点所拥有的子树的个数称之为结点的度，如结点B的度为3</p>
<p><code>树叶</code>：度数为0的结点，也叫作终端结点，图中D、K、F、L、H、I、J都是树叶</p>
<p><code>非终端节点（或分支节点）</code>：树叶以外的节点，或度数不为0的节点。图中根、A、B、C、E、G都是</p>
<p><code>树的深度（或高度）</code>：树中结点的最大层次数，图中树的深度为4</p>
<p><code>结点的层数</code>：从根节点到树中某结点所经路径上的分支树称为该结点的层数，根节点的层数规定为1，其余结点的层数等于其父亲结点的层数+1</p>
<p><code>同代</code>：在同一棵树中具有相同层数的节点</p>
<ol start="2">
<li>二叉树的基本概念</li>
</ol>
<p>二叉树（Binary tree）是树形结构的一个重要类型。二叉树特点是每个结点最多只能有两棵子树，且有左右之分。许多实际问题抽象出来的数据结构往往是二叉树形式，二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。</p>
<p><img src="/images/1563449427345-1661447692846.png" alt="1563449427345"></p>
<ol start="3">
<li>二叉树的遍历</li>
</ol>
<ul>
<li><p><strong>前序遍历：中左右（根左右）</strong></p>
<p>即先访问根结点，再前序遍历左子树，最后再前序遍历右子 树。前序遍历运算访问二叉树各结点是以根、左、右的顺序进行访问的。</p>
</li>
<li><p><strong>中序遍历：左中右（左根右）</strong></p>
<p>即先中前序遍历左子树，然后再访问根结点，最后再中序遍 历右子树。中序遍历运算访问二叉树各结点是以左、根、右的顺序进行访问的。</p>
</li>
<li><p><strong>后序遍历：左右中（左右根）</strong></p>
<p>即先后序遍历左子树，然后再后序遍历右子树，最后访问根 结点。后序遍历运算访问二叉树各结点是以左、右、根的顺序进行访问的。</p>
</li>
</ul>
<p><img src="/images/1574575739236-1661447692846.png"></p>
<!-- <img src="images/1574575739236-1661447692846.png" alt="1574575739236" style="zoom:80%;" /> -->

<p>前序遍历：ABDHIECFG</p>
<p>中序遍历：HDIBEAFCG</p>
<p>后序遍历：HIDEBFGCA</p>
<ol start="4">
<li>经典二叉树</li>
</ol>
<p><img src="/images/image-20220521153016348.png"></p>
<!-- <img src="images/image-20220521153016348.png" alt="image-20220521153016348" style="zoom: 67%;" /> -->

<p>1、<code>满二叉树</code>： 除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树。 第n层的结点数是2的n-1次方，总的结点个数是2的n次方-1</p>
<p><img src="/images/1574575163883-1661447692846.png" alt="1574575163883"></p>
<p>2、<code>完全二叉树</code>： 叶结点只能出现在最底层的两层，且最底层叶结点均处于次底层叶结点的左侧。</p>
<p><img src="/images/1574575180247-1661447692846.png" alt="1574575180247"></p>
<p>3、<code>二叉排序/查找/搜索树</code>：即为BST  (binary search&#x2F;sort tree)。满足如下性质：<br>（1）若它的左子树不为空，则左子树上所有结点的值均小于它的根节点的值；<br>（2）若它的右子树上所有结点的值均大于它的根节点的值；<br>（3）它的左、右子树也分别为二叉排序&#x2F;查找&#x2F;搜索树。</p>
<!-- <img src="images/image-20220521145208018.png" alt="image-20220521145208018" style="zoom: 67%;" /> -->
<p><img src="/images/image-20220521145208018.png"></p>
<blockquote>
<p>对二叉查找树进行中序遍历，得到有序集合。便于检索。</p>
</blockquote>
<p>4、<code>平衡二叉树</code>：（Self-balancing binary search tree，AVL）首先是二叉排序树，此外具有以下性质：<br>（1）它是一棵空树或它的左右两个子树的高度差的绝对值不超过1<br>（2）并且左右两个子树也都是一棵平衡二叉树<br>（3）不要求非叶节点都有两个子结点 </p>
<blockquote>
<p>平衡二叉树的目的是为了减少二叉查找树的层次，提高查找速度。平衡二叉树的常用实现有红黑树、AVL、替罪羊树、Treap、伸展树等。</p>
</blockquote>
<p><img src="/images/image-20220521150151219.png"></p>
<!-- <img src="images/image-20220521150151219.png" alt="image-20220521150151219" style="zoom: 50%;" /> -->



<p>5、<code>红黑树</code>：即Red-Black Tree。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。 </p>
<p>红黑树是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，它是在 1972 年由 Rudolf Bayer 发明的。红黑树是复杂的，但它的操作有着<code>良好的最坏情况运行时间</code>，并且在<code>实践中是高效的</code>：它可以在 O(log n)时间内做查找，插入和删除， 这里的 n 是树中元素的数目。</p>
<p>红黑树的特性：</p>
<ul>
<li><p>每个节点是红色或者黑色</p>
</li>
<li><p>根节点是黑色</p>
</li>
<li><p>每个叶子节点（NIL）是黑色。（注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点）</p>
</li>
<li><p>每个红色节点的两个子节点都是黑色的。(从每个叶子到根的所有路径上不能有两个连续的红色节点) </p>
</li>
<li><p>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点（确保没有一条路径会比其他路径长出2倍）</p>
</li>
</ul>
<p><img src="/images/%E7%BA%A2%E9%BB%91%E6%A0%91-1661447692846.jpeg"></p>
<p>当我们插入或删除节点时，可能会破坏已有的红黑树，使得它不满足以上5个要求，那么此时就需要进行处理，使得它继续满足以上的5个要求：</p>
<p>1、<code>recolor</code> ：将某个节点变红或变黑</p>
<p>2、<code>rotation</code> ：将红黑树某些结点分支进行旋转（左旋或右旋）</p>
<p> <img src="/images/image-20221208212053079.png" alt="image-20221208212053079"></p>
<blockquote>
<p>红黑树可以通过红色节点和黑色节点尽可能的保证二叉树的平衡。主要是用它来存储有序的数据，它的时间复杂度是O(logN)，效率非常之高。</p>
</blockquote>
<h3 id="List接口下的实现类的源码剖析"><a href="#List接口下的实现类的源码剖析" class="headerlink" title="List接口下的实现类的源码剖析"></a>List接口下的实现类的源码剖析</h3><p>【面试题】ArrayList、Vector、LinkedList的三者的对比？</p>
<ul>
<li>层次1：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|-----子接口：List:存储有序的、可重复的数据 (&quot;动态&quot;数组)</span><br><span class="line">       |---- ArrayList:List的主要实现类；线程不安全的、效率高；底层使用Object[]数组存储</span><br><span class="line">                       在添加数据、查找数据时，效率较高；在插入、删除数据时，效率较低</span><br><span class="line">       |---- LinkedList:底层使用双向链表的方式进行存储；在对集合中的数据进行频繁的删除、插入操作时，建议使用此类在插入、删除数据时，效率较高；在添加数据、查找数据时，效率较低；</span><br><span class="line">       |---- Vector:List的古老实现类；线程安全的、效率低；底层使用Object[]数组存储</span><br></pre></td></tr></table></figure>

<ul>
<li>层次2：查看相关api的源码</li>
</ul>
<h4 id="ArrayList源码解析"><a href="#ArrayList源码解析" class="headerlink" title="ArrayList源码解析"></a>ArrayList源码解析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1. jdk7版本：(以jdk1.7.0_07为例)</span><br><span class="line">//如下代码的执行：底层会初始化数组，数组的长度为10。Object[] elementData = new Object[10];</span><br><span class="line">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">list.add(&quot;AA&quot;); //elementData[0] = &quot;AA&quot;;</span><br><span class="line">list.add(&quot;BB&quot;);//elementData[1] = &quot;BB&quot;;</span><br><span class="line">...</span><br><span class="line">当要添加第11个元素的时候，底层的elementData数组已满，则需要扩容。默认扩容为原来长度的1.5倍。并将原有数组</span><br><span class="line">中的元素复制到新的数组中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. jdk8版本:(以jdk1.8.0_271为例)</span><br><span class="line">//如下代码的执行：底层会初始化数组，即：Object[] elementData = new Object[]&#123;&#125;;</span><br><span class="line">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">list.add(&quot;AA&quot;); //首次添加元素时，会初始化数组elementData = new Object[10];elementData[0] = &quot;AA&quot;;</span><br><span class="line">list.add(&quot;BB&quot;);//elementData[1] = &quot;BB&quot;;</span><br><span class="line">...</span><br><span class="line">当要添加第11个元素的时候，底层的elementData数组已满，则需要扩容。默认扩容为原来长度的1.5倍。并将原有数组</span><br><span class="line">中的元素复制到新的数组中。</span><br><span class="line"></span><br><span class="line">小结：</span><br><span class="line">jdk1.7.0_07版本中：ArrayList类似于饿汉式</span><br><span class="line">jdk1.8.0_271版本中：ArrayList类似于懒汉式</span><br></pre></td></tr></table></figure>
<h4 id="Vector源码解析"><a href="#Vector源码解析" class="headerlink" title="Vector源码解析"></a>Vector源码解析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vector源码解析：(以jdk1.8.0_271为例)</span><br><span class="line"></span><br><span class="line">Vector v = new Vector(); //底层初始化数组，长度为10.Object[] elementData = new Object[10];</span><br><span class="line">v.add(&quot;AA&quot;); //elementData[0] = &quot;AA&quot;;</span><br><span class="line">v.add(&quot;BB&quot;);//elementData[1] = &quot;BB&quot;;</span><br><span class="line">...</span><br><span class="line">当添加第11个元素时，需要扩容。默认扩容为原来的2倍。</span><br></pre></td></tr></table></figure>
<h4 id="LinkedList源码解析"><a href="#LinkedList源码解析" class="headerlink" title="LinkedList源码解析"></a>LinkedList源码解析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">LinkedList在jdk8中的源码解析：</span><br><span class="line"></span><br><span class="line">LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;(); //底层也没做啥</span><br><span class="line">list.add(&quot;AA&quot;); //将&quot;AA&quot;封装到一个Node对象1中，list对象的属性first、last都指向此Node对象1。</span><br><span class="line">list.add(&quot;BB&quot;); //将&quot;BB&quot;封装到一个Node对象2中，对象1和对象2构成一个双向链表，同时last指向此Node对象2</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">因为LinkedList使用的是双向链表，不需要考虑扩容问题。</span><br><span class="line"></span><br><span class="line">LinkedList内部声明：</span><br><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>启示与开发建议</li>
</ul>
<ol>
<li><p>Vector基本不使用了。</p>
</li>
<li><p>ArrayList底层使用数组结构，查找和添加（尾部添加）操作效率高，时间复杂度为O(1);删除和插入操作效率低，时间复杂度为O(n)<br>LinkedList底层使用双向链表结构，删除和插入操作效率高，时间复杂度为O(1);查找和添加（尾部添加）操作效率高，时间复杂度为O(n) (有可能添加操作是O(1))</p>
</li>
<li><p>在选择了ArrayList的前提下，new ArrayList() : 底层创建长度为10的数组。new ArrayList(int capacity):底层创建指定capacity长度的数组。如果开发中，大体确认数组的长度，则推荐使用ArrayList(int capacity)这个构造器，避免了底层的扩容、复制数组的操作。</p>
</li>
</ol>
<h3 id="Map接口下的实现类的源码剖析"><a href="#Map接口下的实现类的源码剖析" class="headerlink" title="Map接口下的实现类的源码剖析"></a>Map接口下的实现类的源码剖析</h3><h4 id="HashMap源码解析"><a href="#HashMap源码解析" class="headerlink" title="HashMap源码解析"></a>HashMap源码解析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">1. jdk7中创建对象和添加数据过程(以JDK1.7.0_07为例说明)：</span><br><span class="line"></span><br><span class="line">//创建对象的过程中，底层会初始化数组Entry[] table = new Entry[16];</span><br><span class="line">HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">...</span><br><span class="line">map.put(&quot;AA&quot;,78); //&quot;AA&quot;和78封装到一个Entry对象中，考虑将此对象添加到table数组中。</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">添加/修改的过程：</span><br><span class="line">将(key1,value1)添加到当前的map中：</span><br><span class="line">首先，需要调用key1所在类的hashCode()方法，计算key1对应的哈希值1，此哈希值1经过某种算法(hash())之后，得到哈希值2。</span><br><span class="line">哈希值2再经过某种算法(indexFor())之后，就确定了(key1,value1)在数组table中的索引位置i。</span><br><span class="line">  1.1 如果此索引位置i的数组上没有元素，则(key1,value1)添加成功。  ----&gt;情况1</span><br><span class="line">  1.2 如果此索引位置i的数组上有元素(key2,value2),则需要继续比较key1和key2的哈希值2  ---&gt;哈希冲突</span><br><span class="line">         2.1 如果key1的哈希值2与key2的哈希值2不相同，则(key1,value1)添加成功。   ----&gt;情况2</span><br><span class="line">         2.2 如果key1的哈希值2与key2的哈希值2相同，则需要继续比较key1和key2的equals()。要调用key1所在类的equals(),将key2作为参数传递进去。</span><br><span class="line">               3.1 调用equals()，返回false: 则(key1,value1)添加成功。   ----&gt;情况3</span><br><span class="line">               3.2 调用equals()，返回true: 则认为key1和key2是相同的。默认情况下，value1替换原有的value2。</span><br><span class="line"></span><br><span class="line">说明：情况1：将(key1,value1)存放到数组的索引i的位置</span><br><span class="line">     情况2,情况3：(key1,value1)元素与现有的(key2,value2)构成单向链表结构，(key1,value1)指向(key2,value2)</span><br><span class="line"></span><br><span class="line">随着不断的添加元素，在满足如下的条件的情况下，会考虑扩容：</span><br><span class="line">(size &gt;= threshold) &amp;&amp; (null != table[i])</span><br><span class="line">当元素的个数达到临界值(-&gt; 数组的长度 * 加载因子)时，就考虑扩容。默认的临界值 = 16 * 0.75 --&gt; 12.</span><br><span class="line">默认扩容为原来的2倍。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. jdk8与jdk7的不同之处(以jdk1.8.0_271为例)：</span><br><span class="line">① 在jdk8中，当我们创建了HashMap实例以后，底层并没有初始化table数组。当首次添加(key,value)时，进行判断，如果发现table尚未初始化，则对数组进行初始化。</span><br><span class="line">② 在jdk8中，HashMap底层定义了Node内部类，替换jdk7中的Entry内部类。意味着，我们创建的数组是Node[]</span><br><span class="line">③ 在jdk8中，如果当前的(key,value)经过一系列判断之后，可以添加到当前的数组角标i中。如果此时角标i位置上有</span><br><span class="line">   元素。在jdk7中是将新的(key,value)指向已有的旧的元素（头插法），而在jdk8中是旧的元素指向新的</span><br><span class="line">   (key,value)元素（尾插法）。 &quot;七上八下&quot;</span><br><span class="line">④ jdk7:数组+单向链表</span><br><span class="line">   jk8:数组+单向链表 + 红黑树</span><br><span class="line">   什么时候会使用单向链表变为红黑树：如果数组索引i位置上的元素的个数达到8，并且数组的长度达到64时，我们就将此索引i位置上</span><br><span class="line">                               的多个元素改为使用红黑树的结构进行存储。（为什么修改呢？红黑树进行put()/get()/remove()</span><br><span class="line">                               操作的时间复杂度为O(logn)，比单向链表的时间复杂度O(n)的好。性能更高。</span><br><span class="line">   什么时候会使用红黑树变为单向链表：当使用红黑树的索引i位置上的元素的个数低于6的时候，就会将红黑树结构退化为单向链表。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. 属性/字段：</span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // 默认的初始容量 16</span><br><span class="line">static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; //最大容量  1 &lt;&lt; 30</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;  //默认加载因子</span><br><span class="line">static final int TREEIFY_THRESHOLD = 8; //默认树化阈值8，当链表的长度达到这个值后，要考虑树化</span><br><span class="line">static final int UNTREEIFY_THRESHOLD = 6;//默认反树化阈值6，当树中结点的个数达到此阈值后，要考虑变为链表</span><br><span class="line"></span><br><span class="line">//当单个的链表的结点个数达到8，并且table的长度达到64，才会树化。</span><br><span class="line">//当单个的链表的结点个数达到8，但是table的长度未达到64，会先扩容</span><br><span class="line">static final int MIN_TREEIFY_CAPACITY = 64; //最小树化容量64</span><br><span class="line"></span><br><span class="line">transient Node&lt;K,V&gt;[] table; //数组</span><br><span class="line">transient int size;  //记录有效映射关系的对数，也是Entry对象的个数</span><br><span class="line">int threshold; //阈值，当size达到阈值时，考虑扩容</span><br><span class="line">final float loadFactor; //加载因子，影响扩容的频率</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1. LinkedHashMap 与 HashMap 的关系:</span><br><span class="line">&gt; LinkedHashMap 是 HashMap的子类。</span><br><span class="line">&gt; LinkedHashMap在HashMap使用的数组+单向链表+红黑树的基础上，又增加了一对双向链表，记录添加的(key,value)的</span><br><span class="line">先后顺序。便于我们遍历所有的key-value。</span><br><span class="line"></span><br><span class="line">LinkedHashMap重写了HashMap的如下方法：</span><br><span class="line">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p = new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. 底层结构：LinkedHashMap内部定义了一个Entry</span><br><span class="line">static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after; //增加的一对双向链表</span><br><span class="line">    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        super(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="HashSet和LinkedHashSet的源码分析"><a href="#HashSet和LinkedHashSet的源码分析" class="headerlink" title="HashSet和LinkedHashSet的源码分析"></a>HashSet和LinkedHashSet的源码分析</h4><blockquote>
<p>HashSet底层使用的是HashMap<br>LinkedHashSet底层使用的是LinkedHashMap</p>
</blockquote>
<h2 id="企业真题（十四）"><a href="#企业真题（十四）" class="headerlink" title="企业真题（十四）"></a>企业真题（十四）</h2><h3 id="数据结构相关"><a href="#数据结构相关" class="headerlink" title="数据结构相关"></a>数据结构相关</h3><h4 id="1-链表和数组有什么区别？（腾-）"><a href="#1-链表和数组有什么区别？（腾-）" class="headerlink" title="1. 链表和数组有什么区别？（腾*）"></a>1. 链表和数组有什么区别？（腾*）</h4><p>略</p>
<h4 id="2-栈是如何运行的？-西-信息技术"><a href="#2-栈是如何运行的？-西-信息技术" class="headerlink" title="2. 栈是如何运行的？(西*信息技术)"></a>2. 栈是如何运行的？(西*信息技术)</h4><p>先进后出。属于ADT(abstract data type)，可以使用数组、链表实现栈结构</p>
<h3 id="List集合源码相关"><a href="#List集合源码相关" class="headerlink" title="List集合源码相关"></a>List集合源码相关</h3><h4 id="1-ArrayList的默认大小是多少，以及扩容机制（顺-、凡-科技）"><a href="#1-ArrayList的默认大小是多少，以及扩容机制（顺-、凡-科技）" class="headerlink" title="1. ArrayList的默认大小是多少，以及扩容机制（顺*、凡*科技）"></a>1. ArrayList的默认大小是多少，以及扩容机制（顺*、凡*科技）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; 说说ArrayList的扩容机制吧(国*电网)</span><br><span class="line">&gt; 讲一下ArrayList的扩容机制（*实在）</span><br><span class="line">&gt; ArrayList的扩容机制，为什么是10，为什么是1.5倍（*软国际）</span><br></pre></td></tr></table></figure>

<p>略</p>
<h4 id="2-ArrayList的底层是怎么实现的-（腾-）"><a href="#2-ArrayList的底层是怎么实现的-（腾-）" class="headerlink" title="2. ArrayList的底层是怎么实现的?（腾*）"></a>2. ArrayList的底层是怎么实现的?（腾*）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">集合类的ArrayList底层（安全不安全，扩容，初始大小，添加删除查询是怎么操作的，底层是什么组成的）</span><br><span class="line">（湖**利软件、汇*云通、猎*、苏州***动、上海*进天下、北京博*软件、*科软、大连*点科技、中*亿达、德*物流、天*伟业、猫*娱乐）</span><br></pre></td></tr></table></figure>

<p>略。</p>
<p>建议：ArrayList(int capacity){}</p>
<h4 id="3-在ArrayList中remove后面几个元素该怎么做-（惠-、中-亿达）"><a href="#3-在ArrayList中remove后面几个元素该怎么做-（惠-、中-亿达）" class="headerlink" title="3. 在ArrayList中remove后面几个元素该怎么做?（惠*、中*亿达）"></a>3. 在ArrayList中remove后面几个元素该怎么做?（惠*、中*亿达）</h4><p>前移。</p>
<h4 id="4-ArrayList1-7和1-8的区别（拓-思）"><a href="#4-ArrayList1-7和1-8的区别（拓-思）" class="headerlink" title="4. ArrayList1.7和1.8的区别（拓*思）"></a>4. ArrayList1.7和1.8的区别（拓*思）</h4><p>类似于饿汉式、懒汉式</p>
<h4 id="5-数组和-ArrayList-的区别（阿-、-科软）"><a href="#5-数组和-ArrayList-的区别（阿-、-科软）" class="headerlink" title="5. 数组和 ArrayList 的区别（阿*、*科软）"></a>5. 数组和 ArrayList 的区别（阿*、*科软）</h4><p> ArrayList看做是对数组的常见操作的封装。</p>
<h4 id="6-什么是线程安全的List？-平-金服"><a href="#6-什么是线程安全的List？-平-金服" class="headerlink" title="6. 什么是线程安全的List？(平*金服)"></a>6. 什么是线程安全的List？(平*金服)</h4><p>Vector：线程安全的。</p>
<p>ArrayList：线程不安全。—-&gt; 使用同步机制处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashMap:线程不安全。 ----&gt; 使用同步机制处理。</span><br><span class="line">                   -----&gt; JUC:ConcurrentHashMap</span><br></pre></td></tr></table></figure>

<h3 id="HashMap集合源码相关"><a href="#HashMap集合源码相关" class="headerlink" title="HashMap集合源码相关"></a>HashMap集合源码相关</h3><h4 id="1-说说HahMap底层实现-新-股份、顺-、猫-娱乐"><a href="#1-说说HahMap底层实现-新-股份、顺-、猫-娱乐" class="headerlink" title="1. 说说HahMap底层实现(新*股份、顺*、猫*娱乐)"></a>1. 说说HahMap底层实现(新*股份、顺*、猫*娱乐)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; HashMap的实现讲一下？（腾*，上海**网络）</span><br><span class="line">&gt; 说说HashMap的底层执行原理？（滴*，纬*软件，上海*想，*昂，*蝶**云，宇*科技，*东数科，猎*网）</span><br><span class="line">&gt; 详细说一下 HashMap 的 put 过程（*度）</span><br><span class="line">&gt; Java中的HashMap的工作原理是什么？（北京中**译咨询）</span><br><span class="line">&gt; 集合类的HashMap底层（安全不安全，扩容，初始大小，添加删除查询是怎么操作的，底层是什么组成的）（湖**利软件）</span><br><span class="line">&gt; HashMap 的存储过程（爱*信、杭州*智）</span><br><span class="line">&gt; Hashmap底层实现及构造（汇**通、猎*、苏州博*讯动、上海*进天下、北京博*软件、*科软、大连*点科技、中*亿达、德*物流、天*伟业、猫*娱乐）</span><br><span class="line">&gt; HashMap的实现原理（腾*、阿*）</span><br><span class="line">&gt; HaspMap底层讲一讲（*米）</span><br><span class="line">&gt; 说一下HashMap的实现，扩容机制？（*节）</span><br><span class="line">&gt; 讲一下 HashMap 中 put 方法过程？（阿*）</span><br></pre></td></tr></table></figure>

<p>略。建议以JDK8为主说明。</p>
<h4 id="2-HashMap初始值16，临界值12是怎么算的（软-力）"><a href="#2-HashMap初始值16，临界值12是怎么算的（软-力）" class="headerlink" title="2. HashMap初始值16，临界值12是怎么算的（软**力）"></a>2. HashMap初始值16，临界值12是怎么算的（软**力）</h4><p>16从底层源码的构造器中看到的。</p>
<p>12：threshold，使用数组的长度*加载因子(loadFactor)</p>
<h4 id="3-HashMap长度为什么是2的幂次方-国-时代"><a href="#3-HashMap长度为什么是2的幂次方-国-时代" class="headerlink" title="3. HashMap长度为什么是2的幂次方(国*时代)"></a>3. HashMap长度为什么是2的幂次方(国*时代)</h4><p>为了方便计算要添加的元素的底层的索引i。</p>
<h4 id="4-HashMap怎么计算哈希值和索引？扩容机制？怎么解决hash冲突？（-软国际、中软-腾）"><a href="#4-HashMap怎么计算哈希值和索引？扩容机制？怎么解决hash冲突？（-软国际、中软-腾）" class="headerlink" title="4. HashMap怎么计算哈希值和索引？扩容机制？怎么解决hash冲突？（*软国际、中软*腾）"></a>4. HashMap怎么计算哈希值和索引？扩容机制？怎么解决hash冲突？（*软国际、中软*腾）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; HashMap key的哈希冲突了怎么做（新*股份）</span><br><span class="line">&gt; HashMap的默认大小是多少，以及扩容机制（顺*、凡*科技）</span><br><span class="line">&gt; 讲一下HashMap的扩容机制？（好实*）</span><br></pre></td></tr></table></figure>

<p>略</p>
<h4 id="5-HashMap底层是数组-链表，有数组很快了，为什么加链表？（润-软件）"><a href="#5-HashMap底层是数组-链表，有数组很快了，为什么加链表？（润-软件）" class="headerlink" title="5. HashMap底层是数组+链表，有数组很快了，为什么加链表？（润*软件）"></a>5. HashMap底层是数组+链表，有数组很快了，为什么加链表？（润*软件）</h4><p>因为产生了哈希冲突。解决方案，使用链表的方式。保证要添加的元素仍然在索引i的位置上。</p>
<h4 id="6-HashMap为什么长度达到一定的长度要转化为红黑树（-度）"><a href="#6-HashMap为什么长度达到一定的长度要转化为红黑树（-度）" class="headerlink" title="6. HashMap为什么长度达到一定的长度要转化为红黑树（*度）"></a>6. HashMap为什么长度达到一定的长度要转化为红黑树（*度）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; HashMap为什么用红黑树（*软国际）</span><br></pre></td></tr></table></figure>

<p>红黑树的常用操作的时间复杂度O(logn)，比单向链表的O(n)效率高。</p>
<h4 id="7-HashMap什么时候扩充为红黑树，什么时候又返回到链表？（汉-）"><a href="#7-HashMap什么时候扩充为红黑树，什么时候又返回到链表？（汉-）" class="headerlink" title="7. HashMap什么时候扩充为红黑树，什么时候又返回到链表？（汉*）"></a>7. HashMap什么时候扩充为红黑树，什么时候又返回到链表？（汉*）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; HashMap什么时候转换为红黑树（杭州*智公司）</span><br><span class="line">&gt; 当HashMap中相同hashcode值的数据超过多少时会转变成红黑树？（百*云创）</span><br><span class="line">&gt; 什么时候是数据+链表，什么时候是红黑树（*软国际）</span><br></pre></td></tr></table></figure>

<p>索引i的位置的链表长度超过8且数组长度达到64，需要索引i位置要变成红黑树。</p>
<p>当索引i的位置元素的个数低于6时，要红黑树结构转为单向链表。为什么？节省空间。</p>
<h4 id="8-在-JDK1-8中，HashMap的数据结构与1-7相比有什么变化，这些变化的好处在哪里？（海-科）"><a href="#8-在-JDK1-8中，HashMap的数据结构与1-7相比有什么变化，这些变化的好处在哪里？（海-科）" class="headerlink" title="8. 在 JDK1.8中，HashMap的数据结构与1.7相比有什么变化，这些变化的好处在哪里？（海*科）"></a>8. 在 JDK1.8中，HashMap的数据结构与1.7相比有什么变化，这些变化的好处在哪里？（海*科）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">① 在jdk8中，当我们创建了HashMap实例以后，底层并没有初始化table数组。当首次添加(key,value)时，进行判断，</span><br><span class="line">如果发现table尚未初始化，则对数组进行初始化。</span><br><span class="line">② 在jdk8中，HashMap底层定义了Node内部类，替换jdk7中的Entry内部类。意味着，我们创建的数组是Node[]</span><br><span class="line">③ 在jdk8中，如果当前的(key,value)经过一系列判断之后，可以添加到当前的数组角标i中。如果此时角标i位置上有</span><br><span class="line">   元素。在jdk7中是将新的(key,value)指向已有的旧的元素（头插法），而在jdk8中是旧的元素指向新的</span><br><span class="line">   (key,value)元素（尾插法）。 &quot;七上八下&quot;</span><br><span class="line">④ jdk7:数组+单向链表</span><br><span class="line">   jk8:数组+单向链表 + 红黑树</span><br><span class="line">   什么时候会使用单向链表变为红黑树：如果数组索引i位置上的元素的个数达到8，并且数组的长度达到64时，我们就将此索引i位置上</span><br><span class="line">                               的多个元素改为使用红黑树的结构进行存储。（为什么修改呢？红黑树进行put()/get()/remove()</span><br><span class="line">                               操作的时间复杂度为O(logn)，比单向链表的时间复杂度O(n)的好。性能更高。</span><br><span class="line">   什么时候会使用红黑树变为单向链表：当使用红黑树的索引i位置上的元素的个数低于6的时候，就会将红黑树结构退化为单向链表。</span><br></pre></td></tr></table></figure>

<h4 id="9-HashMap的get-方法的原理-（顺-）"><a href="#9-HashMap的get-方法的原理-（顺-）" class="headerlink" title="9. HashMap的get()方法的原理?（顺*）"></a>9. HashMap的get()方法的原理?（顺*）</h4><p>参考put()</p>
<h3 id="hashCode和equals"><a href="#hashCode和equals" class="headerlink" title="hashCode和equals"></a>hashCode和equals</h3><h4 id="1-hashcode和equals区别？（海-供应链管理）"><a href="#1-hashcode和equals区别？（海-供应链管理）" class="headerlink" title="1. hashcode和equals区别？（海*供应链管理）"></a>1. hashcode和equals区别？（海*供应链管理）</h4><p>略</p>
<h4 id="2-hashCode-与-equals-生成算法、方法怎么重写？（阿-校招）"><a href="#2-hashCode-与-equals-生成算法、方法怎么重写？（阿-校招）" class="headerlink" title="2. hashCode() 与 equals() 生成算法、方法怎么重写？（阿*校招）"></a>2. hashCode() 与 equals() 生成算法、方法怎么重写？（阿*校招）</h4><p>进行equals()判断使用的属性，通常也都会参与到hashCode()的计算中。</p>
<p>尽量保证hashCode()的一致性。（使用IDEA自动生成，hashCode()自动使用相关的算法。</p>
<h4 id="3-说一下equals和-x3D-x3D-的区别，然后问equals相等hash值一定相等吗？hash值相等equals一定相等吗？（南-电网、上海-智网络）"><a href="#3-说一下equals和-x3D-x3D-的区别，然后问equals相等hash值一定相等吗？hash值相等equals一定相等吗？（南-电网、上海-智网络）" class="headerlink" title="3. 说一下equals和&#x3D;&#x3D;的区别，然后问equals相等hash值一定相等吗？hash值相等equals一定相等吗？（南*电网、上海*智网络）"></a>3. 说一下equals和&#x3D;&#x3D;的区别，然后问equals相等hash值一定相等吗？hash值相等equals一定相等吗？（南*电网、上海*智网络）</h4><p>equals相等hash值一定相等吗? 是</p>
<p>hash值相等equals一定相等吗？不一定</p>
<h3 id="Set集合源码相关"><a href="#Set集合源码相关" class="headerlink" title="Set集合源码相关"></a>Set集合源码相关</h3><h4 id="1-HashSet存放数据的方式？（拓-软件）"><a href="#1-HashSet存放数据的方式？（拓-软件）" class="headerlink" title="1. HashSet存放数据的方式？（拓*软件）"></a>1. HashSet存放数据的方式？（拓*软件）</h4><p>底层使用HashMap。说一下HashMap</p>
<h4 id="2-Set是如何实现元素的唯一性？（湖-利软件）"><a href="#2-Set是如何实现元素的唯一性？（湖-利软件）" class="headerlink" title="2. Set是如何实现元素的唯一性？（湖**利软件）"></a>2. Set是如何实现元素的唯一性？（湖**利软件）</h4><p>略</p>
<h4 id="3-用哪两种方式来实现集合的排序（凡-科技）"><a href="#3-用哪两种方式来实现集合的排序（凡-科技）" class="headerlink" title="3. 用哪两种方式来实现集合的排序（凡*科技）"></a>3. 用哪两种方式来实现集合的排序（凡*科技）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; 集合怎么排序？（北京中**信科技）</span><br></pre></td></tr></table></figure>

<p>自然排序、定制排序。</p>
<h2 id="File类与IO流"><a href="#File类与IO流" class="headerlink" title="File类与IO流"></a>File类与IO流</h2><h3 id="File类的使用"><a href="#File类的使用" class="headerlink" title="File类的使用"></a>File类的使用</h3><ul>
<li>位于java.io包下</li>
<li>File类的一个实例对应着磁盘上的一个文件或文件目录。  —-&gt; “万事万物皆对象”</li>
<li>（熟悉）File的实例化、常用的方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">构造器</span><br><span class="line">    * public File(String pathname) ：以 pathname 为路径创建 File 对象，可以是绝对路径或者相对路径，如果 pathname 是相对路径，则默认的当前路径在系统属性user.dir 中存储。</span><br><span class="line">    * public File(String parent, String child) ：以 parent 为父路径，child 为子路径创建 File 对象。</span><br><span class="line">    * public File(File parent, String child) ：根据一个父 File 对象和子文件路径创建 File 对象。  </span><br><span class="line">获取文件和目录基本信息</span><br><span class="line">    * public String getName() ：获取名称</span><br><span class="line">    * public String getPath() ：获取路径</span><br><span class="line">    * public String getAbsolutePath()：获取绝对路径</span><br><span class="line">    * public File getAbsoluteFile()：获取绝对路径表示的文件</span><br><span class="line">    * public String getParent()：获取上层文件目录路径。若无，返回null</span><br><span class="line">    * public long length() ：获取文件长度（即：字节数）。不能获取目录的长度。</span><br><span class="line">    * public long lastModified() ：获取最后一次的修改时间，毫秒值</span><br><span class="line">列出目录的下一级</span><br><span class="line">     * public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。</span><br><span class="line">     * public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。</span><br><span class="line">File类的重命名功能</span><br><span class="line">    * public boolean renameTo(File dest):把文件重命名为指定的文件路径。</span><br><span class="line">判断功能的方法</span><br><span class="line">    * public boolean exists() ：此File表示的文件或目录是否实际存在。</span><br><span class="line">    * public boolean isDirectory() ：此File表示的是否为目录。</span><br><span class="line">    * public boolean isFile() ：此File表示的是否为文件。</span><br><span class="line">    * public boolean canRead() ：判断是否可读</span><br><span class="line">    * public boolean canWrite() ：判断是否可写</span><br><span class="line">    * public boolean isHidden() ：判断是否隐藏</span><br><span class="line">创建、删除功能</span><br><span class="line">    * public boolean createNewFile() ：创建文件。若文件存在，则不创建，返回false。</span><br><span class="line">    * public boolean mkdir() ：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。</span><br><span class="line">    * public boolean mkdirs() ：创建文件目录。如果上层文件目录不存在，一并创建。</span><br><span class="line">    * public boolean delete() ：删除文件或者文件夹</span><br><span class="line">      删除注意事项：① Java中的删除不走回收站。② 要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录。</span><br></pre></td></tr></table></figure>

<ul>
<li>File类中声明了新建、删除、获取名称、重命名等方法，并没有涉及到文件内容的读写操作。要想实现文件内容的读写，我们就需要使用io流。</li>
<li>File类的对象，通常是作为io流操作的文件的端点出现的。代码层面，将File类的对象作为参数传递到IO流相关类的构造器中。</li>
</ul>
<h3 id="IO流的概述"><a href="#IO流的概述" class="headerlink" title="IO流的概述"></a>IO流的概述</h3><ul>
<li>IO流的分类<ul>
<li>流向：输入流、输出流</li>
<li>处理数据单位：字节流、字符流</li>
<li>流的角色：节点流、处理流</li>
</ul>
</li>
<li>IO的4个抽象基类：InputStream \ OutputStream \ Reader \ Writer</li>
</ul>
<h3 id="节点流之一：文件流"><a href="#节点流之一：文件流" class="headerlink" title="节点流之一：文件流"></a>节点流之一：文件流</h3><ul>
<li>FileInputStream \ FileOutputStream \ FileReader \ FileWriter</li>
<li>执行步骤：<ul>
<li>第1步：创建读取或写出的File类的对象</li>
<li>第2步：创建输入流或输出流</li>
<li>第3步：具体的读入或写出的过程。<br>  读入：read(char[] cbuffer)<br>  写出：write(String str) &#x2F; write(char[] cbuffer,0,len)</li>
<li>第4步：关闭流资源，避免内存泄漏</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 需求：复制一份hello.txt文件，命名为hello_copy.txt</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 创建File类的对象</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">            <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello_copy.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2. 创建输入流、输出流</span></span><br><span class="line">            fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(srcFile);</span><br><span class="line">            fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(destFile);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3. 数据的读入和写出的过程</span></span><br><span class="line">            <span class="type">char</span>[] cbuffer = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="type">int</span> len;<span class="comment">//记录每次读入到cbuffer中的字符的个数</span></span><br><span class="line">            <span class="keyword">while</span> ((len = fr.read(cbuffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//write(char[] cbuffer,int fromIndex,int len)</span></span><br><span class="line">                fw.write(cbuffer, <span class="number">0</span>, len); <span class="comment">//正确的</span></span><br><span class="line"><span class="comment">//                fw.write(cbuffer); //错误的</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;复制成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4. 关闭流资源</span></span><br><span class="line">            <span class="comment">//方式1：</span></span><br><span class="line"><span class="comment">//            try &#123;</span></span><br><span class="line">                <span class="comment">//if (fw != null)</span></span><br><span class="line"><span class="comment">//                  fw.close();</span></span><br><span class="line"><span class="comment">//            &#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="comment">//                e.printStackTrace();</span></span><br><span class="line"><span class="comment">//            &#125;finally &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                try &#123;</span></span><br><span class="line">                    <span class="comment">//if (fr != null)</span></span><br><span class="line"><span class="comment">//                    fr.close();</span></span><br><span class="line"><span class="comment">//                &#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="comment">//                    e.printStackTrace();</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="comment">//方式2：</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fw != <span class="literal">null</span>)</span><br><span class="line">                    fw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fr != <span class="literal">null</span>)</span><br><span class="line">                    fr.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>注意点：<br>① 因为涉及到流资源的关闭操作，所以出现异常的话，需要使用try-catch-finally的方式来处理异常<br>② 对于输入流来讲，要求File类的对象对应的物理磁盘上的文件必须存在。否则，会报FileNotFoundException<br> 对于输出流来讲，File类的对象对应的物理磁盘上的文件可以不存在。<br>  &gt; 如果此文件不存在，则在输出的过程中，会自动创建此文件，并写出数据到此文件中。<br>  &gt; 如果此文件存在，使用 FileWriter(File file) 或 FileWriter(File file,false):<br>                                          输出数据过程中，会新建同名的文件对现有的文件进行覆盖。<br>                 FileWriter(File file,true) : 输出数据过程中，会在现有的文件的末尾追加写出内容。</li>
</ul>
<h3 id="处理流之一：缓冲流"><a href="#处理流之一：缓冲流" class="headerlink" title="处理流之一：缓冲流"></a>处理流之一：缓冲流</h3><ul>
<li>BufferedInputStream \ BufferedOutputStream \ BufferedReader \ BufferedWriter</li>
<li>作用：实现更高效的读写数据的操作</li>
</ul>
<h3 id="处理流之二：转换流"><a href="#处理流之二：转换流" class="headerlink" title="处理流之二：转换流"></a>处理流之二：转换流</h3><ul>
<li>层次1：熟悉转换流的使用<ul>
<li>InputStreamReader、OutputStreamWriter：<ul>
<li>InputStreamReader:将一个输入型的字节流转换为输入型的字符流。</li>
<li>OutputStreamWriter:将一个输出型的字符流转换为输出型的字节流。</li>
</ul>
</li>
</ul>
</li>
<li>层次2：（掌握）字符的编码和解码的过程、常用的字符集<ul>
<li>解决相关的问题：读写字符出现乱码！本质问题：使用的解码集与编码集不一致。</li>
</ul>
</li>
</ul>
<h3 id="处理流之三：对象流"><a href="#处理流之三：对象流" class="headerlink" title="处理流之三：对象流"></a>处理流之三：对象流</h3><ul>
<li>层次1：熟悉对象流的使用<ul>
<li>ObjectInputStream:反序列化时需要使用的api，将文件中的数据或网络传输过来的数据还原为内存中的Java对象</li>
<li>ObjectOutputStream:序列化时需要使用的api，将内存中的Java对象保存在文件中或通过网络传输出去</li>
</ul>
</li>
<li>层次2：对象的序列化机制<ul>
<li>对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。&#x2F;&#x2F;当其它程序获取了这种二进制流，就可以恢复成原来的Java对象。</li>
<li>自定义类要想实现序列化机制，需要满足：<br>① 自定义类需要实现接口：Serializable<br>② 要求自定义类声明一个全局常量： static final long serialVersionUID &#x3D; 42234234L;用来唯一的标识当前的类。<br>③ 要求自定义类的各个属性也必须是可序列化的。  <blockquote>
<p>对于基本数据类型的属性：默认就是可以序列化的<br>对于引用数据类型的属性：要求实现Serializable接口</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="其它流的使用"><a href="#其它流的使用" class="headerlink" title="其它流的使用"></a>其它流的使用</h3><ul>
<li>了解：数据流：DataInputStream 、DataOutputStream</li>
<li>了解：标准的输入流、标准的输出流：System.in 、System.out</li>
<li>了解：打印流：PrintStream、PrintWriter</li>
</ul>
<h2 id="企业真题（十五）"><a href="#企业真题（十五）" class="headerlink" title="企业真题（十五）"></a>企业真题（十五）</h2><h3 id="IO流概述"><a href="#IO流概述" class="headerlink" title="IO流概述"></a>IO流概述</h3><h4 id="1-谈谈Java-IO里面的常用类，字节流，字符流-银-数据"><a href="#1-谈谈Java-IO里面的常用类，字节流，字符流-银-数据" class="headerlink" title="1. 谈谈Java IO里面的常用类，字节流，字符流(银*数据)"></a>1. 谈谈Java IO里面的常用类，字节流，字符流(银*数据)</h4><p>略</p>
<h4 id="2-Java-中有几种类型的流？JDK为每种类型的流提供一些抽象类以供继承，请说出他们分别是哪些类？（上海-厦-联网、极-科技）"><a href="#2-Java-中有几种类型的流？JDK为每种类型的流提供一些抽象类以供继承，请说出他们分别是哪些类？（上海-厦-联网、极-科技）" class="headerlink" title="2. Java 中有几种类型的流？JDK为每种类型的流提供一些抽象类以供继承，请说出他们分别是哪些类？（上海*厦*联网、极*科技）"></a>2. Java 中有几种类型的流？JDK为每种类型的流提供一些抽象类以供继承，请说出他们分别是哪些类？（上海*厦*联网、极*科技）</h4><p>InputStream \ OutputStream \ Reader \ Writer</p>
<h4 id="3-流一般需不需要关闭？如果关闭的话用什么方法？处理流是怎么关闭的？-银-数据"><a href="#3-流一般需不需要关闭？如果关闭的话用什么方法？处理流是怎么关闭的？-银-数据" class="headerlink" title="3. 流一般需不需要关闭？如果关闭的话用什么方法？处理流是怎么关闭的？(银*数据)"></a>3. 流一般需不需要关闭？如果关闭的话用什么方法？处理流是怎么关闭的？(银*数据)</h4><p>需要。close()</p>
<p>处理流在关闭过程中，也会关闭内部的流。</p>
<h4 id="4-OutputStream里面的write-是什么意思-君-科技"><a href="#4-OutputStream里面的write-是什么意思-君-科技" class="headerlink" title="4. OutputStream里面的write()是什么意思?(君*科技)"></a>4. OutputStream里面的write()是什么意思?(君*科技)</h4><p>数据写出的意思。</p>
<h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><h4 id="1-BufferedReader属于哪种流？他主要是用来做什么的？-国-电网"><a href="#1-BufferedReader属于哪种流？他主要是用来做什么的？-国-电网" class="headerlink" title="1. BufferedReader属于哪种流？他主要是用来做什么的？(国*电网)"></a>1. BufferedReader属于哪种流？他主要是用来做什么的？(国*电网)</h4><p>略</p>
<h4 id="2-什么是缓冲区？有什么作用？-北京中油"><a href="#2-什么是缓冲区？有什么作用？-北京中油" class="headerlink" title="2. 什么是缓冲区？有什么作用？(北京中油**)"></a>2. 什么是缓冲区？有什么作用？(北京中油**)</h4><p>内部提供了一个数组，将读取或要写出的数据，现在此数组中缓存。达到一定程度时，集中性的写出。</p>
<p>作用：减少与磁盘的交互，进而提升读写效率。</p>
<h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><h4 id="1-字节流和字符流是什么？怎么转换？-北京蓝-、-海-供应链管理）"><a href="#1-字节流和字符流是什么？怎么转换？-北京蓝-、-海-供应链管理）" class="headerlink" title="1. 字节流和字符流是什么？怎么转换？(北京蓝*、*海*供应链管理）"></a>1. 字节流和字符流是什么？怎么转换？(北京蓝*、*海*供应链管理）</h4><p><img src="/images/20240827220242.png"></p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><h4 id="1-什么是Java序列化，如何实现-君-科技、上海-厦物联网"><a href="#1-什么是Java序列化，如何实现-君-科技、上海-厦物联网" class="headerlink" title="1. 什么是Java序列化，如何实现(君*科技、上海*厦物联网)"></a>1. 什么是Java序列化，如何实现(君*科技、上海*厦物联网)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，</span><br><span class="line">或通过网络将这种二进制流传输到另一个网络节点。//当其它程序获取了这种二进制流，就可以恢复成原来的Java对象。</span><br></pre></td></tr></table></figure>

<h4 id="2-Java有些类中为什么需要实现Serializable接口？（阿-校招）"><a href="#2-Java有些类中为什么需要实现Serializable接口？（阿-校招）" class="headerlink" title="2. Java有些类中为什么需要实现Serializable接口？（阿*校招）"></a>2. Java有些类中为什么需要实现Serializable接口？（阿*校招）</h4><p>便于此类的对象实现序列化操作。</p>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="网络编程概述"><a href="#网络编程概述" class="headerlink" title="网络编程概述"></a>网络编程概述</h3><ul>
<li>计算机网络：把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模大、功能强的网络系统，从而使众多的计算机可以方便地互相传递信息、共享硬件、软件、数据信息等资源。</li>
<li>网络编程的目的：直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯。</li>
<li>需要解决的三个问题：<ul>
<li>问题1：如何准确地定位网络上一台或多台主机</li>
<li>问题2：如何定位主机上的特定的应用</li>
<li>问题3：找到主机后，如何可靠、高效地进行数据传输</li>
</ul>
</li>
</ul>
<h3 id="要素1：IP地址"><a href="#要素1：IP地址" class="headerlink" title="要素1：IP地址"></a>要素1：IP地址</h3><ul>
<li>使用具体的一个ip地址对应具体的一个互联网上的主机</li>
<li>IP分类：<ul>
<li>角度一：IPv4(占用4个字节)、IPv6(占用16个字节)</li>
<li>角度二：公网地址、私网地址（或局域网,以192.168开头)</li>
</ul>
</li>
<li>域名:便捷的记录ip地址</li>
<li>使用InetAddress类表示IP地址<ul>
<li>实例化：getByName(String host) 、getLocalHost()</li>
<li>常用方法：getHostName() 、getHostAddress()</li>
</ul>
</li>
</ul>
<h3 id="要素2：端口号"><a href="#要素2：端口号" class="headerlink" title="要素2：端口号"></a>要素2：端口号</h3><ul>
<li>用于区分同一台主机上的不同的进程，可以唯一标识主机中的进程（应用程序）</li>
<li>不同的进程分配不同的端口号</li>
<li>范围：0-65535</li>
</ul>
<h3 id="要素3：网络通信协议"><a href="#要素3：网络通信协议" class="headerlink" title="要素3：网络通信协议"></a>要素3：网络通信协议</h3><p>为了实现可靠而高效的数据传输。</p>
<ul>
<li>这里有两套参考模型<ul>
<li>OSI参考模型：将网络分为7层，模型过于理想化，未能在因特网上进行广泛推广</li>
<li>TCP&#x2F;IP参考模型(或TCP&#x2F;IP协议)：将网络分为4层：应用层、传输层、网络层、物理+数据链路层，事实上的国际标准。</li>
</ul>
</li>
<li>在传输层中涉及到两个协议：TCP、UDP。二者的对比<ul>
<li>TCP：可靠的连接（发送数据前，需要三次握手、四次挥手），进行大数据量的传输，效率低。</li>
<li>UDP：不可靠的连接（发送前，不需要确认对方是否在）、使用数据报传输（限制在64kb以内）、效率高。</li>
</ul>
</li>
<li>TCP的三次握手、四次挥手<ul>
<li>TCP 协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。第一次握手，客户端向服务器端发起 TCP 连接的请求；第二次握手，服务器端发送针对客户端 TCP 连接请求的确认；第三次握手，客户端发送确认的确认。</li>
<li>TCP 协议中，在发送数据结束后，释放连接时需要经过四次挥手。第一次挥手：客户端向服务器端提出结束连接，让服务器做最后的准备工作。此时，客户端处于半关闭状态，即表示不再向服务器发送数据了，但是还可以接受数据；第二次挥手：服务器接收到客户端释放连接的请求后，会将最后的数据发给客户端。并告知上层的应用进程不再接收数据；第三次挥手：服务器发送完数据后，会给客户端发送一个释放连接的报文。那么客户端接收后就知道可以正式释放连接了；第四次挥手：客户端接收到服务器最后的释放连接报文后，要回复一个彻底断开的报文。这样服务器收到后才会彻底释放连接。这里客户端，发送完最后的报文后，会等待 2MSL(Maximum Segment Lifetime)，因为有可能服务器没有收到最后的报文，那么服务器迟迟没收到，就会再次给客户端发送释放连接的报文，此时客户端在等待时间范围内接收到，会重新发送最后的报文，并重新计时。如果等待 2MSL 后，没有收到，那么彻底断开。</li>
</ul>
</li>
</ul>
<h3 id="TCP网络编程"><a href="#TCP网络编程" class="headerlink" title="TCP网络编程"></a>TCP网络编程</h3><p>开发步骤：</p>
<ul>
<li>客户端程序：<ol>
<li>创建 Socket ：根据指定服务端的 IP 地址或端口号构造 Socket 类对象。若服务器端响应，则建立客户端到服务器的通信线路。若连接失败，会出现异常。</li>
<li>打开连接到 Socket 的输入&#x2F; 出流： 使用 getInputStream()方法获得输入流，使用getOutputStream()方法获得输出流，进行数据传输</li>
<li>按照一定的协议对 Socket 进行读&#x2F; 写操作：通过输入流读取服务器放入线路的信息（但不能读取自己放入线路的信息），通过输出流将信息写入线路。</li>
<li>关闭 Socket ：断开客户端到服务器的连接，释放线路</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 创建一个Socket</span></span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inetAddress</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;192.168.21.107&quot;</span>); <span class="comment">//声明对方的ip地址</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8989</span>;<span class="comment">//声明对方的端口号</span></span><br><span class="line">            socket = <span class="keyword">new</span> <span class="title class_">Socket</span>(inetAddress, port);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2. 发送数据</span></span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            os.write(<span class="string">&quot;你好，我是客户端，请多多关照&quot;</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//3. 关闭socket、关闭流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (socket != <span class="literal">null</span>)</span><br><span class="line">                    socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (os != <span class="literal">null</span>) &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>服务器端程序：<ol>
<li>调用 ServerSocket(int port) ：创建一个服务器端套接字，并绑定到指定端口上。用<br>于监听客户端的请求。</li>
<li>调用 accept() ：监听连接请求，如果客户端请求连接，则接受连接，返回通信套接<br>字对象。</li>
<li>调用 该 Socket 类对象的 getOutputStream() 和 getInputStream () ：获取输出流和<br>输入流，开始网络数据的发送和接收。</li>
<li>关闭 Socket 对象：客户端访问结束，关闭通信套接字。</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//阻塞式的方法</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 创建一个ServerSocket</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8989</span>;</span><br><span class="line">            serverSocket = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2. 调用accept()，接收客户端的Socket</span></span><br><span class="line">            socket = serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;服务器端已开启&quot;</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;收到了来自于&quot;</span> + socket.getInetAddress().getHostAddress() + <span class="string">&quot;的连接&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3. 接收数据</span></span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>(); <span class="comment">//内部维护了一个byte[]</span></span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//错误的，可能会出现乱码。</span></span><br><span class="line"><span class="comment">//                String str = new String(buffer, 0, len);</span></span><br><span class="line"><span class="comment">//                System.out.print(str);</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//正确的</span></span><br><span class="line">                baos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(baos.toString());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;\n数据接收完毕&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4. 关闭Socket、ServerSocket、流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (socket != <span class="literal">null</span>) &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (serverSocket != <span class="literal">null</span>) &#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (is != <span class="literal">null</span>) &#123;</span><br><span class="line">                    is.close();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>聊天室案例（与多线程结合）</li>
</ul>
<h3 id="UDP网络编程"><a href="#UDP网络编程" class="headerlink" title="UDP网络编程"></a>UDP网络编程</h3><p>开发步骤：</p>
<ul>
<li>发送端程序：<ol>
<li>创建 DatagramSocket ：默认使用系统随机分配端口号。</li>
<li>创建 DatagramPacket：将要发送的数据用字节数组表示，并指定要发送的数据长度，接收方的 IP 地址和端口号。</li>
<li>调用 该 DatagramSocket 类对象的 send 方法 ：发送数据报 DatagramPacket 对象。</li>
<li>关闭 DatagramSocket 对象：发送端程序结束，关闭通信套接字。</li>
</ol>
</li>
<li>接收端程序：<ol>
<li>创建 DatagramSocket ：指定监听的端口号。</li>
<li>创建 DatagramPacket：指定接收数据用的字节数组，起到临时数据缓冲区的效果，并指定最大可以接收的数据长度。</li>
<li>调用 该 DatagramSocket 类对象的 receive 方法 ：接收数据报 DatagramPacket 对象。</li>
<li>关闭 DatagramSocket ：接收端程序结束，关闭通信套接字。</li>
</ol>
</li>
</ul>
<h3 id="URL编程"><a href="#URL编程" class="headerlink" title="URL编程"></a>URL编程</h3><ul>
<li><p>Java后台：将写好的Java程序部署在Tomcat服务器。启动Tomcat服务器。</p>
</li>
<li><p>前台：使用浏览器进行访问。需要使用url。（HTML+CSS+JavaScript）</p>
</li>
<li><p>URL的作用：定位互联网上某一资源的地址。</p>
</li>
<li><p>URL的格式：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.21.107:8080/examples/abcd.jpg?name=Tom   ---&gt; &quot;万事万物皆对象&quot;</span><br><span class="line">应用层协议 ip地址       端口号  资源地址   参数列表</span><br></pre></td></tr></table></figure>

<ul>
<li>使用URL实现数据的下载（了解）</li>
</ul>
<h2 id="企业真题（十六）"><a href="#企业真题（十六）" class="headerlink" title="企业真题（十六）"></a>企业真题（十六）</h2><h4 id="1-TCP协议和UDP协议的区别（华-为）"><a href="#1-TCP协议和UDP协议的区别（华-为）" class="headerlink" title="1. TCP协议和UDP协议的区别（华**为）"></a>1. TCP协议和UDP协议的区别（华**为）</h4><p>略</p>
<h4 id="2-简单说说TCP协议的三次握手与四次挥手机制-（-科软）"><a href="#2-简单说说TCP协议的三次握手与四次挥手机制-（-科软）" class="headerlink" title="2. 简单说说TCP协议的三次握手与四次挥手机制 （*科软）"></a>2. 简单说说TCP协议的三次握手与四次挥手机制 （*科软）</h4><p>略</p>
<h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><h3 id="反射的概述"><a href="#反射的概述" class="headerlink" title="反射的概述"></a>反射的概述</h3><p>通过使用反射前后的例子的对比，回答：</p>
<ol>
<li>面向对象中创建对象，调用指定结构（属性、方法）等功能，可以不使用反射，也可以使用反射。请问有什么区别？</li>
</ol>
<p>不使用反射，我们需要考虑封装性。比如：出了Person类之后，就不能调用Person类中私有的结构<br>使用反射，我们可以调用运行时类中任意的构造器、属性、方法。包括了私有的属性、方法、构造器。</p>
<ol start="2">
<li>以前创建对象并调用方法的方式，与现在通过反射创建对象并调用方法的方式对比的话，哪种用的多？<br>场景是什么？</li>
</ol>
<blockquote>
<p>从我们作为程序员开发者的角度来讲，我们开发中主要是完成业务代码，对于相关的对象、方法的调用都是确定的。<br>  所以，我们使用非反射的方式多一些。</p>
</blockquote>
<blockquote>
<p>因为反射体现了动态性（可以在运行时动态的获取对象所属的类，动态的调用相关的方法），所以我们在设计框架的时候，<br>  会大量的使用反射。意味着，如果大家需要学习框架源码，那么就需要学习反射。</p>
</blockquote>
<p>  框架 &#x3D; 注解 + 反射 + 设计模式</p>
<ol start="3">
<li>单例模式的饿汉式和懒汉式中，私有化类的构造器了！ 此时通过反射，可以创建单例模式中类的多个对象吗？</li>
</ol>
<p>是的！</p>
<ol start="4">
<li>通过反射，可以调用类中私有的结构，是否与面向对象的封装性有冲突？是不是Java语言设计存在Bug？</li>
</ol>
<p>不存在bug!</p>
<p>封装性：体现的是是否建议我们调用内部api的问题。比如，private声明的结构，意味着不建议调用。<br>反射：体现的是我们能否调用的问题。因为类的完整结构都加载到了内存中，所有我们就有能力进行调用。</p>
<ul>
<li>Java给我们提供了一套API，使用这套API我们可以在运行时动态的获取指定对象所属的类，创建运行时类的对象，调用指定的结构（属性、方法）等。</li>
<li>API：<ul>
<li><code>java.lang.Class</code>：代表一个类</li>
<li>java.lang.reflect.Method：代表类的方法</li>
<li>java.lang.reflect.Field：代表类的成员变量</li>
<li>java.lang.reflect.Constructor：代表类的构造器</li>
<li>… …</li>
</ul>
</li>
<li>反射的优点和缺点<ul>
<li><strong>优点：</strong><ul>
<li><p>提高了Java程序的灵活性和扩展性，<code>降低了耦合性</code>，提高<code>自适应</code>能力</p>
</li>
<li><p>允许程序创建和控制任何类的对象，无需提前<code>硬编码</code>目标类</p>
</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>反射的<code>性能较低</code>。<ul>
<li>反射机制主要应用在对灵活性和扩展性要求很高的系统框架上</li>
</ul>
</li>
<li>反射会<code>模糊</code>程序内部逻辑，<code>可读性较差</code>。</li>
</ul>
</li>
</ul>
</li>
<li>反射，平时开发中，我们使用并不多。主要是在框架的底层使用。</li>
</ul>
<h3 id="Class-反射的源头"><a href="#Class-反射的源头" class="headerlink" title="Class:反射的源头"></a>Class:反射的源头</h3><ul>
<li><p>Class的理解 （掌握）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">针对于编写好的.java源文件进行编译(使用javac.exe)，会生成一个或多个.class字节码文件。接着，我们使用</span><br><span class="line">java.exe命令对指定的.class文件进行解释运行。这个解释运行的过程中，我们需要将.class字节码文件加载(使用类的加载器)到内存中(存放在方法区)。加载到内存中的.class文件对应的结构即为Class的一个实例。</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取Class的实例的几种方式（前三种）</p>
<ul>
<li>类.class</li>
<li>对象.getClass()</li>
<li>（使用较多）Class调用静态方法forName(String className)</li>
<li>(了解)使用ClassLoader的方法loadClass(String className)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">//1.调用运行时类的静态属性：class</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz1</span> <span class="operator">=</span> User.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 调用运行时类的对象的getClass()</span></span><br><span class="line"><span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz2</span> <span class="operator">=</span> u1.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 调用Class的静态方法forName(String className)</span></span><br><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;com.atguigu02._class.User&quot;</span>; <span class="comment">//全类名</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz3</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line"></span><br><span class="line">System.out.println(clazz1 == clazz2);<span class="comment">//true</span></span><br><span class="line">System.out.println(clazz1 == clazz3);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 使用类的加载器的方式 (了解)</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz4</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;com.atguigu02._class.User&quot;</span>);</span><br><span class="line">System.out.println(clazz1 == clazz4);<span class="comment">//true</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure>
</li>
<li><p>Class 可以指向哪些结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">简言之，所有Java类型！</span><br><span class="line">（1）class：外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类</span><br><span class="line">（2）interface：接口</span><br><span class="line">（3）[]：数组</span><br><span class="line">（4）enum：枚举</span><br><span class="line">（5）annotation：注解@interface</span><br><span class="line">（6）primitive type：基本数据类型</span><br><span class="line">（7）void</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="类的加载过程、类的加载器（理解）"><a href="#类的加载过程、类的加载器（理解）" class="headerlink" title="类的加载过程、类的加载器（理解）"></a>类的加载过程、类的加载器（理解）</h3><ul>
<li><p>类的加载过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">过程1：类的装载(loading)</span><br><span class="line">将类的class文件读入内存，并为之创建一个java.lang.Class对象。此过程由类加载器完成</span><br><span class="line"></span><br><span class="line">过程2：链接(linking)</span><br><span class="line">&gt; 验证(Verify):确保加载的类信息符合JVM规范，例如：以cafebabe开头，没有安全方面的问题。</span><br><span class="line">&gt; 准备(Prepare):正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。</span><br><span class="line">&gt; 解析(Resolve):虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。</span><br><span class="line"></span><br><span class="line">过程3：初始化(initialization)</span><br><span class="line">执行类构造器&lt;clinit&gt;()方法的过程。</span><br><span class="line">类构造器&lt;clinit&gt;()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。</span><br></pre></td></tr></table></figure>
</li>
<li><p>类的加载器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">作用：负责类的加载，并对应于一个Class的实例。</span><br><span class="line"></span><br><span class="line">分类（分为两种）：</span><br><span class="line">&gt; BootstrapClassLoader:引导类加载器、启动类加载器</span><br><span class="line">     &gt; 使用C/C++语言编写的，不能通过Java代码获取其实例</span><br><span class="line">     &gt; 负责加载Java的核心库（JAVA_HOME/jre/lib/rt.jar或sun.boot.class.path路径下的内容）</span><br><span class="line"></span><br><span class="line">&gt; 继承于ClassLoader的类加载器</span><br><span class="line">    &gt; ExtensionClassLoader:扩展类加载器</span><br><span class="line">            &gt; 负责加载从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录下加载类库</span><br><span class="line">    &gt; SystemClassLoader/ApplicationClassLoader:系统类加载器、应用程序类加载器</span><br><span class="line">            &gt; 我们自定义的类，默认使用的类的加载器。</span><br><span class="line">    &gt; 用户自定义类的加载器</span><br><span class="line">            &gt; 实现应用的隔离（同一个类在一个应用程序中可以加载多份）；数据的加密。</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用类的加载器获取流，并读取配置文件信息:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 需求：通过ClassLoader加载指定的配置文件</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="comment">//其他方式读取的文件的默认路径为：当前的module</span></span><br><span class="line">    <span class="comment">//通过类的加载器读取的文件的默认的路径为：当前module下的src下</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().getResourceAsStream(<span class="string">&quot;info1.properties&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pros.load(is);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    System.out.println(name + <span class="string">&quot;:&quot;</span> +pwd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="反射的应用1：创建运行时类的对象（重点）"><a href="#反射的应用1：创建运行时类的对象（重点）" class="headerlink" title="反射的应用1：创建运行时类的对象（重点）"></a>反射的应用1：创建运行时类的对象（重点）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Person.class;</span><br><span class="line"></span><br><span class="line">//创建Person类的实例</span><br><span class="line">Person per = (Person) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">System.out.println(per);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">要想创建对象成功，需要满足：</span><br><span class="line">条件1：要求运行时类中必须提供一个空参的构造器</span><br><span class="line">条件2：要求提供的空参的构造器的权限要足够。</span><br></pre></td></tr></table></figure>

<h3 id="反射的应用2：获取运行时类所有的结构"><a href="#反射的应用2：获取运行时类所有的结构" class="headerlink" title="反射的应用2：获取运行时类所有的结构"></a>反射的应用2：获取运行时类所有的结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">（了解）获取运行时类的内部结构1：所有属性、所有方法、所有构造器</span><br><span class="line">  · getFields():获取到运行时类本身及其所有的父类中声明为public权限的属性</span><br><span class="line">  · getDeclaredFields():获取当前运行时类中声明的所有属性</span><br><span class="line">  · getMethods():获取到运行时类本身及其所有的父类中声明为public权限的方法</span><br><span class="line">  · getDeclaredMethods():获取当前运行时类中声明的所有方法</span><br><span class="line">（熟悉）获取运行时类的内部结构2：父类、接口们、包、带泛型的父类、父类的泛型等</span><br><span class="line">  1. 获取运行时类的父类 getSuperclass()</span><br><span class="line">  2. 获取运行时类实现的接口 getInterfaces()</span><br><span class="line">  3. 获取运行时类所在的包 getPackage()</span><br><span class="line">  4. 获取运行时类的带泛型的父类 getGenericSuperclass()</span><br><span class="line">  5. 获取运行时类的父类的泛型 </span><br><span class="line">    @Test</span><br><span class="line">      public void test5() throws ClassNotFoundException &#123;</span><br><span class="line">          Class clazz = Class.forName(&quot;com.atguigu03.reflectapply.data.Person&quot;);</span><br><span class="line">          //获取带泛型的父类（Type是一个接口，Class实现了此接口</span><br><span class="line">          Type superclass = clazz.getGenericSuperclass();</span><br><span class="line">          //如果父类是带泛型的，则可以强转为ParameterizedType</span><br><span class="line">          ParameterizedType paramType = (ParameterizedType) superclass;</span><br><span class="line">          //调用getActualTypeArguments()获取泛型的参数，结果是一个数组，因为可能有多个泛型参数。</span><br><span class="line">          Type[] arguments = paramType.getActualTypeArguments();</span><br><span class="line">          //获取泛型参数的名称</span><br><span class="line">          System.out.println(((Class)arguments[0]).getName());</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h3 id="反射的应用3：调用指定的结构（重点）"><a href="#反射的应用3：调用指定的结构（重点）" class="headerlink" title="反射的应用3：调用指定的结构（重点）"></a>反射的应用3：调用指定的结构（重点）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 调用指定的属性（步骤）</span><br><span class="line">步骤1.通过Class实例调用getDeclaredField(String fieldName)，获取运行时类指定名的属性</span><br><span class="line">步骤2. setAccessible(true)：确保此属性是可以访问的</span><br><span class="line">步骤3. 通过Filed类的实例调用get(Object obj) （获取的操作）</span><br><span class="line">                  或 set(Object obj,Object value) （设置的操作）进行操作。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> (Person) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.通过Class实例调用getDeclaredField(String fieldName)，获取运行时类指定名的属性</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. setAccessible(true)：确保此属性是可以访问的</span></span><br><span class="line">    nameField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 通过Filed类的实例调用get(Object obj) （获取的操作）</span></span><br><span class="line">    <span class="comment">// 或 set(Object obj,Object value) （设置的操作）进行操作。</span></span><br><span class="line">    nameField.set(per,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    System.out.println(nameField.get(per));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2 调用指定的方法（步骤）</span><br><span class="line">步骤1.通过Class的实例调用getDeclaredMethod(String methodName,Class ... args),获取指定的方法</span><br><span class="line">步骤2. setAccessible(true)：确保此方法是可访问的</span><br><span class="line">步骤3.通过Method实例调用invoke(Object obj,Object ... objs),即为对Method对应的方法的调用。</span><br><span class="line">     invoke()的返回值即为Method对应的方法的返回值</span><br><span class="line">     特别的：如果Method对应的方法的返回值类型为void，则invoke()返回值为null</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> (Person) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.通过Class的实例调用getDeclaredMethod(String methodName,Class ... args),获取指定的方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">showNationMethod</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;showNation&quot;</span>,String.class,<span class="type">int</span>.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. setAccessible(true)：确保此方法是可访问的</span></span><br><span class="line">    showNationMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.通过Method实例调用invoke(Object obj,Object ... objs),即为对Method对应的方法的调用。</span></span><br><span class="line">    <span class="comment">//invoke()的返回值即为Method对应的方法的返回值</span></span><br><span class="line">    <span class="comment">//特别的：如果Method对应的方法的返回值类型为void，则invoke()返回值为null</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> showNationMethod.invoke(per,<span class="string">&quot;CHN&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    System.out.println(returnValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 调用指定的构造器（步骤）</span><br><span class="line">步骤1.通过Class的实例调用getDeclaredConstructor(Class ... args)，获取指定参数类型的构造器</span><br><span class="line">步骤2.setAccessible(true)：确保此构造器是可以访问的</span><br><span class="line">步骤3.通过Constructor实例调用newInstance(Object ... objs),返回一个运行时类的实例。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.通过Class的实例调用getDeclaredConstructor(Class ... args)，获取指定参数类型的构造器</span></span><br><span class="line">    <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.setAccessible(true)：确保此构造器是可以访问的</span></span><br><span class="line">    constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.通过Constructor实例调用newInstance(Object ... objs),返回一个运行时类的实例。</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> (Person) constructor.newInstance(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(per);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反射的应用4：注解的使用（了解）"><a href="#反射的应用4：注解的使用（了解）" class="headerlink" title="反射的应用4：注解的使用（了解）"></a>反射的应用4：注解的使用（了解）</h3><p>在框架中用的比较多。</p>
<h3 id="体会：反射的动态性"><a href="#体会：反射的动态性" class="headerlink" title="体会：反射的动态性"></a>体会：反射的动态性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//体会：静态性</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//体会：反射的动态性</span></span><br><span class="line">    <span class="comment">//举例1：</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getInstance</span><span class="params">(String className)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line"></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">        con.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (T) con.newInstance();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> getInstance();</span><br><span class="line">        System.out.println(p1);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;com.atguigu04.other.dynamic.Person&quot;</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">per1</span> <span class="operator">=</span> getInstance(className);</span><br><span class="line">        System.out.println(per1);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">className1</span> <span class="operator">=</span> <span class="string">&quot;java.util.Date&quot;</span>;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> getInstance(className1);</span><br><span class="line">        System.out.println(date1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//体会：反射的动态性</span></span><br><span class="line">    <span class="comment">//举例2：</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(String className,String methodName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1. 创建全类名对应的运行时类的对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line"></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">        con.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> con.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 获取运行时类中指定的方法，并调用</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(methodName);</span><br><span class="line">        method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;com.atguigu04.other.dynamic.Person&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> <span class="string">&quot;show&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> invoke(className,methodName);</span><br><span class="line">        System.out.println(returnValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="企业真题（十七）"><a href="#企业真题（十七）" class="headerlink" title="企业真题（十七）"></a>企业真题（十七）</h2><h3 id="反射概述"><a href="#反射概述" class="headerlink" title="反射概述"></a>反射概述</h3><h4 id="1-对反射了解吗？反射有什么好处？为什么需要反射？（微-银行）"><a href="#1-对反射了解吗？反射有什么好处？为什么需要反射？（微-银行）" class="headerlink" title="1. 对反射了解吗？反射有什么好处？为什么需要反射？（微*银行）"></a>1. 对反射了解吗？反射有什么好处？为什么需要反射？（微*银行）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; Java反射的作用是什么？(三*重工、上海*和网络)</span><br><span class="line">&gt; Java反射机制的作用有什么？(上海明*物联网)</span><br><span class="line">&gt; 反射的具体用途？（阿***芝*信用项目组）</span><br></pre></td></tr></table></figure>

<p>略</p>
<h4 id="2-反射的使用场合和作用、及其优缺点（-软国际）"><a href="#2-反射的使用场合和作用、及其优缺点（-软国际）" class="headerlink" title="2. 反射的使用场合和作用、及其优缺点（*软国际）"></a>2. 反射的使用场合和作用、及其优缺点（*软国际）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; 反射机制的优缺点(君*科技)</span><br><span class="line">&gt; Java反射你怎么用的？（吉*航空）</span><br></pre></td></tr></table></figure>

<p>略</p>
<h4 id="3-实现Java反射的类有什么？-君-科技"><a href="#3-实现Java反射的类有什么？-君-科技" class="headerlink" title="3. 实现Java反射的类有什么？(君*科技)"></a>3. 实现Java反射的类有什么？(君*科技)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; Java反射 API 有几类？(北京*蓝)</span><br></pre></td></tr></table></figure>

<p>问API。</p>
<h4 id="4-反射是怎么实现的？（上海立-网络）"><a href="#4-反射是怎么实现的？（上海立-网络）" class="headerlink" title="4. 反射是怎么实现的？（上海立*网络）"></a>4. 反射是怎么实现的？（上海立*网络）</h4><p>从Class说起。</p>
<h3 id="Class的理解"><a href="#Class的理解" class="headerlink" title="Class的理解"></a>Class的理解</h3><h4 id="1-Class类的作用？生成Class对象的方法有哪些？-顺"><a href="#1-Class类的作用？生成Class对象的方法有哪些？-顺" class="headerlink" title="1. Class类的作用？生成Class对象的方法有哪些？(顺*)"></a>1. Class类的作用？生成Class对象的方法有哪些？(顺*)</h4><p>反射的源头。 主要有三种。</p>
<h4 id="2-Class-forName-“全路径”-会调用哪些方法-？-会调用构造方法吗？加载的类会放在哪？（上-银行外包）"><a href="#2-Class-forName-“全路径”-会调用哪些方法-？-会调用构造方法吗？加载的类会放在哪？（上-银行外包）" class="headerlink" title="2. Class.forName(“全路径”) 会调用哪些方法 ？ 会调用构造方法吗？加载的类会放在哪？（上*银行外包）"></a>2. Class.forName(“全路径”) 会调用哪些方法 ？ 会调用构造方法吗？加载的类会放在哪？（上*银行外包）</h4><p>Class.forName() 会执行执行类构造器<clinit>()方法。</p>
<p>不会调用构造方法</p>
<p>加载的类放在方法区。</p>
<h3 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h3><h4 id="1-类加载流程（汇-通、同-顺、凡-科技）"><a href="#1-类加载流程（汇-通、同-顺、凡-科技）" class="headerlink" title="1. 类加载流程（汇**通、同*顺、凡*科技）"></a>1. 类加载流程（汇**通、同*顺、凡*科技）</h4><p>略</p>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><h4 id="1-说一下创建对象的几种方法？（华油-集团、-科软、凡-科技）"><a href="#1-说一下创建对象的几种方法？（华油-集团、-科软、凡-科技）" class="headerlink" title="1. 说一下创建对象的几种方法？（华油***集团、*科软、凡*科技）"></a>1. 说一下创建对象的几种方法？（华油***集团、*科软、凡*科技）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; 除了使用new创建对象之外，还可以用什么方法创建对象？(*云网络)</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20221214145240412.png" alt="image-20221214145240412"></p>
<h4 id="2-如何找到对象实际类的？（-度）"><a href="#2-如何找到对象实际类的？（-度）" class="headerlink" title="2. 如何找到对象实际类的？（*度）"></a>2. 如何找到对象实际类的？（*度）</h4><p>对象.getClass();</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Date();</span><br><span class="line"></span><br><span class="line">obj.getClass();// 获取到的是Date。</span><br></pre></td></tr></table></figure>



<h4 id="3-Java反射创建对象效率高还是通过new创建对象的效率高？-三-重工"><a href="#3-Java反射创建对象效率高还是通过new创建对象的效率高？-三-重工" class="headerlink" title="3. Java反射创建对象效率高还是通过new创建对象的效率高？(三*重工)"></a>3. Java反射创建对象效率高还是通过new创建对象的效率高？(三*重工)</h4><p>new 的方式。</p>
<h3 id="调用属性、方法"><a href="#调用属性、方法" class="headerlink" title="调用属性、方法"></a>调用属性、方法</h3><h4 id="1-如何利用反射机制来访问一个类的方法？（神州-软件）"><a href="#1-如何利用反射机制来访问一个类的方法？（神州-软件）" class="headerlink" title="1. 如何利用反射机制来访问一个类的方法？（神州**软件）"></a>1. 如何利用反射机制来访问一个类的方法？（神州**软件）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">调用指定的方法（步骤）</span><br><span class="line">步骤1.通过Class的实例调用getDeclaredMethod(String methodName,Class ... args),获取指定的方法</span><br><span class="line">步骤2. setAccessible(true)：确保此方法是可访问的</span><br><span class="line">步骤3.通过Method实例调用invoke(Object obj,Object ... objs),即为对Method对应的方法的调用。</span><br><span class="line">     invoke()的返回值即为Method对应的方法的返回值</span><br><span class="line">     特别的：如果Method对应的方法的返回值类型为void，则invoke()返回值为null</span><br></pre></td></tr></table></figure>



<h4 id="2-说一下Java反射获取私有属性，如何改变值？（阿-麻信用项目组）"><a href="#2-说一下Java反射获取私有属性，如何改变值？（阿-麻信用项目组）" class="headerlink" title="2. 说一下Java反射获取私有属性，如何改变值？（阿****麻信用项目组）"></a>2. 说一下Java反射获取私有属性，如何改变值？（阿****麻信用项目组）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">调用指定的属性（步骤）</span><br><span class="line">步骤1.通过Class实例调用getDeclaredField(String fieldName)，获取运行时类指定名的属性</span><br><span class="line">步骤2. setAccessible(true)：确保此属性是可以访问的</span><br><span class="line">步骤3. 通过Filed类的实例调用get(Object obj) （获取的操作）</span><br><span class="line">                       或 set(Object obj,Object value) （设置的操作）进行操作。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">针对于核心源码的api，内部的私有的结构在jdk17中就不可以通过反射调用了。</span><br></pre></td></tr></table></figure>

<h2 id="JDK8-17新特性"><a href="#JDK8-17新特性" class="headerlink" title="JDK8-17新特性"></a>JDK8-17新特性</h2><h3 id="Java版本迭代概述"><a href="#Java版本迭代概述" class="headerlink" title="Java版本迭代概述"></a>Java版本迭代概述</h3><table>
<thead>
<tr>
<th align="center">发行版本</th>
<th align="center">发行时间</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Java 1.0</td>
<td align="center">1996.01.23</td>
<td align="center">Sun公司发布了Java的第一个开发工具包</td>
</tr>
<tr>
<td align="center">Java 5.0</td>
<td align="center">2004.09.30</td>
<td align="center">①版本号从1.4直接更新至5.0；②平台更名为JavaSE、JavaEE、JavaME</td>
</tr>
<tr>
<td align="center">Java 8.0</td>
<td align="center">2014.03.18</td>
<td align="center">此版本是继Java 5.0以来变化最大的版本。是长期支持版本（<code>LTS</code>）</td>
</tr>
<tr>
<td align="center">Java 9.0</td>
<td align="center">2017.09.22</td>
<td align="center"><strong>此版本开始，每半年更新一次</strong></td>
</tr>
<tr>
<td align="center">Java 10.0</td>
<td align="center">2018.03.21</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Java 11.0</td>
<td align="center">2018.09.25</td>
<td align="center">JDK安装包取消独立JRE安装包，是长期支持版本（<code>LTS</code>）</td>
</tr>
<tr>
<td align="center">Java 12.0</td>
<td align="center">2019.03.19</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Java17.0</td>
<td align="center">2021.09</td>
<td align="center">发布Java 17.0，版本号也称为21.9，是长期支持版本（<code>LTS</code>）</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Java19.0</td>
<td align="center">2022.09</td>
<td align="center">发布Java19.0，版本号也称为22.9。</td>
</tr>
</tbody></table>
<p>从Java 9 这个版本开始，Java 的计划发布周期是 <code>6个月</code>。</p>
<p>这意味着Java的更新从传统的以<code>特性驱动</code>的发布周期，转变为以<code>时间驱动</code>的发布模式，并且承诺不会跳票。通过这样的方式，开发团队可以把一些关键特性尽早合并到 JDK 之中，以快速得到开发者反馈，在一定程度上避免出现像 Java 9 两次被迫延迟发布的窘况。</p>
<p>针对企业客户的需求，Oracle 将以<code>三年</code>为周期发布长期支持版本（long term support）。</p>
<p>Oracle 的官方观点认为：<strong>与 Java 7-&gt;8-&gt;9 相比，Java 9-&gt;10-&gt;11的升级和 8-&gt;8u20-&gt;8u40 更相似。</strong></p>
<p>新模式下的 Java 版本发布都会包含许多变更，包括<code>语言变更</code>和 <code>JVM 变更</code>，这两者都会对 IDE、字节码库和框架产生重大影响。此外，不仅会新增其他 API，还会有 <code>API被删除</code>（这在 Java 8 之前没有发生过）。</p>
<h3 id="各版本介绍"><a href="#各版本介绍" class="headerlink" title="各版本介绍"></a>各版本介绍</h3><h4 id="jdk-9"><a href="#jdk-9" class="headerlink" title="jdk 9"></a>jdk 9</h4><p>Java 9 提供了<code>超过150项</code>新功能特性，包括备受期待的模块化系统、可交互的 REPL 工具：jshell，JDK 编译工具，Java 公共 API 和私有代码，以及安全增强、扩展提升、性能管理改善等。</p>
<p>特性太多，查看链接：</p>
<p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk9/">https://openjdk.java.net/projects/jdk9/</a></p>
<h4 id="jdk-10"><a href="#jdk-10" class="headerlink" title="jdk 10"></a>jdk 10</h4><p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk/10/">https://openjdk.java.net/projects/jdk/10/</a></p>
<blockquote>
<p>286: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/286">Local-Variable Type Inference</a> 局部变量类型推断<br> 296: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/296">Consolidate the JDK Forest into a Single Repository</a> JDK库的合并<br> 304: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/304">Garbage-Collector Interface</a> 统一的垃圾回收接口<br> 307: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/307">Parallel Full GC for G1</a> 为G1提供并行的Full GC<br> 310: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/310">Application Class-Data Sharing</a> 应用程序类数据（AppCDS）共享<br> 312: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/312">Thread-Local Handshakes</a> ThreadLocal握手交互<br> 313: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/313">Remove the Native-Header Generation Tool (javah)</a> 移除JDK中附带的javah工具<br> 314: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/314">Additional Unicode Language-Tag Extensions</a> 使用附加的Unicode语言标记扩展<br> 316: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/316">Heap Allocation on Alternative Memory Devices</a> 能将堆内存占用分配给用户指定的备用内存设备<br> 317: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/317">Experimental Java-Based JIT Compiler</a> 使用Graal基于Java的编译器</p>
<p>319: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/319">Root Certificates</a> 根证书<br> 322: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/322">Time-Based Release Versioning</a> 基于时间定于的发布版本</p>
</blockquote>
<h4 id="jdk-11"><a href="#jdk-11" class="headerlink" title="jdk 11"></a>jdk 11</h4><p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk/11/">https://openjdk.java.net/projects/jdk/11/</a></p>
<blockquote>
<p>181: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/181">Nest-Based Access Control</a>  基于嵌套的访问控制<br>309: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/309">Dynamic Class-File Constants</a> 动态类文件常量<br>315: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/315">Improve Aarch64 Intrinsics</a> 改进 Aarch64 Intrinsics<br>318: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/318">Epsilon: A No-Op Garbage Collector</a> Epsilon — 一个No-Op（无操作）的垃圾收集器<br>320: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/320">Remove the Java EE and CORBA Modules</a> 删除 Java EE 和 CORBA 模块<br>321: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/321">HTTP Client (Standard)</a>  HTTPClient API<br>323: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/323">Local-Variable Syntax for Lambda Parameters</a>  用于 Lambda 参数的局部变量语法<br>324: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/324">Key Agreement with Curve25519 and Curve448</a> Curve25519 和 Curve448 算法的密钥协议<br>327: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/327">Unicode 10</a><br>328: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/328">Flight Recorder</a> 飞行记录仪<br>329: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/329">ChaCha20 and Poly1305 Cryptographic Algorithms</a> ChaCha20 和 Poly1305 加密算法<br>330: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/330">Launch Single-File Source-Code Programs</a> 启动单一文件的源代码程序<br>331: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/331">Low-Overhead Heap Profiling</a> 低开销的 Heap Profiling<br>332: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/332">Transport Layer Security (TLS) 1.3</a> 支持 TLS 1.3<br>333: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/333">ZGC: A Scalable Low-Latency Garbage Collector<br>   (Experimental)</a> 可伸缩低延迟垃圾收集器<br>335: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/335">Deprecate the Nashorn JavaScript Engine</a> 弃用 Nashorn JavaScript 引擎<br>336: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/336">Deprecate the Pack200 Tools and API</a>  弃用 Pack200 工具和 API</p>
</blockquote>
<h4 id="jdk-12"><a href="#jdk-12" class="headerlink" title="jdk 12"></a>jdk 12</h4><p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk/12/">https://openjdk.java.net/projects/jdk/12/</a></p>
<blockquote>
<p>189：<a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/189">Shenandoah: A Low-Pause-Time Garbage Collector (Experimental)</a> 低暂停时间的GC<br>230: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/230">Microbenchmark Suite</a> 微基准测试套件<br>325: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/325">Switch Expressions (Preview)</a> switch表达式<br>334: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/334">JVM Constants API </a> JVM常量API<br>340: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/340">One AArch64 Port, Not Two</a> 只保留一个AArch64实现<br>341: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/341">Default CDS Archives</a> 默认类数据共享归档文件<br>344: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/344">Abortable Mixed Collections for G1</a> 可中止的G1 Mixed GC<br>346: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/346">Promptly Return Unused Committed Memory from G1</a> G1及时返回未使用的已分配内存</p>
</blockquote>
<h4 id="jdk-13"><a href="#jdk-13" class="headerlink" title="jdk 13"></a>jdk 13</h4><p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk/13/">https://openjdk.java.net/projects/jdk/13/</a></p>
<blockquote>
<p>350: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/350">Dynamic CDS Archives</a> 动态CDS档案<br>351: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/351">ZGC: Uncommit Unused Memory</a> ZGC:取消使用未使用的内存<br>353: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/353">Reimplement the Legacy Socket API</a> 重新实现旧版套接字API<br>354: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/354">Switch Expressions (Preview)</a> switch表达式（预览）<br>355: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/355">Text Blocks (Preview)</a> 文本块（预览）</p>
</blockquote>
<h4 id="jdk-14"><a href="#jdk-14" class="headerlink" title="jdk 14"></a>jdk 14</h4><p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk/14/">https://openjdk.java.net/projects/jdk/14/</a></p>
<blockquote>
<p>305: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/305">Pattern Matching for instanceof (Preview)</a> instanceof的模式匹配<br>343: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/343">Packaging Tool (Incubator)</a> 打包工具<br>345: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/345">NUMA-Aware Memory Allocation for G1</a> G1的NUMA-Aware内存分配<br>349: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/349">JFR Event Streaming</a> JFR事件流<br>352: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/352">Non-Volatile Mapped Byte Buffers</a> 非易失性映射字节缓冲区<br>358: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/358">Helpful NullPointerExceptions</a> 实用的NullPointerExceptions<br>359: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/359">Records (Preview)</a><br>361: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/361">Switch Expressions (Standard)</a> Switch表达式<br>362: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/362">Deprecate the Solaris and SPARC Ports</a> 弃用Solaris和SPARC端口<br>363: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/363">Remove the Concurrent Mark Sweep (CMS) Garbage Collector</a> 删除并发标记扫描（CMS）垃圾回收器<br>364: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/364">ZGC on macOS</a><br>365: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/365">ZGC on Windows</a><br>366: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/366">Deprecate the ParallelScavenge + SerialOld GC Combination</a> 弃用ParallelScavenge + SerialOld GC组合<br>367: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/367">Remove the Pack200 Tools and API</a> 删除Pack200工具和API<br>368: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/368">Text Blocks (Second Preview)</a> 文本块<br>370: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/370">Foreign-Memory Access API (Incubator)</a> 外部存储器访问API</p>
</blockquote>
<h4 id="jdk-15"><a href="#jdk-15" class="headerlink" title="jdk 15"></a>jdk 15</h4><p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk/15/">https://openjdk.java.net/projects/jdk/15/</a></p>
<blockquote>
<p>339: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/339">Edwards-Curve Digital Signature Algorithm (EdDSA)</a> EdDSA 数字签名算法<br>360: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/360">Sealed Classes (Preview)</a> 密封类（预览）<br>371: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/371">Hidden Classes</a> 隐藏类<br>372: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/372">Remove the Nashorn JavaScript Engine</a> 移除 Nashorn JavaScript 引擎<br>373: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/373">Reimplement the Legacy DatagramSocket API</a> 重新实现 Legacy DatagramSocket API<br>374: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/374">Disable and Deprecate Biased Locking</a> 禁用偏向锁定<br>375: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/375">Pattern Matching for instanceof (Second Preview)</a> instanceof 模式匹配（第二次预览）<br>377: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/377">ZGC: A Scalable Low-Latency Garbage Collector</a> ZGC：一个可扩展的低延迟垃圾收集器<br>378: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/378">Text Blocks</a> 文本块<br>379: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/379">Shenandoah: A Low-Pause-Time Garbage Collector</a> Shenandoah:低暂停时间垃圾收集器<br>381: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/381">Remove the Solaris and SPARC Ports</a> 移除 Solaris 和 SPARC 端口<br>383: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/383">Foreign-Memory Access API (Second Incubator)</a> 外部存储器访问 API（第二次孵化版）<br>384: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/384">Records (Second Preview)</a> Records（第二次预览）<br>385: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/385">Deprecate RMI Activation for Removal</a> 废弃 RMI 激活机制</p>
</blockquote>
<h4 id="jdk-16"><a href="#jdk-16" class="headerlink" title="jdk 16"></a>jdk 16</h4><p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk/16/">https://openjdk.java.net/projects/jdk/16/</a></p>
<blockquote>
<p>338: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/338">Vector API (Incubator)</a> Vector API（孵化器）<br>347: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/347">Enable C++14 Language Features</a> JDK C++的源码中允许使用C++14的语言特性<br>357: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/357">Migrate from Mercurial to Git</a> OpenJDK源码的版本控制从Mercurial (hg) 迁移到git<br>369: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/369">Migrate to GitHub</a> OpenJDK源码的版本控制迁移到github上<br>376: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/376">ZGC: Concurrent Thread-Stack Processing</a> ZGC：并发线程处理<br>380: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/380">Unix-Domain Socket Channels</a> Unix域套接字通道<br>386: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/386">Alpine Linux Port</a> 将glibc的jdk移植到使用musl的alpine linux上<br>387: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/387">Elastic Metaspace</a> 弹性元空间<br>388: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/388">Windows&#x2F;AArch64 Port</a> 移植JDK到Windows&#x2F;AArch64<br>389: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/389">Foreign Linker API (Incubator)</a> 提供jdk.incubator.foreign来简化native code的调用<br>390: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/390">Warnings for Value-Based Classes</a> 提供基于值的类的警告<br>392: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/392">Packaging Tool</a> jpackage打包工具转正<br>393: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/393">Foreign-Memory Access API (Third Incubator)</a><br>394: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/394">Pattern Matching for instanceof</a> Instanceof的模式匹配转正<br>395: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/395">Records</a> Records转正<br>396: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/396">Strongly Encapsulate JDK Internals by Default</a> 默认情况下，封装了JDK内部构件<br>397: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/397">Sealed Classes (Second Preview)</a> 密封类</p>
</blockquote>
<h4 id="jdk-17"><a href="#jdk-17" class="headerlink" title="jdk 17"></a>jdk 17</h4><p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk/17/">https://openjdk.java.net/projects/jdk/17/</a></p>
<blockquote>
<p>306: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/306">Restore Always-Strict Floating-Point Semantics</a> 恢复始终严格的浮点语义</p>
<p>356: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/356">Enhanced Pseudo-Random Number Generators</a> 增强型伪随机数生成器</p>
<p>382: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/382">New macOS Rendering Pipeline</a> 新的macOS渲染管道</p>
<p>391: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/391">macOS&#x2F;AArch64 Port</a> macOS&#x2F;AArch64端口</p>
<p>398: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/398">Deprecate the Applet API for Removal</a> 弃用Applet API后续将进行删除</p>
<p>403: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/403">Strongly Encapsulate JDK Internals</a> 强封装JDK的内部API</p>
<p>406: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/406">Pattern Matching for switch (Preview)</a> switch模式匹配（预览）</p>
<p>407: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/407">Remove RMI Activation</a> 删除RMI激活机制</p>
<p>409: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/409">Sealed Classes</a> 密封类转正</p>
<p>410: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/410">Remove the Experimental AOT and JIT Compiler</a> 删除实验性的AOT和JIT编译器</p>
<p>411: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/411">Deprecate the Security Manager for Removal</a> 弃用即将删除的安全管理器</p>
<p>412: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/412">Foreign Function &amp; Memory API (Incubator)</a> 外部函数和内存API（孵化特性）</p>
<p>414: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/414">Vector API (Second Incubator)</a> Vector API（第二次孵化特性）</p>
<p>415: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/415">Context-Specific Deserialization Filters</a> 上下文特定的反序列化过滤器</p>
</blockquote>
<h3 id="Java8新特性：Lambda表达式"><a href="#Java8新特性：Lambda表达式" class="headerlink" title="Java8新特性：Lambda表达式"></a>Java8新特性：Lambda表达式</h3><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p><strong>冗余的匿名内部类</strong>：<br>当需要启动一个线程去完成任务时，通常会通过<code>java.lang.Runnable</code>接口来定义任务内容，并使用<code>java.lang.Thread</code>类来启动该线程。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.fp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseFunctionalProgramming</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start(); <span class="comment">// 启动线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个<code>Runnable</code>接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。</p>
<p><strong>代码分析：</strong></p>
<p>对于<code>Runnable</code>的匿名内部类用法，可以分析出几点内容：</p>
<ul>
<li><code>Thread</code>类需要<code>Runnable</code>接口作为参数，其中的抽象<code>run</code>方法是用来指定线程任务内容的核心；</li>
<li>为了指定<code>run</code>的方法体，<strong>不得不</strong>需要<code>Runnable</code>接口的实现类；</li>
<li>为了省去定义一个<code>RunnableImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li>
<li>必须覆盖重写抽象<code>run</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li>
<li>而实际上，<strong>似乎只有方法体才是关键所在</strong>。</li>
</ul>
<h4 id="Lambda-及其语法"><a href="#Lambda-及其语法" class="headerlink" title="Lambda 及其语法"></a>Lambda 及其语法</h4><p>Lambda 是一个<strong>匿名函数</strong>，我们可以把 Lambda 表达式理解为是<strong>一段可以传递的代码</strong>（将代码像数据一样进行传递）。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升  </p>
<p>Lambda 表达式：在Java 8 语言中引入的一种新的语法元素和操作符。这个操作符为 “<code>-&gt;</code>” ， 该操作符被称为 <code>Lambda 操作符</code>或<code>箭头操作符</code>。它将 Lambda 分为两个部分：</p>
<ul>
<li>左侧：指定了 Lambda 表达式需要的参数列表</li>
<li>右侧：指定了 Lambda 体，是抽象方法的实现逻辑，也即 Lambda 表达式要执行的功能。</li>
</ul>
<p><strong>语法格式一：</strong>无参，无返回值  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//未使用Lambda表达式</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我爱北京天安门&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    r1.run();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;***********************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用Lambda表达式</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">r2</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我爱北京故宫&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    r2.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>语法格式二：</strong>Lambda 需要一个参数，但是没有返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//未使用Lambda表达式</span></span><br><span class="line">    Consumer&lt;String&gt; con = <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    con.accept(<span class="string">&quot;谎言和誓言的区别是什么？&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用Lambda表达式</span></span><br><span class="line">    Consumer&lt;String&gt; con1 = (String s) -&gt; &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;;</span><br><span class="line">    con1.accept(<span class="string">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>语法格式三：</strong>数据类型可以省略，因为可由编译器推断得出，称为“类型推断”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//语法格式三使用前</span></span><br><span class="line">    Consumer&lt;String&gt; con1 = (String s) -&gt; &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;;</span><br><span class="line">    con1.accept(<span class="string">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line">    <span class="comment">//语法格式三使用后</span></span><br><span class="line">    Consumer&lt;String&gt; con2 = (s) -&gt; &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;;</span><br><span class="line">    con2.accept(<span class="string">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>语法格式四：</strong>Lambda 若只需要一个参数时，参数的小括号可以省略</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//语法格式四使用前</span></span><br><span class="line">    Consumer&lt;String&gt; con1 = (s) -&gt; &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;;</span><br><span class="line">    con1.accept(<span class="string">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line">    <span class="comment">//语法格式四使用后</span></span><br><span class="line">    Consumer&lt;String&gt; con2 = s -&gt; &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;;</span><br><span class="line">    con2.accept(<span class="string">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>语法格式五：</strong>Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//语法格式五使用前</span></span><br><span class="line">    Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">            System.out.println(o1);</span><br><span class="line">            System.out.println(o2);</span><br><span class="line">            <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    System.out.println(com1.compare(<span class="number">12</span>,<span class="number">21</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;*****************************&quot;</span>);</span><br><span class="line">    <span class="comment">//语法格式五使用后</span></span><br><span class="line">    Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; &#123;</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(o2);</span><br><span class="line">        <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    System.out.println(com2.compare(<span class="number">12</span>,<span class="number">6</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>语法格式六：</strong>当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//语法格式六使用前</span></span><br><span class="line">    Comparator&lt;Integer&gt; com1 = (o1,o2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    System.out.println(com1.compare(<span class="number">12</span>,<span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*****************************&quot;</span>);</span><br><span class="line">    <span class="comment">//语法格式六使用后</span></span><br><span class="line">    Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; o1.compareTo(o2);</span><br><span class="line"></span><br><span class="line">    System.out.println(com2.compare(<span class="number">12</span>,<span class="number">21</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//语法格式六使用前</span></span><br><span class="line">    Consumer&lt;String&gt; con1 = s -&gt; &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;;</span><br><span class="line">    con1.accept(<span class="string">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*****************************&quot;</span>);</span><br><span class="line">    <span class="comment">//语法格式六使用后</span></span><br><span class="line">    Consumer&lt;String&gt; con2 = s -&gt; System.out.println(s);</span><br><span class="line"></span><br><span class="line">    con2.accept(<span class="string">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java8新特性：函数式-Functional-接口"><a href="#Java8新特性：函数式-Functional-接口" class="headerlink" title="Java8新特性：函数式(Functional)接口"></a>Java8新特性：函数式(Functional)接口</h3><h4 id="什么是函数式接口"><a href="#什么是函数式接口" class="headerlink" title="什么是函数式接口"></a>什么是函数式接口</h4><ul>
<li>只包含<code>一个抽象方法</code>（Single Abstract Method，简称SAM）的接口，称为函数式接口。当然该接口可以包含其他非抽象方法。</li>
<li>你可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda 表达式抛出一个受检异常(即：非运行时异常)，那么该异常需要在目标接口的抽象方法上进行声明）。</li>
<li>我们可以在一个接口上使用 <code>@FunctionalInterface</code> 注解，这样做可以检查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。</li>
<li>在<code>java.util.function</code>包下定义了Java 8 的丰富的函数式接口</li>
</ul>
<h4 id="如何理解函数式接口"><a href="#如何理解函数式接口" class="headerlink" title="如何理解函数式接口"></a>如何理解函数式接口</h4><ul>
<li>简单的说，在Java8中，Lambda表达式就是一个函数式接口的实例。这就是Lambda表达式和函数式接口的关系。也就是说，只要一个对象是函数式接口的实例，那么该对象就可以用Lambda表达式来表示。</li>
</ul>
<h4 id="Java-内置函数式接口"><a href="#Java-内置函数式接口" class="headerlink" title="Java 内置函数式接口"></a>Java 内置函数式接口</h4><ul>
<li>java.lang.Runnable<ul>
<li>public void run()</li>
</ul>
</li>
<li>java.lang.Iterable<T><ul>
<li>public Iterator<T> iterate()</li>
</ul>
</li>
<li>java.lang.Comparable<T><ul>
<li>public int compareTo(T t)</li>
</ul>
</li>
<li>java.util.Comparator<T><ul>
<li>public int compare(T t1, T t2)</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>函数式接口</th>
<th>称谓</th>
<th>参数类型</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>Consumer&lt;T&gt;  </code></td>
<td>消费型接口</td>
<td>T</td>
<td>对类型为T的对象应用操作，包含方法：  <code>void accept(T t)  </code></td>
</tr>
<tr>
<td><code>Supplier&lt;T&gt;  </code></td>
<td>供给型接口</td>
<td>无</td>
<td>返回类型为T的对象，包含方法：<code>T get()  </code></td>
</tr>
<tr>
<td><code>Function&lt;T, R&gt;  </code></td>
<td>函数型接口</td>
<td>T</td>
<td>对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：<code>R apply(T t)  </code></td>
</tr>
<tr>
<td><code>Predicate&lt;T&gt;  </code></td>
<td>判断型接口</td>
<td>T</td>
<td>确定类型为T的对象是否满足某约束，并返回 boolean 值。包含方法：<code>boolean test(T t)  </code></td>
</tr>
</tbody></table>
<p>其他接口：  </p>
<p><strong>类型1：消费型接口</strong></p>
<p>消费型接口的抽象方法特点：有形参，但是返回值类型是void</p>
<table>
<thead>
<tr>
<th>接口名</th>
<th>抽象方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BiConsumer&lt;T,U&gt;</td>
<td>void accept(T t, U u)</td>
<td>接收两个对象用于完成功能</td>
</tr>
<tr>
<td>DoubleConsumer</td>
<td>void accept(double value)</td>
<td>接收一个double值</td>
</tr>
<tr>
<td>IntConsumer</td>
<td>void accept(int value)</td>
<td>接收一个int值</td>
</tr>
<tr>
<td>LongConsumer</td>
<td>void accept(long value)</td>
<td>接收一个long值</td>
</tr>
<tr>
<td>ObjDoubleConsumer<T></td>
<td>void accept(T t, double value)</td>
<td>接收一个对象和一个double值</td>
</tr>
<tr>
<td>ObjIntConsumer<T></td>
<td>void accept(T t, int value)</td>
<td>接收一个对象和一个int值</td>
</tr>
<tr>
<td>ObjLongConsumer<T></td>
<td>void accept(T t, long value)</td>
<td>接收一个对象和一个long值</td>
</tr>
</tbody></table>
<p><strong>类型2：供给型接口</strong></p>
<p>这类接口的抽象方法特点：无参，但是有返回值</p>
<table>
<thead>
<tr>
<th>接口名</th>
<th>抽象方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BooleanSupplier</td>
<td>boolean getAsBoolean()</td>
<td>返回一个boolean值</td>
</tr>
<tr>
<td>DoubleSupplier</td>
<td>double getAsDouble()</td>
<td>返回一个double值</td>
</tr>
<tr>
<td>IntSupplier</td>
<td>int getAsInt()</td>
<td>返回一个int值</td>
</tr>
<tr>
<td>LongSupplier</td>
<td>long getAsLong()</td>
<td>返回一个long值</td>
</tr>
</tbody></table>
<p><strong>类型3：函数型接口</strong></p>
<p>这类接口的抽象方法特点：既有参数又有返回值</p>
<table>
<thead>
<tr>
<th>接口名</th>
<th>抽象方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>UnaryOperator<T></td>
<td>T apply(T t)</td>
<td>接收一个T类型对象，返回一个T类型对象结果</td>
</tr>
<tr>
<td>DoubleFunction<R></td>
<td>R apply(double value)</td>
<td>接收一个double值，返回一个R类型对象</td>
</tr>
<tr>
<td>IntFunction<R></td>
<td>R apply(int value)</td>
<td>接收一个int值，返回一个R类型对象</td>
</tr>
<tr>
<td>LongFunction<R></td>
<td>R apply(long value)</td>
<td>接收一个long值，返回一个R类型对象</td>
</tr>
<tr>
<td>ToDoubleFunction<T></td>
<td>double applyAsDouble(T value)</td>
<td>接收一个T类型对象，返回一个double</td>
</tr>
<tr>
<td>ToIntFunction<T></td>
<td>int applyAsInt(T value)</td>
<td>接收一个T类型对象，返回一个int</td>
</tr>
<tr>
<td>ToLongFunction<T></td>
<td>long applyAsLong(T value)</td>
<td>接收一个T类型对象，返回一个long</td>
</tr>
<tr>
<td>DoubleToIntFunction</td>
<td>int applyAsInt(double value)</td>
<td>接收一个double值，返回一个int结果</td>
</tr>
<tr>
<td>DoubleToLongFunction</td>
<td>long applyAsLong(double value)</td>
<td>接收一个double值，返回一个long结果</td>
</tr>
<tr>
<td>IntToDoubleFunction</td>
<td>double applyAsDouble(int value)</td>
<td>接收一个int值，返回一个double结果</td>
</tr>
<tr>
<td>IntToLongFunction</td>
<td>long applyAsLong(int value)</td>
<td>接收一个int值，返回一个long结果</td>
</tr>
<tr>
<td>LongToDoubleFunction</td>
<td>double applyAsDouble(long value)</td>
<td>接收一个long值，返回一个double结果</td>
</tr>
<tr>
<td>LongToIntFunction</td>
<td>int applyAsInt(long value)</td>
<td>接收一个long值，返回一个int结果</td>
</tr>
<tr>
<td>DoubleUnaryOperator</td>
<td>double applyAsDouble(double operand)</td>
<td>接收一个double值，返回一个double</td>
</tr>
<tr>
<td>IntUnaryOperator</td>
<td>int applyAsInt(int operand)</td>
<td>接收一个int值，返回一个int结果</td>
</tr>
<tr>
<td>LongUnaryOperator</td>
<td>long applyAsLong(long operand)</td>
<td>接收一个long值，返回一个long结果</td>
</tr>
<tr>
<td>BiFunction&lt;T,U,R&gt;</td>
<td>R apply(T t, U u)</td>
<td>接收一个T类型和一个U类型对象，返回一个R类型对象结果</td>
</tr>
<tr>
<td>BinaryOperator<T></td>
<td>T apply(T t, T u)</td>
<td>接收两个T类型对象，返回一个T类型对象结果</td>
</tr>
<tr>
<td>ToDoubleBiFunction&lt;T,U&gt;</td>
<td>double applyAsDouble(T t, U u)</td>
<td>接收一个T类型和一个U类型对象，返回一个double</td>
</tr>
<tr>
<td>ToIntBiFunction&lt;T,U&gt;</td>
<td>int applyAsInt(T t, U u)</td>
<td>接收一个T类型和一个U类型对象，返回一个int</td>
</tr>
<tr>
<td>ToLongBiFunction&lt;T,U&gt;</td>
<td>long applyAsLong(T t, U u)</td>
<td>接收一个T类型和一个U类型对象，返回一个long</td>
</tr>
<tr>
<td>DoubleBinaryOperator</td>
<td>double applyAsDouble(double left, double right)</td>
<td>接收两个double值，返回一个double结果</td>
</tr>
<tr>
<td>IntBinaryOperator</td>
<td>int applyAsInt(int left, int right)</td>
<td>接收两个int值，返回一个int结果</td>
</tr>
<tr>
<td>LongBinaryOperator</td>
<td>long applyAsLong(long left, long right)</td>
<td>接收两个long值，返回一个long结果</td>
</tr>
</tbody></table>
<p><strong>类型4：判断型接口</strong></p>
<p>这类接口的抽象方法特点：有参，但是返回值类型是boolean结果。</p>
<table>
<thead>
<tr>
<th>接口名</th>
<th>抽象方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BiPredicate&lt;T,U&gt;</td>
<td>boolean test(T t, U u)</td>
<td>接收两个对象</td>
</tr>
<tr>
<td>DoublePredicate</td>
<td>boolean test(double value)</td>
<td>接收一个double值</td>
</tr>
<tr>
<td>IntPredicate</td>
<td>boolean test(int value)</td>
<td>接收一个int值</td>
</tr>
<tr>
<td>LongPredicate</td>
<td>boolean test(long value)</td>
<td>接收一个long值</td>
</tr>
</tbody></table>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p><strong>练习1：无参无返回值形式</strong></p>
<p>假如有自定义函数式接口Call如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Call</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在测试类中声明一个如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">callSomething</span><span class="params">(Call call)</span>&#123;</span><br><span class="line">		call.shout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在测试类的main方法中调用callSomething方法，并用Lambda表达式为形参call赋值，可以喊出任意你想说的话。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		callSomething(()-&gt;System.out.println(<span class="string">&quot;回家吃饭&quot;</span>));</span><br><span class="line">		callSomething(()-&gt;System.out.println(<span class="string">&quot;我爱你&quot;</span>));</span><br><span class="line">		callSomething(()-&gt;System.out.println(<span class="string">&quot;滚蛋&quot;</span>));</span><br><span class="line">		callSomething(()-&gt;System.out.println(<span class="string">&quot;回来&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">callSomething</span><span class="params">(Call call)</span>&#123;</span><br><span class="line">		call.shout();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Call</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>练习2：消费型接口</strong></p>
<p>代码示例：Consumer<T>接口</p>
<p>在JDK1.8中Collection集合接口的父接口Iterable接口中增加了一个默认方法：</p>
<p><code>public default void forEach(Consumer&lt;? super T&gt; action) </code>遍历Collection集合的每个元素，执行“xxx消费型”操作。</p>
<p>在JDK1.8中Map集合接口中增加了一个默认方法：</p>
<p><code>public default void forEach(BiConsumer&lt;? super K,? super V&gt; action)</code>遍历Map集合的每对映射关系，执行“xxx消费型”操作。</p>
<p>案例：</p>
<p>（1）创建一个Collection系列的集合，添加一些字符串，调用forEach方法遍历查看</p>
<p>（2）创建一个Map系列的集合，添加一些(key,value)键值对，调用forEach方法遍历查看</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">	List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="string">&quot;lambda&quot;</span>,<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">	list.forEach(s -&gt; System.out.println(s));</span><br><span class="line">   &#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">	HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">	map.put(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	map.put(<span class="number">2</span>, <span class="string">&quot;java&quot;</span>);</span><br><span class="line">	map.put(<span class="number">3</span>, <span class="string">&quot;lambda&quot;</span>);</span><br><span class="line">	map.put(<span class="number">4</span>, <span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">	map.forEach((k,v) -&gt; System.out.println(k+<span class="string">&quot;-&gt;&quot;</span>+v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>练习3：供给型接口</strong></p>
<p>代码示例：Supplier<T>接口</p>
<p>在JDK1.8中增加了StreamAPI，java.util.stream.Stream<T>是一个数据流。这个类型有一个静态方法：</p>
<p><code>public static &lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</code>可以创建Stream的对象。而又包含一个forEach方法可以遍历流中的元素：<code>public void forEach(Consumer&lt;? super T&gt; action)</code>。</p>
<p>案例：</p>
<p>现在请调用Stream的generate方法，来产生一个流对象，并调用Math.random()方法来产生数据，为Supplier函数式接口的形参赋值。最后调用forEach方法遍历流中的数据查看结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">	Stream.generate(() -&gt; Math.random()).forEach(num -&gt; System.out.println(num));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>练习4：功能型接口</strong></p>
<p>代码示例：Function&lt;T,R&gt;接口</p>
<p>在JDK1.8时Map接口增加了很多方法，例如：</p>
<p><code>public default void replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; function) </code>按照function指定的操作替换map中的value。</p>
<p><code>public default void forEach(BiConsumer&lt;? super K,? super V&gt; action)</code>遍历Map集合的每对映射关系，执行“xxx消费型”操作。</p>
<p>案例：</p>
<p>（1）声明一个Employee员工类型，包含编号、姓名、薪资。</p>
<p>（2）添加n个员工对象到一个HashMap&lt;Integer,Employee&gt;集合中，其中员工编号为key，员工对象为value。</p>
<p>（3）调用Map的forEach遍历集合</p>
<p>（4）调用Map的replaceAll方法，将其中薪资低于10000元的，薪资设置为10000。</p>
<p>（5）再次调用Map的forEach遍历集合查看结果</p>
<p>Employee类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(<span class="type">int</span> id, String name, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.id = id;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.salary = salary;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> salary;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> salary)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.salary = salary;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Employee [id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;, salary=&quot;</span> + salary + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		HashMap&lt;Integer,Employee&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		<span class="type">Employee</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">8000</span>);</span><br><span class="line">		<span class="type">Employee</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">2</span>, <span class="string">&quot;李四&quot;</span>, <span class="number">9000</span>);</span><br><span class="line">		<span class="type">Employee</span> <span class="variable">e3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">3</span>, <span class="string">&quot;王五&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">		<span class="type">Employee</span> <span class="variable">e4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">4</span>, <span class="string">&quot;赵六&quot;</span>, <span class="number">11000</span>);</span><br><span class="line">		<span class="type">Employee</span> <span class="variable">e5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">5</span>, <span class="string">&quot;钱七&quot;</span>, <span class="number">12000</span>);</span><br><span class="line">		</span><br><span class="line">		map.put(e1.getId(), e1);</span><br><span class="line">		map.put(e2.getId(), e2);</span><br><span class="line">		map.put(e3.getId(), e3);</span><br><span class="line">		map.put(e4.getId(), e4);</span><br><span class="line">		map.put(e5.getId(), e5);</span><br><span class="line">		</span><br><span class="line">		map.forEach((k,v) -&gt; System.out.println(k+<span class="string">&quot;=&quot;</span>+v));</span><br><span class="line">		System.out.println();</span><br><span class="line">		</span><br><span class="line">		map.replaceAll((k,v)-&gt;&#123;</span><br><span class="line">			<span class="keyword">if</span>(v.getSalary()&lt;<span class="number">10000</span>)&#123;</span><br><span class="line">				v.setSalary(<span class="number">10000</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> v;</span><br><span class="line">		&#125;);</span><br><span class="line">		map.forEach((k,v) -&gt; System.out.println(k+<span class="string">&quot;=&quot;</span>+v));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>练习5：判断型接口</strong></p>
<p>代码示例：Predicate<T>接口</p>
<p>JDK1.8时，Collecton<E>接口增加了一下方法，其中一个如下：</p>
<p><code>public default boolean removeIf(Predicate&lt;? super E&gt; filter)</code> 用于删除集合中满足filter指定的条件判断的。</p>
<p><code>public default void forEach(Consumer&lt;? super T&gt; action) </code>遍历Collection集合的每个元素，执行“xxx消费型”操作。</p>
<p>案例：</p>
<p>（1）添加一些字符串到一个Collection集合中</p>
<p>（2）调用forEach遍历集合</p>
<p>（3）调用removeIf方法，删除其中字符串的长度&lt;5的</p>
<p>（4）再次调用forEach遍历集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		list.forEach(str-&gt;System.out.println(str));</span><br><span class="line">		System.out.println();</span><br><span class="line">		</span><br><span class="line">		list.removeIf(str-&gt;str.length()&lt;<span class="number">5</span>);</span><br><span class="line">		list.forEach(str-&gt;System.out.println(str));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>练习6：判断型接口</strong></p>
<p>案例：</p>
<p>（1）声明一个Employee员工类型，包含编号、姓名、性别，年龄，薪资。</p>
<p>（2）声明一个EmployeeSerice员工管理类，包含一个ArrayList<Employee>集合的属性all，在EmployeeSerice的构造器中，创建一些员工对象，为all集合初始化。</p>
<p>（3）在EmployeeSerice员工管理类中，声明一个方法：ArrayList<Employee> get(Predicate<Employee> p)，即将满足p指定的条件的员工，添加到一个新的ArrayList<Employee> 集合中返回。</p>
<p>（4）在测试类中创建EmployeeSerice员工管理类的对象，并调用get方法，分别获取：</p>
<ul>
<li>所有员工对象</li>
<li>所有年龄超过35的员工</li>
<li>所有薪资高于15000的女员工</li>
<li>所有编号是偶数的员工</li>
<li>名字是“张三”的员工</li>
<li>年龄超过25，薪资低于10000的男员工</li>
</ul>
<p>示例代码：</p>
<p>Employee类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">char</span> gender;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(<span class="type">int</span> id, String name, <span class="type">char</span> gender, <span class="type">int</span> age, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.id = id;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.gender = gender;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">		<span class="built_in">this</span>.salary = salary;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> salary;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> salary)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.salary = salary;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Employee [id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;, gender=&quot;</span> + gender + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;, salary=&quot;</span> + salary</span><br><span class="line">				+ <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>员工管理类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EmployeeService</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ArrayList&lt;Employee&gt; all;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">EmployeeService</span><span class="params">()</span>&#123;</span><br><span class="line">		all = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Employee&gt;();</span><br><span class="line">		all.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">33</span>, <span class="number">8000</span>));</span><br><span class="line">		all.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">2</span>, <span class="string">&quot;翠花&quot;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="number">23</span>, <span class="number">18000</span>));</span><br><span class="line">		all.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">3</span>, <span class="string">&quot;无能&quot;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">46</span>, <span class="number">8000</span>));</span><br><span class="line">		all.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">4</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="number">23</span>, <span class="number">9000</span>));</span><br><span class="line">		all.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">5</span>, <span class="string">&quot;老王&quot;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">23</span>, <span class="number">15000</span>));</span><br><span class="line">		all.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">6</span>, <span class="string">&quot;大嘴&quot;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">23</span>, <span class="number">11000</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> ArrayList&lt;Employee&gt; <span class="title function_">get</span><span class="params">(Predicate&lt;Employee&gt; p)</span>&#123;</span><br><span class="line">		ArrayList&lt;Employee&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Employee&gt;();</span><br><span class="line">		<span class="keyword">for</span> (Employee emp : result) &#123;</span><br><span class="line">			<span class="keyword">if</span>(p.test(emp))&#123;</span><br><span class="line">				result.add(emp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">EmployeeService</span> <span class="variable">es</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmployeeService</span>();</span><br><span class="line">		</span><br><span class="line">		es.get(e -&gt; <span class="literal">true</span>).forEach(e-&gt;System.out.println(e));</span><br><span class="line">		System.out.println();</span><br><span class="line">		es.get(e -&gt; e.getAge()&gt;<span class="number">35</span>).forEach(e-&gt;System.out.println(e));</span><br><span class="line">		System.out.println();</span><br><span class="line">		es.get(e -&gt; e.getSalary()&gt;<span class="number">15000</span> &amp;&amp; e.getGender()==<span class="string">&#x27;女&#x27;</span>).forEach(e-&gt;System.out.println(e));</span><br><span class="line">		System.out.println();</span><br><span class="line">		es.get(e -&gt; e.getId()%<span class="number">2</span>==<span class="number">0</span>).forEach(e-&gt;System.out.println(e));</span><br><span class="line">		System.out.println();</span><br><span class="line">		es.get(e -&gt; <span class="string">&quot;张三&quot;</span>.equals(e.getName())).forEach(e-&gt;System.out.println(e));</span><br><span class="line">		System.out.println();</span><br><span class="line">		es.get(e -&gt; e.getAge()&gt;<span class="number">25</span> &amp;&amp; e.getSalary()&lt;<span class="number">10000</span> &amp;&amp; e.getGender()==<span class="string">&#x27;男&#x27;</span>).forEach(e-&gt;System.out.println(e));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java8新特性：方法引用与构造器引用"><a href="#Java8新特性：方法引用与构造器引用" class="headerlink" title="Java8新特性：方法引用与构造器引用"></a>Java8新特性：方法引用与构造器引用</h3><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！</p>
<p>方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。</p>
<blockquote>
<p>语法糖（Syntactic sugar），也译为糖衣语法，是由英国计算机科学家彼得·约翰·兰达（Peter J. Landin）发明的一个术语，指计算机语言中添加的某种语法，这种语法<code>对语言的功能并没有影响，但是更方便程序员使用</code>。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。  </p>
</blockquote>
<h5 id="方法引用格式"><a href="#方法引用格式" class="headerlink" title="方法引用格式"></a>方法引用格式</h5><ul>
<li><p>格式：使用方法引用操作符 “<code>::</code>” 将类(或对象) 与 方法名分隔开来。</p>
<ul>
<li>两个:中间不能有空格，而且必须英文状态下半角输入</li>
</ul>
</li>
<li><p>如下三种主要使用情况：</p>
<ul>
<li>情况1：<code>对象 :: 实例方法名</code></li>
<li>情况2：<code>类 :: 静态方法名</code></li>
<li>情况3：<code>类 :: 实例方法名</code></li>
</ul>
</li>
</ul>
<h5 id="方法引用使用前提"><a href="#方法引用使用前提" class="headerlink" title="方法引用使用前提"></a>方法引用使用前提</h5><p><strong>要求1：</strong>Lambda体只有一句语句，并且是通过调用一个对象的&#x2F;类现有的方法来完成的</p>
<p>例如：System.out对象，调用println()方法来完成Lambda体</p>
<p>​           Math类，调用random()静态方法来完成Lambda体</p>
<p><strong>要求2：</strong></p>
<p>针对情况1：函数式接口中的抽象方法a在被重写时使用了某一个对象的方法b。如果方法a的形参列表、返回值类型与方法b的形参列表、返回值类型都相同，则我们可以使用方法b实现对方法a的重写、替换。  对象 :: 实例方法  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line">Consumer&lt;String&gt; con1 = str -&gt; System.out.println(str);</span><br><span class="line">Consumer&lt;String&gt; con2 = System.out::println;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">Supplier&lt;String&gt; sup1 = () -&gt; emp.getName();</span><br><span class="line">Supplier&lt;String&gt; sup2 = emp::getName;</span><br></pre></td></tr></table></figure>

<p>针对情况2：函数式接口中的抽象方法a在被重写时使用了某一个类的静态方法b。如果方法a的形参列表、返回值类型与方法b的形参列表、返回值类型都相同，则我们可以使用方法b实现对方法a的重写、替换。  类 :: 静态方法  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line">Comparator&lt;Integer&gt; com1 = (t1,t2) -&gt; Integer.compare(t1,t2);</span><br><span class="line">Comparator&lt;Integer&gt; com2 = Integer::compare;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">Function&lt;Double,Long&gt; func1 = d -&gt; Math.round(d);</span><br><span class="line">Function&lt;Double,Long&gt; func2 = Math::round;</span><br></pre></td></tr></table></figure>

<p>针对情况3：函数式接口中的抽象方法a在被重写时使用了某一个对象的方法b。如果方法a的返回值类型与方法b的返回值类型相同，同时方法a的形参列表中有n个参数，方法b的形参列表有n-1个参数，且方法a的第1个参数作为方法b的调用者，且方法a的后n-1参数与方法b的n-1参数匹配（类型相同或满足多态场景也可以）  类 :: 实例方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line">Comparator&lt;String&gt; com1 = (s1,s2) -&gt; s1.compareTo(s2);</span><br><span class="line">Comparator&lt;String&gt; com2 = String :: compareTo;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">BiPredicate&lt;String,String&gt; pre1 = (s1,s2) -&gt; s1.equals(s2);</span><br><span class="line">BiPredicate&lt;String,String&gt; pre2 = String :: equals;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line">Function&lt;Employee,String&gt; func1 = e -&gt; e.getName();</span><br><span class="line">Function&lt;Employee,String&gt; func2 = Employee::getName;</span><br></pre></td></tr></table></figure>


<h4 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h4><p>当Lambda表达式是创建一个对象，并且满足Lambda表达式形参，正好是给创建这个对象的构造器的实参列表，就可以使用构造器引用。</p>
<p>格式：<code>类名::new</code>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Supplier&lt;Employee&gt; sup = <span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;Employee&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Employee <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Supplier&lt;Employee&gt;  sup1 = () -&gt; <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line"></span><br><span class="line">Supplier&lt;Employee&gt;  sup2 = Employee :: <span class="keyword">new</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="数组构造引用"><a href="#数组构造引用" class="headerlink" title="数组构造引用"></a>数组构造引用</h4><p>当Lambda表达式是创建一个数组对象，并且满足Lambda表达式形参，正好是给创建这个数组对象的长度，就可以数组构造引用。</p>
<p>格式：<code>数组类型名::new</code>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer,String[]&gt; func1 = length -&gt; <span class="keyword">new</span> <span class="title class_">String</span>[length];</span><br><span class="line">Function&lt;Integer,String[]&gt; func2 = String[] :: <span class="keyword">new</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Java8新特性：强大的Stream-API"><a href="#Java8新特性：强大的Stream-API" class="headerlink" title="Java8新特性：强大的Stream API"></a>Java8新特性：强大的Stream API</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul>
<li>Stream API ( java.util.stream) 把真正的函数式编程风格引入到Java中。这是目前为止对Java类库<code>最好的补充</code>，因为Stream API可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</li>
<li>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 <strong>使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。</strong>也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</li>
</ul>
<p><strong>为什么要使用Stream API</strong>：实际开发中，项目中多数数据源都来自于MySQL、Oracle等。但现在数据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据就需要Java层面去处理。  </p>
<p><strong>什么是Stream</strong>：<br>Stream 是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。</p>
<p>Stream 和 Collection 集合的区别：<strong>Collection 是一种静态的内存数据结构，讲的是数据，而 Stream 是有关计算的，讲的是计算。</strong>前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算。</p>
<p>注意：</p>
<p>①Stream 自己不会存储元素。</p>
<p>②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</p>
<p>③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。即一旦执行终止操作，就执行中间操作链，并产生结果。</p>
<p>④ Stream一旦执行了终止操作，就不能再调用其它中间操作或终止操作了。  </p>
<h4 id="Stream的操作三个步骤"><a href="#Stream的操作三个步骤" class="headerlink" title="Stream的操作三个步骤"></a>Stream的操作三个步骤</h4><p><strong>1- 创建 Stream</strong><br>一个数据源（如：集合、数组），获取一个流</p>
<p><strong>2- 中间操作</strong><br>每次处理都会返回一个持有结果的新Stream，即中间操作的方法返回值仍然是Stream类型的对象。因此中间操作可以是个<code>操作链</code>，可对数据源的数据进行n次处理，但是在终结操作前，并不会真正执行。</p>
<p><strong>3- 终止操作(终端操作)</strong><br>终止操作的方法返回值类型就不再是Stream了，因此一旦执行终止操作，就结束整个Stream操作了。一旦执行终止操作，就执行中间操作链，最终产生结果并结束Stream。  </p>
<h5 id="创建Stream实例"><a href="#创建Stream实例" class="headerlink" title="创建Stream实例"></a>创建Stream实例</h5><p><strong>方式一：通过集合</strong></p>
<p>Java8 中的 Collection 接口被扩展，提供了两个获取流的方法：</p>
<ul>
<li><p>default Stream<E> stream() : 返回一个顺序流</p>
</li>
<li><p>default Stream<E> parallelStream() : 返回一个并行流</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//JDK1.8中，Collection系列集合增加了方法</span></span><br><span class="line">    Stream&lt;Integer&gt; stream = list.stream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方式二：通过数组</strong></p>
<p>Java8 中的 Arrays 的静态方法 stream() 可以获取数组流：</p>
<ul>
<li>static <T> Stream<T> stream(T[] array): 返回一个流</li>
<li>public static IntStream stream(int[] array)</li>
<li>public static LongStream stream(long[] array)</li>
<li>public static DoubleStream stream(double[] array)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">    String[] arr = &#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line">    Stream&lt;String&gt; stream = Arrays.stream(arr); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">IntStream</span> <span class="variable">stream</span> <span class="operator">=</span> Arrays.stream(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方式三：通过Stream的of()</strong></p>
<p>可以调用Stream类静态方法 of(), 通过显示值创建一个流。它可以接收任意数量的参数。</p>
<ul>
<li>public static<T> Stream<T> of(T… values) : 返回一个流</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span>&#123;</span><br><span class="line">    Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">    stream.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方式四：创建无限流(了解)</strong></p>
<p>可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。</p>
<ul>
<li><p>迭代<br>public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f) </p>
</li>
<li><p>生成<br>public static<T> Stream<T> generate(Supplier<T> s)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式四：创建无限流</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 迭代</span></span><br><span class="line">	<span class="comment">// public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final</span></span><br><span class="line">	<span class="comment">// UnaryOperator&lt;T&gt; f)</span></span><br><span class="line">	Stream&lt;Integer&gt; stream = Stream.iterate(<span class="number">0</span>, x -&gt; x + <span class="number">2</span>);</span><br><span class="line">	stream.limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 生成</span></span><br><span class="line">	<span class="comment">// public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</span></span><br><span class="line">	Stream&lt;Double&gt; stream1 = Stream.generate(Math::random);</span><br><span class="line">	stream1.limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="一系列中间操作"><a href="#一系列中间操作" class="headerlink" title="一系列中间操作"></a>一系列中间操作</h5><p>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。</p>
<p>1-筛选与切片</p>
<table>
<thead>
<tr>
<th><strong>方   法</strong></th>
<th><strong>描   述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>filter(Predicatep)</strong></td>
<td>接收  Lambda ， 从流中排除某些元素</td>
</tr>
<tr>
<td><strong>distinct()</strong></td>
<td>筛选，通过流所生成元素的  hashCode() 和 equals() 去除重复元素</td>
</tr>
<tr>
<td><strong>limit(long maxSize)</strong></td>
<td>截断流，使其元素不超过给定数量</td>
</tr>
<tr>
<td><strong>skip(long n)</strong></td>
<td>跳过元素，返回一个扔掉了前  n 个元素的流。<br>若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补</td>
</tr>
</tbody></table>
<p>2-映 射</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>map(Function f)</strong></td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</td>
</tr>
<tr>
<td><strong>mapToDouble(ToDoubleFunction f)</strong></td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 DoubleStream。</td>
</tr>
<tr>
<td><strong>mapToInt(ToIntFunction  f)</strong></td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的  IntStream。</td>
</tr>
<tr>
<td><strong>mapToLong(ToLongFunction  f)</strong></td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的  LongStream。</td>
</tr>
<tr>
<td><strong>flatMap(Function  f)</strong></td>
<td>接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</td>
</tr>
</tbody></table>
<p>3-排序</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>sorted()</strong></td>
<td>产生一个新流，其中按自然顺序排序</td>
</tr>
<tr>
<td><strong>sorted(Comparator</strong> <strong>com)</strong></td>
<td>产生一个新流，其中按比较器顺序排序</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamMiddleOperate</span> &#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1、创建Stream</span></span><br><span class="line">        Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、加工处理</span></span><br><span class="line">        <span class="comment">//过滤：filter(Predicate p)</span></span><br><span class="line">        <span class="comment">//把里面的偶数拿出来</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * filter(Predicate p)</span></span><br><span class="line"><span class="comment">         * Predicate是函数式接口，抽象方法：boolean test(T t)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        stream = stream.filter(t -&gt; t%<span class="number">2</span>==<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、终结操作：例如：遍历</span></span><br><span class="line">        stream.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">        Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">                .filter(t -&gt; t%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">        Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">                .distinct()</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span>&#123;</span><br><span class="line">        Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">                .limit(<span class="number">3</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span>&#123;</span><br><span class="line">        Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">                .distinct()  <span class="comment">//(1,2,3,4,5,6,7)</span></span><br><span class="line">                .filter(t -&gt; t%<span class="number">2</span>!=<span class="number">0</span>) <span class="comment">//(1,3,5,7)</span></span><br><span class="line">                .limit(<span class="number">3</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test06</span><span class="params">()</span>&#123;</span><br><span class="line">        Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">                .skip(<span class="number">5</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test07</span><span class="params">()</span>&#123;</span><br><span class="line">        Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">                .skip(<span class="number">5</span>)</span><br><span class="line">                .distinct()</span><br><span class="line">                .filter(t -&gt; t%<span class="number">3</span>==<span class="number">0</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test08</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">                .distinct()</span><br><span class="line">                .peek(System.out::println)  <span class="comment">//Consumer接口的抽象方法  void accept(T t)</span></span><br><span class="line">                .count();</span><br><span class="line">        System.out.println(<span class="string">&quot;count=&quot;</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test09</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//希望能够找出前三个最大值，前三名最大的，不重复</span></span><br><span class="line">        Stream.of(<span class="number">11</span>,<span class="number">2</span>,<span class="number">39</span>,<span class="number">4</span>,<span class="number">54</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">22</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">54</span>,<span class="number">54</span>)</span><br><span class="line">                .distinct()</span><br><span class="line">                .sorted((t1,t2) -&gt; -Integer.compare(t1, t2))<span class="comment">//Comparator接口  int compare(T t1, T t2)</span></span><br><span class="line">                .limit(<span class="number">3</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test10</span><span class="params">()</span>&#123;</span><br><span class="line">        Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">                .map(t -&gt; t+=<span class="number">1</span>)<span class="comment">//Function&lt;T,R&gt;接口抽象方法 R apply(T t)</span></span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test11</span><span class="params">()</span>&#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="string">&quot;java&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        Arrays.stream(arr)</span><br><span class="line">                .map(t-&gt;t.toUpperCase())</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test12</span><span class="params">()</span>&#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="string">&quot;java&quot;</span>&#125;;</span><br><span class="line">        Arrays.stream(arr)</span><br><span class="line">                .flatMap(t -&gt; Stream.of(t.split(<span class="string">&quot;|&quot;</span>)))<span class="comment">//Function&lt;T,R&gt;接口抽象方法 R apply(T t)  现在的R是一个Stream</span></span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="终止操作"><a href="#终止操作" class="headerlink" title="终止操作"></a>终止操作</h5><p> 终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void 。</p>
<ul>
<li>流进行了终止操作后，不能再次使用。</li>
</ul>
<p>1-匹配与查找</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>allMatch(Predicate  p)</strong></td>
<td>检查是否匹配所有元素</td>
</tr>
<tr>
<td><strong>anyMatch(Predicate  p)</strong></td>
<td>检查是否至少匹配一个元素</td>
</tr>
<tr>
<td><strong>noneMatch(Predicate</strong>  <strong>p)</strong></td>
<td>检查是否没有匹配所有元素</td>
</tr>
<tr>
<td><strong>findFirst()</strong></td>
<td>返回第一个元素</td>
</tr>
<tr>
<td><strong>findAny()</strong></td>
<td>返回当前流中的任意元素</td>
</tr>
<tr>
<td><strong>count()</strong></td>
<td>返回流中元素总数</td>
</tr>
<tr>
<td><strong>max(Comparator c)</strong></td>
<td>返回流中最大值</td>
</tr>
<tr>
<td><strong>min(Comparator c)</strong></td>
<td>返回流中最小值</td>
</tr>
<tr>
<td><strong>forEach(Consumer c)</strong></td>
<td>内部迭代(使用  Collection  接口需要用户去做迭代，称为外部迭代。<br>相反，Stream  API 使用内部迭代——它帮你把迭代做了)</td>
</tr>
</tbody></table>
<p>2-归约</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>reduce(T  identity, BinaryOperator b)</strong></td>
<td>可以将流中元素反复结合起来，得到一个值。返回  T</td>
</tr>
<tr>
<td><strong>reduce(BinaryOperator  b)</strong></td>
<td>可以将流中元素反复结合起来，得到一个值。返回 Optional<T></td>
</tr>
</tbody></table>
<p>备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它来进行网络搜索而出名。</p>
<p>3-收集</p>
<table>
<thead>
<tr>
<th><strong>方   法</strong></th>
<th><strong>描   述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>collect(Collector  c)</strong></td>
<td>将流转换为其他形式。接收一个  Collector接口的实现，<br>用于给Stream中元素做汇总的方法</td>
</tr>
</tbody></table>
<p>Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、Map)。</p>
<p>另外， Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表：</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>toList</strong></td>
<td>Collector&lt;T, ?, List<T>&gt;</td>
<td>把流中元素收集到List</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Employee&gt; emps= list.stream().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>toSet</strong></td>
<td>Collector&lt;T, ?, Set<T>&gt;</td>
<td>把流中元素收集到Set</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Employee&gt; emps= list.stream().collect(Collectors.toSet());</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>toCollection</strong></td>
<td>Collector&lt;T, ?, C&gt;</td>
<td>把流中元素收集到创建的集合</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;Employee&gt; emps =list.stream().collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>counting</strong></td>
<td>Collector&lt;T, ?, Long&gt;</td>
<td>计算流中元素的个数</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> list.stream().collect(Collectors.counting());</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>summingInt</strong></td>
<td>Collector&lt;T, ?, Integer&gt;</td>
<td>对流中元素的整数属性求和</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> total=list.stream().collect(Collectors.summingInt(Employee::getSalary));</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>averagingInt</strong></td>
<td>Collector&lt;T, ?, Double&gt;</td>
<td>计算流中元素Integer属性的平均值</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">avg</span> <span class="operator">=</span> list.stream().collect(Collectors.averagingInt(Employee::getSalary));</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>summarizingInt</strong></td>
<td>Collector&lt;T, ?, IntSummaryStatistics&gt;</td>
<td>收集流中Integer属性的统计值。如：平均值</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> SummaryStatisticsiss= list.stream().collect(Collectors.summarizingInt(Employee::getSalary));</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>joining</strong></td>
<td>Collector&lt;CharSequence, ?, String&gt;</td>
<td>连接流中每个字符串</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str= list.stream().map(Employee::getName).collect(Collectors.joining());</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>maxBy</strong></td>
<td>Collector&lt;T, ?, Optional<T>&gt;</td>
<td>根据比较器选择最大值</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Emp&gt;max= list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary)));</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>minBy</strong></td>
<td>Collector&lt;T, ?, Optional<T>&gt;</td>
<td>根据比较器选择最小值</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Emp&gt; min = list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary)));</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>reducing</strong></td>
<td>Collector&lt;T, ?, Optional<T>&gt;</td>
<td>从一个作为累加器的初始值开始，利用BinaryOperator与流中元素逐个结合，从而归约成单个值</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> total=list.stream().collect(Collectors.reducing(<span class="number">0</span>, Employee::getSalar, Integer::sum));</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>collectingAndThen</strong></td>
<td>Collector&lt;T,A,RR&gt;</td>
<td>包裹另一个收集器，对其结果转换函数</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> how= list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size));</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>groupingBy</strong></td>
<td>Collector&lt;T, ?, Map&lt;K, List<T>&gt;&gt;</td>
<td>根据某属性值对流分组，属性为K，结果为V</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Emp.Status, List&lt;Emp&gt;&gt; map= list.stream().collect(Collectors.groupingBy(Employee::getStatus));</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>partitioningBy</strong></td>
<td>Collector&lt;T, ?, Map&lt;Boolean, List<T>&gt;&gt;</td>
<td>根据true或false进行分区</td>
</tr>
</tbody></table>
<h4 id="Java9新增API"><a href="#Java9新增API" class="headerlink" title="Java9新增API"></a>Java9新增API</h4><p><strong>新增1：Stream实例化方法</strong></p>
<p>ofNullable()的使用：</p>
<p>Java 8 中 Stream 不能完全为null，否则会报空指针异常。而 Java 9 中的 ofNullable 方法允许我们创建一个单元素 Stream，可以包含一个非空元素，也可以创建一个空 Stream。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//报NullPointerException</span></span><br><span class="line"><span class="comment">//Stream&lt;Object&gt; stream1 = Stream.of(null);</span></span><br><span class="line"><span class="comment">//System.out.println(stream1.count());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不报异常，允许通过</span></span><br><span class="line">Stream&lt;String&gt; stringStream = Stream.of(<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">System.out.println(stringStream.count());<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不报异常，允许通过</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">list.add(<span class="literal">null</span>);</span><br><span class="line">System.out.println(list.stream().count());<span class="comment">//2</span></span><br><span class="line"><span class="comment">//ofNullable()：允许值为null</span></span><br><span class="line">Stream&lt;Object&gt; stream1 = Stream.ofNullable(<span class="literal">null</span>);</span><br><span class="line">System.out.println(stream1.count());<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">Stream&lt;String&gt; stream = Stream.ofNullable(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">System.out.println(stream.count());<span class="comment">//1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>iterator()重载的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原来的控制终止方式：</span></span><br><span class="line">Stream.iterate(<span class="number">1</span>,i -&gt; i + <span class="number">1</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">//现在的终止方式：</span></span><br><span class="line">Stream.iterate(<span class="number">1</span>,i -&gt; i &lt; <span class="number">100</span>,i -&gt; i + <span class="number">1</span>).forEach(System.out::println);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="新语法结构"><a href="#新语法结构" class="headerlink" title="新语法结构"></a>新语法结构</h3><p>新的语法结构，为我们勾勒出了 Java 语法进化的一个趋势，将开发者从<code>复杂、繁琐</code>的低层次抽象中逐渐解放出来，以更高层次、更优雅的抽象，既<code>降低代码量</code>，又避免意外编程错误的出现，进而提高代码质量和开发效率。  </p>
<h4 id="Java的REPL工具：-jShell命令"><a href="#Java的REPL工具：-jShell命令" class="headerlink" title="Java的REPL工具： jShell命令"></a>Java的REPL工具： jShell命令</h4><p>利用jShell在没有创建类的情况下，在命令行里直接声明变量，计算表达式，执行语句。无需跟人解释”public static void main(String[] args)”这句”废话”。  </p>
<h4 id="异常处理之try-catch资源关闭"><a href="#异常处理之try-catch资源关闭" class="headerlink" title="异常处理之try-catch资源关闭"></a>异常处理之try-catch资源关闭</h4><p>在JDK7 之前，我们这样处理资源的关闭：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;d:/1.txt&quot;</span>);</span><br><span class="line">        bw = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(fw);</span><br><span class="line"></span><br><span class="line">        bw.write(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bw != <span class="literal">null</span>) &#123;</span><br><span class="line">                bw.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fw != <span class="literal">null</span>) &#123;</span><br><span class="line">                fw.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JDK7的新特性</strong></p>
<p>在try的后面可以增加一个()，在括号中可以声明流对象并初始化。try中的代码执行完毕，会自动把流对象释放，就不用写finally了。</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(资源对象的声明和初始化)&#123;</span><br><span class="line">    业务逻辑代码,可能会产生异常</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> e)&#123;</span><br><span class="line">    处理异常代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> e)&#123;</span><br><span class="line">    处理异常代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>1、在try()中声明的资源，无论是否发生异常，无论是否处理异常，都会自动关闭资源对象，不用手动关闭了。</p>
<p>2、这些资源实现类必须实现AutoCloseable或Closeable接口，实现其中的close()方法。Closeable是AutoCloseable的子接口。Java7几乎把所有的“资源类”（包括文件IO的各种类、JDBC编程的Connection、Statement等接口…）都进行了改写，改写后资源类都实现了AutoCloseable或Closeable接口，并实现了close()方法。</p>
<p>3、写到try()中的资源类的变量默认是final声明的，不能修改。</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//举例1</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (</span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;d:/1.txt&quot;</span>);</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(fw);</span><br><span class="line">    ) &#123;</span><br><span class="line">        bw.write(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//举例2</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//从d:/1.txt(utf-8)文件中，读取内容，写到项目根目录下1.txt(gbk)文件中</span></span><br><span class="line">    <span class="keyword">try</span> (</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;d:/1.txt&quot;</span>);</span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line"></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fos, <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(osw);</span><br><span class="line">    ) &#123;</span><br><span class="line">        String str;</span><br><span class="line">        <span class="keyword">while</span> ((str = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            bw.write(str);</span><br><span class="line">            bw.newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JDK9的新特性</strong></p>
<p>try的前面可以定义流对象，try后面的()中可以直接引用流对象的名称。在try代码执行完毕后，流对象也可以释放掉，也不用写finally了。</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line"><span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line"><span class="keyword">try</span>(a;b)&#123;</span><br><span class="line">    可能产生的异常代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类名 变量名)&#123;</span><br><span class="line">    异常处理的逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in);</span><br><span class="line">    <span class="type">OutputStreamWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out);</span><br><span class="line">    <span class="keyword">try</span> (reader; writer) &#123;</span><br><span class="line">        <span class="comment">//reader是final的，不可再被赋值</span></span><br><span class="line">        <span class="comment">//   reader = null;</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="局部变量类型推断"><a href="#局部变量类型推断" class="headerlink" title="局部变量类型推断"></a>局部变量类型推断</h4><p><strong>JDK 10的新特性</strong></p>
<p>局部变量的显示类型声明，常常被认为是不必须的，给一个好听的名字反而可以很清楚的表达出下面应该怎样继续。本新特性允许开发人员省略通常不必要的局部变量类型声明，以增强Java语言的体验性、可读性。</p>
<ul>
<li>使用举例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.局部变量的实例化</span></span><br><span class="line"><span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="type">var</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.增强for循环中的索引</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> v : list) &#123;</span><br><span class="line">    System.out.println(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.传统for循环中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 返回值类型含复杂泛型结构</span></span><br><span class="line"><span class="type">var</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line"><span class="comment">//Iterator&lt;Map.Entry&lt;Integer, Student&gt;&gt; iterator = set.iterator();</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>不适用场景<ul>
<li>声明一个成员变量</li>
<li>声明一个数组变量，并为数组静态初始化（省略new的情况下）</li>
<li>方法的返回值类型</li>
<li>方法的参数类型</li>
<li>没有初始化的方法内的局部变量声明</li>
<li>作为catch块中异常类型</li>
<li>Lambda表达式中函数式接口的类型</li>
<li>方法引用中函数式接口的类型</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li><p>var不是一个关键字，而是一个类型名，将它作为变量的类型。不能使用var作为类名。</p>
</li>
<li><p>这不是JavaScript。var并不会改变 Java是一门静态类型语言的事实。编译器负责推断出类型，并把结果写入字节码文件，就好像是开发人员自己敲入类型一样。</p>
</li>
</ul>
<h4 id="instanceof的模式匹配"><a href="#instanceof的模式匹配" class="headerlink" title="instanceof的模式匹配"></a>instanceof的模式匹配</h4><p><strong>JDK14中预览特性：</strong></p>
<p>instanceof 模式匹配通过提供更为简便的语法，来提高生产力。有了该功能，可以减少Java程序中显式强制转换的数量，实现更精确、简洁的类型安全的代码。</p>
<p>Java 14之前旧写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(obj <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String)obj; <span class="comment">//需要强转</span></span><br><span class="line">    .. str.contains(..)..</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 14新特性写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(obj <span class="keyword">instanceof</span> String str)&#123;</span><br><span class="line">    .. str.contains(..)..</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JDK15中第二次预览：</strong></p>
<p>没有任何更改。</p>
<p><strong>JDK16中转正特性：</strong></p>
<p>在Java16中转正。  </p>
<h4 id="switch表达式"><a href="#switch表达式" class="headerlink" title="switch表达式"></a>switch表达式</h4><p>传统switch声明语句的弊端：</p>
<ul>
<li>匹配是自上而下的，如果忘记写break，后面的case语句不论匹配与否都会执行； —&gt;case穿透</li>
<li>所有的case语句共用一个块范围，在不同的case语句定义的变量名不能重复；</li>
<li>不能在一个case里写多个执行结果一致的条件；</li>
<li>整个switch不能作为表达式返回值；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常见错误实现</span></span><br><span class="line"><span class="keyword">switch</span>(month)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>|<span class="number">4</span>|<span class="number">5</span>:<span class="comment">//3|4|5 用了位运算符，11 | 100 | 101结果是 111是7</span></span><br><span class="line">        System.out.println(<span class="string">&quot;春季&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>|<span class="number">7</span>|<span class="number">8</span>:<span class="comment">//6|7|8用了位运算符，110 | 111 | 1000结果是1111是15</span></span><br><span class="line">        System.out.println(<span class="string">&quot;夏季&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>|<span class="number">10</span>|<span class="number">11</span>:<span class="comment">//9|10|11用了位运算符，1001 | 1010 | 1011结果是1011是11</span></span><br><span class="line">        System.out.println(<span class="string">&quot;秋季&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>|<span class="number">1</span>|<span class="number">2</span>:<span class="comment">//12|1|2 用了位运算符，1100 | 1 | 10 结果是1111，是15</span></span><br><span class="line">        System.out.println(<span class="string">&quot;冬季&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;输入有误&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JDK12中预览特性：</strong></p>
<ul>
<li><p>Java 12将会对switch声明语句进行扩展，使用<code>case L -&gt;</code>来替代以前的<code>break;</code>，省去了 break 语句，避免了因少写 break 而出错。</p>
</li>
<li><p>同时将多个 case 合并到一行，显得简洁、清晰，也更加优雅的表达逻辑分支。</p>
</li>
<li><p>为了保持兼容性，case 条件语句中依然可以使用字符<code> :</code> ，但是同一个 switch 结构里不能混用<code> -&gt;</code> 和<code> :</code> ，否则编译错误。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwitchTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> Fruit.GRAPE;</span><br><span class="line">        <span class="keyword">switch</span>(fruit)&#123;</span><br><span class="line">            <span class="keyword">case</span> PEAR -&gt; System.out.println(<span class="number">4</span>);</span><br><span class="line">            <span class="keyword">case</span> APPLE,MANGO,GRAPE -&gt; System.out.println(<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">case</span> ORANGE,PAPAYA -&gt; System.out.println(<span class="number">6</span>);</span><br><span class="line">            <span class="keyword">default</span> -&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No Such Fruit:&quot;</span> + fruit);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更进一步：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwitchTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> Fruit.GRAPE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numberOfLetters</span> <span class="operator">=</span> <span class="keyword">switch</span>(fruit)&#123;</span><br><span class="line">            <span class="keyword">case</span> PEAR -&gt; <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">case</span> APPLE,MANGO,GRAPE -&gt; <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">case</span> ORANGE,PAPAYA -&gt; <span class="number">6</span>;</span><br><span class="line">            <span class="keyword">default</span> -&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No Such Fruit:&quot;</span> + fruit);</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(numberOfLetters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JDK13中二次预览特性：</strong></p>
<p>JDK13中引入了yield语句，用于返回值。这意味着，switch表达式(返回值)应该使用yield，switch语句(不返回值)应该使用break。</p>
<p>yield和return的区别在于：return会直接跳出当前循环或者方法，而yield只会跳出当前switch块。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSwitch3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&quot;3&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;1&quot;</span>:</span><br><span class="line">            <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;2&quot;</span>:</span><br><span class="line">            <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JDK14中转正特性：</strong></p>
<p>这是JDK 12和JDK 13中的预览特性，现在是正式特性了。</p>
<p><strong>JDK17的预览特性：switch的模式匹配</strong></p>
<p>旧写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> String <span class="title function_">formatter</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">formatted</span> <span class="operator">=</span> <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Integer i) &#123;</span><br><span class="line">        formatted = String.format(<span class="string">&quot;int %d&quot;</span>, i);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Long l) &#123;</span><br><span class="line">        formatted = String.format(<span class="string">&quot;long %d&quot;</span>, l);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Double d) &#123;</span><br><span class="line">        formatted = String.format(<span class="string">&quot;double %f&quot;</span>, d);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">        formatted = String.format(<span class="string">&quot;String %s&quot;</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> formatted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模式匹配新写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> String <span class="title function_">formatterPatternSwitch</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">switch</span> (o) &#123;</span><br><span class="line">        <span class="keyword">case</span> Integer i -&gt; String.format(<span class="string">&quot;int %d&quot;</span>, i);</span><br><span class="line">        <span class="keyword">case</span> Long l    -&gt; String.format(<span class="string">&quot;long %d&quot;</span>, l);</span><br><span class="line">        <span class="keyword">case</span> Double d  -&gt; String.format(<span class="string">&quot;double %f&quot;</span>, d);</span><br><span class="line">        <span class="keyword">case</span> String s  -&gt; String.format(<span class="string">&quot;String %s&quot;</span>, s);</span><br><span class="line">        <span class="keyword">default</span>        -&gt; o.toString();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接在 switch 上支持 Object 类型，这就等于同时支持多种类型，使用模式匹配得到具体类型，大大简化了语法量，这个功能很实用。  </p>
<h4 id="文本块"><a href="#文本块" class="headerlink" title="文本块"></a>文本块</h4><p>现实问题：</p>
<p>在Java中，通常需要使用String类型表达HTML，XML，SQL或JSON等格式的字符串，在进行字符串赋值时需要进行转义和连接操作，然后才能编译该代码，这种表达方式难以阅读并且难以维护。</p>
<p><strong>JDK13的新特性</strong></p>
<p>使用”””作为文本块的开始符和结束符，在其中就可以放置多行的字符串，不需要进行任何转义。因此，文本块将提高Java程序的可读性和可写性。</p>
<p>基本使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">line1</span></span><br><span class="line"><span class="string">line2</span></span><br><span class="line"><span class="string">line3</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>相当于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;line1\nline2\nline3\n&quot;</span></span><br></pre></td></tr></table></figure>

<p>或者一个连接的字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;line1\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;line2\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;line3\n&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果字符串末尾不需要行终止符，则结束分隔符可以放在最后一行内容上。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">line1</span></span><br><span class="line"><span class="string">line2</span></span><br><span class="line"><span class="string">line3&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>相当于</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;line1\nline2\nline3&quot;</span></span><br></pre></td></tr></table></figure>

<p>文本块可以表示空字符串，但不建议这样做，因为它需要两行源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">empty</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>JDK14中二次预览特性</strong></p>
<p>JDK14的版本主要增加了两个escape sequences，分别是<code> \ &lt;line-terminator&gt;</code>与<code>\s  escape sequence</code>。  </p>
<ul>
<li>:取消换行操作</li>
<li>\s:表示一个空格</li>
</ul>
<p><strong>JDK15中功能转正</strong>  </p>
<h4 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h4><p><code>背景</code></p>
<p>早在2019年2月份，Java 语言架构师 Brian Goetz，曾写文抱怨“<code>Java太啰嗦</code>”或有太多的“繁文缛节”。他提到：开发人员想要创建纯数据载体类（plain data carriers）通常都必须编写大量低价值、重复的、容易出错的代码。如：构造函数、getter&#x2F;setter、equals()、hashCode()以及toString()等。</p>
<p>以至于很多人选择使用IDE的功能来自动生成这些代码。还有一些开发会选择使用一些第三方类库，如Lombok等来生成这些方法。</p>
<p><strong>JDK14中预览特性：神说要用record，于是就有了。</strong>实现一个简单的数据载体类，为了避免编写：构造函数，访问器，equals()，hashCode () ，toString ()等，Java 14推出record。</p>
<p><code>record</code> 是一种全新的类型，它本质上是一个 <code>final</code> 类，同时所有的属性都是 <code>final</code> 修饰，它会自动编译出 <code>public get</code> 、<code>hashcode</code> 、<code>equals</code>、<code>toString</code>、构造器等结构，减少了代码编写量。</p>
<p>具体来说：当你用<code>record</code> 声明一个类时，该类将自动拥有以下功能：</p>
<ul>
<li>获取成员变量的简单方法，比如例题中的 name() 和 partner() 。注意区别于我们平常getter()的写法。</li>
<li>一个 equals 方法的实现，执行比较时会比较该类的所有成员属性。</li>
<li>重写 hashCode() 方法。</li>
<li>一个可以打印该类所有成员属性的 toString() 方法。</li>
<li>只有一个构造方法。</li>
</ul>
<p>此外：</p>
<ul>
<li><p>还可以在record声明的类中定义静态字段、静态方法、构造器或实例方法。</p>
</li>
<li><p>不能在record声明的类中定义实例字段；类不能声明为abstract；不能声明显式的父类等。</p>
</li>
</ul>
<p>举例1（新写法）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>JDK15中第二次预览特性</strong></p>
<p><strong>JDK16中转正特性</strong></p>
<p>最终到JDK16中转正。</p>
<p><code>记录不适合哪些场景</code></p>
<p>record的设计目标是提供一种将数据建模为数据的好方法。它也不是 JavaBeans 的直接替代品，因为record的方法不符合 JavaBeans 的 get 标准。另外 JavaBeans 通常是可变的，而记录是不可变的。尽管它们的用途有点像，但记录并不会以某种方式取代 JavaBean。  </p>
<h4 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h4><p>背景：</p>
<p>在 Java 中如果想让一个类不能被继承和修改，这时我们应该使用 <code>final</code> 关键字对类进行修饰。不过这种要么可以继承，要么不能继承的机制不够灵活，有些时候我们可能想让某个类可以被某些类型继承，但是又不能随意继承，是做不到的。Java 15 尝试解决这个问题，引入了 <code>sealed</code> 类，被 <code>sealed</code> 修饰的类可以指定子类。这样这个类就只能被指定的类继承。</p>
<p><strong>JDK15的预览特性：</strong></p>
<p>通过密封的类和接口来限制超类的使用，密封的类和接口限制其它可能继承或实现它们的其它类或接口。</p>
<p>具体使用：</p>
<ul>
<li><p>使用修饰符<code>sealed</code>，可以将一个类声明为密封类。密封的类使用保留关键字<code>permits</code>列出可以直接扩展（即extends）它的类。</p>
</li>
<li><p><code>sealed</code> 修饰的类的机制具有传递性，它的子类必须使用指定的关键字进行修饰，且只能是 <code>final</code>、<code>sealed</code>、<code>non-sealed</code> 三者之一。</p>
</li>
</ul>
<p><strong>JDK16二次预览特性</strong></p>
<p><strong>JDK17中转正特性</strong>  </p>
<h3 id="API的变化"><a href="#API的变化" class="headerlink" title="API的变化"></a>API的变化</h3><h4 id="Optional-类"><a href="#Optional-类" class="headerlink" title="Optional 类"></a>Optional 类</h4><p><strong>JDK8的新特性</strong></p>
<p>到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google在著名的Guava项目引入了Optional类，通过检查空值的方式避免空指针异常。受到Google的启发，Optional类已经成为Java 8类库的一部分。</p>
<p><code>Optional&lt;T&gt;</code> 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。如果值存在，则isPresent()方法会返回true，调用get()方法会返回该对象。</p>
<p>Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p>
<ul>
<li><p><code>创建Optional类对象的方法：</code></p>
</li>
<li><p>static <T> Optional<T> empty() ：用来创建一个空的Optional实例</p>
<ul>
<li>static <T> Optional<T> of(T value) ：用来创建一个Optional实例，value必须非空</li>
<li><code>static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value)</code> ：用来创建一个Optional实例，value可能是空，也可能非空</li>
</ul>
</li>
<li><p><code>判断Optional容器中是否包含对象：</code></p>
<ul>
<li>boolean isPresent() : 判断Optional容器中的值是否存在</li>
<li>void ifPresent(Consumer&lt;? super T&gt; consumer) ：判断Optional容器中的值是否存在，如果存在，就对它进行Consumer指定的操作，如果不存在就不做</li>
</ul>
</li>
<li><p><code>获取Optional容器的对象：</code></p>
</li>
<li><p>T get(): 如果调用对象包含值，返回该值。否则抛异常。T get()与of(T value)配合使用</p>
</li>
<li><p><code>T orElse(T other) </code>：orElse(T other) 与ofNullable(T value)配合使用，如果Optional容器中非空，就返回所包装值，如果为空，就用orElse(T other)other指定的默认值（备胎）代替</p>
</li>
<li><p>T orElseGet(Supplier&lt;? extends T&gt; other) ：如果Optional容器中非空，就返回所包装值，如果为空，就用Supplier接口的Lambda表达式提供的值代替</p>
</li>
<li><p>T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) ：如果Optional容器中非空，就返回所包装值，如果为空，就抛出你指定的异常类型代替原来的NoSuchElementException</p>
</li>
</ul>
<p><strong>这是JDK9-11的新特性</strong></p>
<table>
<thead>
<tr>
<th><strong>新增方法</strong></th>
<th><strong>描述</strong></th>
<th><strong>新增的版本</strong></th>
</tr>
</thead>
<tbody><tr>
<td>boolean isEmpty()</td>
<td>判断value是否为空</td>
<td>JDK  11</td>
</tr>
<tr>
<td>ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction)</td>
<td>value非空，执行参数1功能；如果value为空，执行参数2功能</td>
<td>JDK  9</td>
</tr>
<tr>
<td>Optional<T> or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier)</td>
<td>value非空，返回对应的Optional；value为空，返回形参封装的Optional</td>
<td>JDK  9</td>
</tr>
<tr>
<td>Stream<T> stream()</td>
<td>value非空，返回仅包含此value的Stream；否则，返回一个空的Stream</td>
<td>JDK  9</td>
</tr>
<tr>
<td>T orElseThrow()</td>
<td>value非空，返回value；否则抛异常NoSuchElementException</td>
<td>JDK  10</td>
</tr>
</tbody></table>
<h4 id="String存储结构和API变更"><a href="#String存储结构和API变更" class="headerlink" title="String存储结构和API变更"></a>String存储结构和API变更</h4><p><strong>这是JDK9的新特性。</strong></p>
<p>产生背景：</p>
<blockquote>
<p>Motivation<br>The current implementation of the String class stores characters in a char array, using two bytes (sixteen bits) for each character. Data gathered from many different applications indicates that strings are a major component of heap usage and, moreover, that most String objects contain only Latin-1 characters. Such characters require only one byte of storage, hence half of the space in the internal char arrays of such String objects is going unused.</p>
</blockquote>
<p>使用说明：</p>
<blockquote>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>We propose to change the internal representation of the String class from a UTF-16 char array to a byte array plus an encoding-flag field. The new String class will store characters encoded either as ISO-8859-1&#x2F;Latin-1 (one byte per character), or as UTF-16 (two bytes per character), based upon the contents of the string. The encoding flag will indicate which encoding is used.</p>
</blockquote>
<p>结论：String 再也不用 char[] 来存储啦，改成了 byte[] 加上编码标记，节约了一些空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拓展：StringBuffer 与 StringBuilder</p>
<p>那StringBuffer 和 StringBuilder 是否仍无动于衷呢？</p>
<blockquote>
<p>String-related classes such as AbstractStringBuilder, StringBuilder, and StringBuffer will be updated to use the same representation, as will the HotSpot VM’s intrinsic string operations.</p>
</blockquote>
<p><strong>JDK11新特性：新增了一系列字符串处理方法</strong></p>
<table>
<thead>
<tr>
<th><strong>描述</strong></th>
<th><strong>举例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>判断字符串是否为空白</td>
<td>“  “.isBlank(); &#x2F;&#x2F; true</td>
</tr>
<tr>
<td>去除首尾空白</td>
<td>“  Javastack “.strip(); &#x2F;&#x2F; “Javastack”</td>
</tr>
<tr>
<td>去除尾部空格</td>
<td>“  Javastack “.stripTrailing(); &#x2F;&#x2F; “ Javastack”</td>
</tr>
<tr>
<td>去除首部空格</td>
<td>“  Javastack “.stripLeading(); &#x2F;&#x2F; “Javastack “</td>
</tr>
<tr>
<td>复制字符串</td>
<td>“Java”.repeat(3);&#x2F;&#x2F;  “JavaJavaJava”</td>
</tr>
<tr>
<td>行数统计</td>
<td>“A\nB\nC”.lines().count();  &#x2F;&#x2F; 3</td>
</tr>
</tbody></table>
<p><strong>JDK12新特性：String 实现了 Constable 接口</strong></p>
<p>String源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence,Constable, ConstantDesc &#123;</span><br></pre></td></tr></table></figure>

<p>java.lang.constant.Constable接口定义了抽象方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Constable</span> &#123;</span><br><span class="line">	Optional&lt;? <span class="keyword">extends</span> <span class="title class_">ConstantDesc</span>&gt; describeConstable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 12 String 的实现源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns an &#123;<span class="doctag">@link</span> Optional&#125; containing the nominal descriptor for this</span></span><br><span class="line"><span class="comment"> * instance, which is the instance itself.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an &#123;<span class="doctag">@link</span> Optional&#125; describing the &#123;<span class="doctag">@linkplain</span> String&#125; instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Optional&lt;String&gt; <span class="title function_">describeConstable</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Optional.of(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单，其实就是调用 Optional.of 方法返回一个 Optional 类型。</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testDescribeConstable</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;尚硅谷Java高级工程师&quot;</span>;</span><br><span class="line">	Optional&lt;String&gt; optional = name.describeConstable();</span><br><span class="line">	System.out.println(optional.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">尚硅谷Java高级工程师</span><br></pre></td></tr></table></figure>

<p><strong>JDK12新特性：String新增方法</strong></p>
<p>String的transform(Function)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;foo&quot;</span>.transform(input -&gt; input + <span class="string">&quot; bar&quot;</span>);</span><br><span class="line">System.out.println(result); <span class="comment">//foo bar</span></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;foo&quot;</span>.transform(input -&gt; input + <span class="string">&quot; bar&quot;</span>).transform(String::toUpperCase)</span><br><span class="line">System.out.println(result); <span class="comment">//FOO BAR</span></span><br></pre></td></tr></table></figure>

<p>对应的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* This method allows the application of a function to &#123;<span class="doctag">@code</span> this&#125;</span></span><br><span class="line"><span class="comment">* string. The function should expect a single String argument</span></span><br><span class="line"><span class="comment">* and produce an &#123;<span class="doctag">@code</span> R&#125; result.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 12</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> &lt;R&gt; R <span class="title function_">transform</span><span class="params">(Function&lt;? <span class="built_in">super</span> String, ? extends R&gt; f)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> f.apply(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在某种情况下，该方法应该被称为map()。</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testTransform</span><span class="params">()</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;======test java 12 transform======&quot;</span>);</span><br><span class="line">	List&lt;String&gt; list1 = List.of(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot; Python&quot;</span>, <span class="string">&quot; C++ &quot;</span>);</span><br><span class="line">	List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">	list1.forEach(element -&gt; list2.add(element.transform(String::strip)</span><br><span class="line">								  .transform(String::toUpperCase)</span><br><span class="line">								  .transform((e) -&gt; <span class="string">&quot;Hi,&quot;</span> + e))</span><br><span class="line">				 );</span><br><span class="line">	list2.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">======test java <span class="number">12</span> transform======</span><br><span class="line">Hi,JAVA</span><br><span class="line">Hi,PYTHON</span><br><span class="line">Hi,C++</span><br></pre></td></tr></table></figure>

<p>如果使用Java 8的Stream特性，可以如下实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testTransform1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;======test before java 12 ======&quot;</span>);</span><br><span class="line">        List&lt;String&gt; list1 = List.of(<span class="string">&quot;Java  &quot;</span>, <span class="string">&quot; Python&quot;</span>, <span class="string">&quot; C++ &quot;</span>);</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stringStream = list1.stream().map(element -&gt; element.strip()).map(String::toUpperCase).map(element -&gt; <span class="string">&quot;Hello,&quot;</span> + element);</span><br><span class="line">        List&lt;String&gt; list2 = stringStream.collect(Collectors.toList());</span><br><span class="line">        list2.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="JDK17：标记删除Applet-API"><a href="#JDK17：标记删除Applet-API" class="headerlink" title="JDK17：标记删除Applet API"></a>JDK17：标记删除Applet API</h4><p>Applet API 提供了一种将 Java AWT&#x2F;Swing 控件嵌入到浏览器网页中的方法。不过，目前 Applet 已经被淘汰。大部分人可能压根就没有用过 Applet。</p>
<p>Applet API 实际上是无用的，因为所有 Web 浏览器供应商都已删除或透露计划放弃对 Java 浏览器插件的支持。Java 9 的时候，Applet API 已经被标记为过时，Java 17 的时候终于标记为删除了。</p>
<p>具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.applet.Applet</span><br><span class="line">java.applet.AppletStub</span><br><span class="line">java.applet.AppletContext</span><br><span class="line">java.applet.AudioClip</span><br><span class="line">javax.swing.JApplet</span><br><span class="line">java.beans.AppletInitializer</span><br></pre></td></tr></table></figure>

<h3 id="其它结构变化"><a href="#其它结构变化" class="headerlink" title="其它结构变化"></a>其它结构变化</h3><h4 id="JDK9：UnderScore-下划线-使用的限制"><a href="#JDK9：UnderScore-下划线-使用的限制" class="headerlink" title="JDK9：UnderScore(下划线)使用的限制"></a>JDK9：UnderScore(下划线)使用的限制</h4><p>在java 8 中，标识符可以独立使用“_”来命名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">_</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(_);</span><br></pre></td></tr></table></figure>

<p>但是，在java 9 中规定“_”不再可以单独命名标识符了，如果使用，会报错</p>
<h4 id="JDK11：更简化的编译运行程序"><a href="#JDK11：更简化的编译运行程序" class="headerlink" title="JDK11：更简化的编译运行程序"></a>JDK11：更简化的编译运行程序</h4><p>看下面的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译</span></span><br><span class="line">javac JavaStack.java</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行</span></span><br><span class="line">java JavaStack</span><br></pre></td></tr></table></figure>

<p>我们的认知里，要运行一个 Java 源代码必须先编译，再运行。而在 Java 11 版本中，通过一个 java 命令就直接搞定了，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java JavaStack.java</span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<ul>
<li>执行源文件中的第一个类，第一个类必须包含主方法。</li>
</ul>
<h4 id="GC方面新特性"><a href="#GC方面新特性" class="headerlink" title="GC方面新特性"></a>GC方面新特性</h4><p>GC是Java主要优势之一。 然而，当GC停顿太长，就会开始影响应用的响应时间。随着现代系统中内存不断增长，用户和程序员希望JVM能够以高效的方式充分利用这些内存， 并且无需长时间的GC暂停时间。</p>
<h5 id="G1-GC"><a href="#G1-GC" class="headerlink" title="G1 GC"></a>G1 GC</h5><p>JDK9以后默认的垃圾回收器是G1GC。</p>
<p><strong>JDK10 : 为G1提供并行的Full GC</strong></p>
<p>G1最大的亮点就是可以尽量的避免full gc。但毕竟是“尽量”，在有些情况下，G1就要进行full gc了，比如如果它无法足够快的回收内存的时候，它就会强制停止所有的应用线程然后清理。</p>
<p>在Java10之前，一个单线程版的标记-清除-压缩算法被用于full gc。为了尽量减少full gc带来的影响，在Java10中，就把之前的那个单线程版的标记-清除-压缩的full gc算法改成了支持多个线程同时full gc。这样也算是减少了full gc所带来的停顿，从而提高性能。</p>
<p>你可以通过<code>-XX:ParallelGCThreads</code>参数来指定用于并行GC的线程数。</p>
<p><strong>JDK12：可中断的 G1 Mixed GC</strong></p>
<p><strong>JDK12：增强G1，自动返回未用堆内存给操作系统</strong></p>
<h5 id="Shenandoah-GC"><a href="#Shenandoah-GC" class="headerlink" title="Shenandoah GC"></a>Shenandoah GC</h5><p><strong>JDK12：Shenandoah GC：低停顿时间的GC</strong></p>
<p><img src="/images/image-20220528212254705.png" alt="image-20220528212254705"></p>
<p>Shenandoah 垃圾回收器是 Red Hat 在 2014 年宣布进行的一项垃圾收集器研究项目 Pauseless GC 的实现，旨在<strong>针对 JVM 上的内存收回实现低停顿的需求</strong>。</p>
<p>据 Red Hat 研发 Shenandoah 团队对外宣称，Shenandoah 垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为 200 MB 还是 200 GB，都将拥有一致的系统暂停时间，不过实际使用性能将取决于实际工作堆的大小和工作负载。</p>
<p>Shenandoah GC 主要目标是 99.9% 的暂停小于 10ms，暂停与堆大小无关等。</p>
<p>这是一个实验性功能，不包含在默认（Oracle）的OpenJDK版本中。</p>
<p>Shenandoah开发团队在实际应用中的测试数据：</p>
<p><img src="/images/image-20220528212323729.png" alt="image-20220528212323729"></p>
<p><strong>JDK15：Shenandoah垃圾回收算法转正</strong></p>
<p>Shenandoah垃圾回收算法终于从实验特性转变为产品特性，这是一个从 JDK 12 引入的回收算法，该算法通过与正在运行的 Java 线程同时进行疏散工作来减少 GC 暂停时间。Shenandoah 的暂停时间与堆大小无关，无论堆栈是 200 MB 还是 200 GB，都具有相同的一致暂停时间。</p>
<p>Shenandoah在JDK12被作为experimental引入，在JDK15变为Production；之前需要通过<code>-XX:+UnlockExperimentalVMOptions</code> <code>-XX:+UseShenandoahGC</code>来启用，现在只需要<code>-XX:+UseShenandoahGC</code>即可启用</p>
<h5 id="革命性的-ZGC"><a href="#革命性的-ZGC" class="headerlink" title="革命性的 ZGC"></a>革命性的 ZGC</h5><p><strong>JDK11：引入革命性的 ZGC</strong></p>
<p>ZGC，这应该是JDK11最为瞩目的特性，没有之一。 </p>
<p>ZGC是一个并发、基于region、压缩型的垃圾收集器。</p>
<p>ZGC的设计目标是：支持TB级内存容量，暂停时间低（&lt;10ms），对整个程序吞吐量的影响小于15%。 将来还可以扩展实现机制，以支持不少令人兴奋的功能，例如多层堆（即热对象置于DRAM和冷对象置于NVMe闪存），或压缩堆。</p>
<p><strong>JDK13：ZGC:将未使用的堆内存归还给操作系统</strong></p>
<p><strong>JDK14：ZGC on macOS和windows</strong></p>
<ul>
<li><p>JDK14之前，ZGC仅Linux才支持。现在mac或Windows上也能使用ZGC了，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</span><br></pre></td></tr></table></figure>
</li>
<li><p>ZGC与Shenandoah目标高度相似，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在<code>十毫秒以内</code>的低延迟。</p>
</li>
</ul>
<p><img src="/images/image-20220528212414676.png" alt="image-20220528212414676"></p>
<p><img src="/images/image-20220528212421319.png" alt="image-20220528212421319"></p>
<p><strong>JDK15：ZGC 功能转正</strong></p>
<p>ZGC是Java 11引入的新的垃圾收集器，经过了多个实验阶段，自此终于成为正式特性。</p>
<p>但是这并不是替换默认的GC，默认的GC仍然还是G1；之前需要通过<code>-XX:+UnlockExperimentalVMOptions</code>、<code> -XX:+UseZGC</code>来启用ZGC，现在只需要<code>-XX:+UseZGC</code>就可以。相信不久的将来它必将成为默认的垃圾回收器。</p>
<blockquote>
<p>ZGC的性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。未来将成为服务端、大内存、低延迟应用的首选垃圾收集器。</p>
</blockquote>
<p>怎么形容Shenandoah和ZGC的关系呢？异同点大概如下：</p>
<ul>
<li>相同点：性能几乎可认为是相同的</li>
<li>不同点：ZGC是Oracle JDK的，根正苗红。而Shenandoah只存在于OpenJDK中，因此使用时需注意你的JDK版本</li>
</ul>
<p><strong>JDK16：ZGC 并发线程处理</strong></p>
<p>在线程的堆栈处理过程中，总有一个制约因素就是safepoints。在safepoints这个点，Java的线程是要暂停执行的，从而限制了GC的效率。</p>
<blockquote>
<p>回顾：</p>
<p>我们都知道，在之前，需要 GC 的时候，为了进行垃圾回收，需要所有的线程都暂停下来，这个暂停的时间我们称为 <strong>Stop The World</strong>。</p>
<p>而为了实现 STW 这个操作， JVM 需要为每个线程选择一个点停止运行，这个点就叫做<strong>安全点（Safepoints）</strong>。</p>
</blockquote>
<p>而ZGC的并发线程堆栈处理可以保证Java线程可以在GC safepoints的同时可以并发执行。它有助于提高所开发的Java软件应用程序的性能和效率。  </p>
<h2 id="企业真题（十八）"><a href="#企业真题（十八）" class="headerlink" title="企业真题（十八）"></a>企业真题（十八）</h2><h3 id="1-JDK新特性的概述"><a href="#1-JDK新特性的概述" class="headerlink" title="1. JDK新特性的概述"></a>1. JDK新特性的概述</h3><ul>
<li><p>几个重要的版本</p>
<ul>
<li>jdk 5.0 &#x2F; jdk 8.0 ：里程碑式的版本</li>
<li>jdk9.0 开始每6个月发布一个新的版本</li>
<li>LTS : jdk8 、 jdk 11 、 jdk 17</li>
</ul>
</li>
<li><p>如何学习新特性</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; 角度1：新的语法规则 （多关注）</span><br><span class="line">  自动装箱、自动拆箱、注解、enum、Lambda表达式、方法引用、switch表达式、try-catch变化、record等</span><br><span class="line"></span><br><span class="line">&gt; 角度2：增加、过时、删除API</span><br><span class="line">  StringBuilder、ArrayList、新的日期时间的API、Optional等</span><br><span class="line"></span><br><span class="line">&gt; 角度3：底层的优化、JVM参数的调整、GC的变化、内存结构（永久代---&gt;元空间）</span><br></pre></td></tr></table></figure>

<h3 id="2-JDK8-lambda表达式"><a href="#2-JDK8-lambda表达式" class="headerlink" title="2. JDK8:lambda表达式"></a>2. JDK8:lambda表达式</h3><h4 id="2-1-什么情况下可以使用lambda表达式"><a href="#2-1-什么情况下可以使用lambda表达式" class="headerlink" title="2.1 什么情况下可以使用lambda表达式"></a>2.1 什么情况下可以使用lambda表达式</h4><ul>
<li>在给函数式接口提供实例时，都可以考虑使用lambda表达式。</li>
<li>基本语法的使用（重要）</li>
</ul>
<h4 id="2-2-函数式接口"><a href="#2-2-函数式接口" class="headerlink" title="2.2 函数式接口"></a>2.2 函数式接口</h4><ul>
<li><p>常见的函数式接口。Comparator \ Runnable \ java.util.function下定义的丰富的函数式接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">消费型接口：Consumer&lt;T&gt;     void accept(T t)</span><br><span class="line">供给型接口：Supplier&lt;T&gt;     T get()</span><br><span class="line">函数型接口：Function&lt;T,R&gt;   R apply(T t)</span><br><span class="line">判断型接口：Predicate&lt;T&gt;    boolean test(T t)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-3-方法引用、构造器引用、数组引用"><a href="#2-3-方法引用、构造器引用、数组引用" class="headerlink" title="2.3 方法引用、构造器引用、数组引用"></a>2.3 方法引用、构造器引用、数组引用</h4><ul>
<li><p>方法引用、构造器引用、数组引用：看做是lambda表达式的进一步刻画、表达。</p>
</li>
<li><p>（掌握）方法引用、构造器引用、数组引用的使用场景。</p>
</li>
</ul>
<h3 id="3-JDK8-Stream-API的使用"><a href="#3-JDK8-Stream-API的使用" class="headerlink" title="3. JDK8:Stream API的使用"></a>3. JDK8:Stream API的使用</h3><ul>
<li>Stream关注于内存中的多个数据的运算。</li>
<li>使用步骤：① Stream 的实例化 ② 一系列的中间操作 ③ 终止操作</li>
</ul>
<h3 id="4-JDK8之后的新特性：语法层面"><a href="#4-JDK8之后的新特性：语法层面" class="headerlink" title="4. JDK8之后的新特性：语法层面"></a>4. JDK8之后的新特性：语法层面</h3><ul>
<li>jShell工具</li>
<li>try-catch结构的变化。try(…){ }</li>
<li>局部变量的类型推断：var</li>
<li>instanceof的模式匹配</li>
<li>switch表达式、switch的模式匹配</li>
<li>文本块的使用：”””文本块”””</li>
<li>新的引用数据类型：record (记录)</li>
<li>密封类：sealed class</li>
</ul>
<h3 id="5-JDK8之后的新特性：其它"><a href="#5-JDK8之后的新特性：其它" class="headerlink" title="5. JDK8之后的新特性：其它"></a>5. JDK8之后的新特性：其它</h3><ul>
<li>Optional类的使用</li>
<li>其他：了解</li>
</ul>
<h2 id="二、企业真题"><a href="#二、企业真题" class="headerlink" title="二、企业真题"></a>二、企业真题</h2><h3 id="JDK8新特性"><a href="#JDK8新特性" class="headerlink" title="JDK8新特性"></a>JDK8新特性</h3><h4 id="1-谈谈java8新特性-京-旗下、时代-宇，信必-、招-信诺，中-外包，金-软件、阿-巴"><a href="#1-谈谈java8新特性-京-旗下、时代-宇，信必-、招-信诺，中-外包，金-软件、阿-巴" class="headerlink" title="1. 谈谈java8新特性(京*旗下、时代*宇，信必*、招*信诺，中*外包，金*软件、阿**巴)"></a>1. 谈谈java8新特性(京*旗下、时代*宇，信必*、招*信诺，中*外包，金*软件、阿**巴)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类似问题</span><br><span class="line">&gt; JDK1.8相较于JDK1.7有什么不一样？（惠*）</span><br><span class="line">&gt; JDK1.8的新特性有哪些？Stream API + Lambda表达式，还有吗？（久*国际物流）</span><br></pre></td></tr></table></figure>

<ul>
<li>lambda表达式、Stream API</li>
<li>jdk7的对比：元空间、HashMap、新的日期时间API、接口变化等。</li>
</ul>
<h4 id="2-JDK1-8在数据结构上发生了哪些变化-？（银-数据）"><a href="#2-JDK1-8在数据结构上发生了哪些变化-？（银-数据）" class="headerlink" title="2. JDK1.8在数据结构上发生了哪些变化 ？（银*数据）"></a>2. JDK1.8在数据结构上发生了哪些变化 ？（银*数据）</h4><ul>
<li>使用元空间替代永久代。  （方法区：jvm规范中提到的结构。  <ul>
<li>HotSpot来讲，jdk7：方法区的落地体现：永久代。 jdk8：方法区的落地体现：元空间。</li>
</ul>
</li>
<li>HashMap底层结构</li>
</ul>
<h4 id="3-你说的了解-Java的新特性-，你说说JDK8改进的地方？（银-科技）"><a href="#3-你说的了解-Java的新特性-，你说说JDK8改进的地方？（银-科技）" class="headerlink" title="3. 你说的了解 Java的新特性 ，你说说JDK8改进的地方？（银*科技）"></a>3. 你说的了解 Java的新特性 ，你说说JDK8改进的地方？（银*科技）</h4><p>略</p>
<h4 id="4-JDK1-8用的是哪个垃圾回收器？（O-O）"><a href="#4-JDK1-8用的是哪个垃圾回收器？（O-O）" class="headerlink" title="4. JDK1.8用的是哪个垃圾回收器？（O**O）"></a>4. JDK1.8用的是哪个垃圾回收器？（O**O）</h4><p>Parallel GC –&gt; jdk9：默认使用G1GC  –&gt; ZGC （低延迟）</p>
<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><h4 id="1-Lambda表达式有了解吗，说说如何使用的（O-O）"><a href="#1-Lambda表达式有了解吗，说说如何使用的（O-O）" class="headerlink" title="1. Lambda表达式有了解吗，说说如何使用的（O**O）"></a>1. Lambda表达式有了解吗，说说如何使用的（O**O）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类似问题：</span><br><span class="line">&gt; Lambda的理解（国*）</span><br></pre></td></tr></table></figure>

<p>略</p>
<h4 id="2-什么是函数式接口？有几种函数式接口（阿-巴）"><a href="#2-什么是函数式接口？有几种函数式接口（阿-巴）" class="headerlink" title="2. 什么是函数式接口？有几种函数式接口（阿**巴）"></a>2. 什么是函数式接口？有几种函数式接口（阿**巴）</h4><p>略。</p>
<p>java.util.function包下定义了丰富的好函数式接口。有4类基础的函数式接口：</p>
<p>消费型接口：Consumer<T>     void accept(T t)<br>供给型接口：Supplier<T>     T get()<br>函数型接口：Function&lt;T,R&gt;   R apply(T t)<br>判断型接口：Predicate<T>    boolean test(T t)</p>
<h3 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h3><h4 id="1-创建Stream的方式（阿-巴）"><a href="#1-创建Stream的方式（阿-巴）" class="headerlink" title="1. 创建Stream的方式（阿**巴）"></a>1. 创建Stream的方式（阿**巴）</h4><p>三种。</p>
<h4 id="2-你讲讲stream表达式是咋用的，干啥的？（中-国际，上海-网络）"><a href="#2-你讲讲stream表达式是咋用的，干啥的？（中-国际，上海-网络）" class="headerlink" title="2. 你讲讲stream表达式是咋用的，干啥的？（中*国际，上海**网络）"></a>2. 你讲讲stream表达式是咋用的，干啥的？（中*国际，上海**网络）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; Stream API 关注的是多个数据的计算（排序、查找、过滤、映射、遍历等），面向CPU的。</span><br><span class="line">  集合关注的数据的存储，面向内存的。</span><br><span class="line">&gt; Stream API 之于集合，类似于SQL之于数据表的查询。</span><br></pre></td></tr></table></figure>

<h4 id="3-集合用Stream流怎么实现过滤？（润-软件）"><a href="#3-集合用Stream流怎么实现过滤？（润-软件）" class="headerlink" title="3. 集合用Stream流怎么实现过滤？（润*软件）"></a>3. 集合用Stream流怎么实现过滤？（润*软件）</h4><p>filter(Predicate predicate)</p>
<h4 id="4-用Stream怎么选出List里想要的数据？（惠-）"><a href="#4-用Stream怎么选出List里想要的数据？（惠-）" class="headerlink" title="4. 用Stream怎么选出List里想要的数据？（惠*）"></a>4. 用Stream怎么选出List里想要的数据？（惠*）</h4><p>略</p>
<h3 id="其它版本新特性"><a href="#其它版本新特性" class="headerlink" title="其它版本新特性"></a>其它版本新特性</h3><h4 id="1-说说JDK15、JDK16、JDK17中的新特性都有什么？-银-数据"><a href="#1-说说JDK15、JDK16、JDK17中的新特性都有什么？-银-数据" class="headerlink" title="1. 说说JDK15、JDK16、JDK17中的新特性都有什么？(银*数据)"></a>1. 说说JDK15、JDK16、JDK17中的新特性都有什么？(银*数据)</h4><p>略</p>
<h2 id="IDEA的日常快捷键和Debug"><a href="#IDEA的日常快捷键和Debug" class="headerlink" title="IDEA的日常快捷键和Debug"></a>IDEA的日常快捷键和Debug</h2><h3 id="第1组：通用型"><a href="#第1组：通用型" class="headerlink" title="第1组：通用型"></a>第1组：通用型</h3><table>
<thead>
<tr>
<th>说明</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>复制代码-copy</td>
<td>ctrl + c</td>
</tr>
<tr>
<td>粘贴-paste</td>
<td>ctrl + v</td>
</tr>
<tr>
<td>剪切-cut</td>
<td>ctrl + x</td>
</tr>
<tr>
<td>撤销-undo</td>
<td>ctrl + z</td>
</tr>
<tr>
<td>反撤销-redo</td>
<td>ctrl + shift + z</td>
</tr>
<tr>
<td>保存-save all</td>
<td>ctrl + s</td>
</tr>
<tr>
<td>全选-select all</td>
<td>ctrl + a</td>
</tr>
</tbody></table>
<h3 id="第2组：提高编写速度（上）"><a href="#第2组：提高编写速度（上）" class="headerlink" title="第2组：提高编写速度（上）"></a>第2组：提高编写速度（上）</h3><table>
<thead>
<tr>
<th>说明</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>智能提示-edit</td>
<td>alt + enter</td>
</tr>
<tr>
<td>提示代码模板-insert live template</td>
<td>ctrl+j</td>
</tr>
<tr>
<td>使用xx块环绕-surround with …</td>
<td>ctrl+alt+t</td>
</tr>
<tr>
<td>调出生成getter&#x2F;setter&#x2F;构造器等结构-generate …</td>
<td>alt+insert</td>
</tr>
<tr>
<td>自动生成返回值变量-introduce variable …</td>
<td>ctrl+alt+v</td>
</tr>
<tr>
<td>复制指定行的代码-duplicate line or selection</td>
<td>ctrl+d</td>
</tr>
<tr>
<td>删除指定行的代码-delete line</td>
<td>ctrl+y</td>
</tr>
<tr>
<td>切换到下一行代码空位-start new line</td>
<td>shift + enter</td>
</tr>
<tr>
<td>切换到上一行代码空位-start new line before current</td>
<td>ctrl +alt+ enter</td>
</tr>
<tr>
<td>向上移动代码-move statement up</td>
<td>ctrl+shift+↑</td>
</tr>
<tr>
<td>向下移动代码-move statement down</td>
<td>ctrl+shift+↓</td>
</tr>
<tr>
<td>向上移动一行-move line up</td>
<td>alt+shift+↑</td>
</tr>
<tr>
<td>向下移动一行-move line down</td>
<td>alt+shift+↓</td>
</tr>
<tr>
<td>方法的形参列表提醒-parameter info</td>
<td>ctrl+p</td>
</tr>
</tbody></table>
<h3 id="第3组：提高编写速度（下）"><a href="#第3组：提高编写速度（下）" class="headerlink" title="第3组：提高编写速度（下）"></a>第3组：提高编写速度（下）</h3><table>
<thead>
<tr>
<th>说明</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>批量修改指定的变量名、方法名、类名等-rename</td>
<td>shift+f6</td>
</tr>
<tr>
<td>抽取代码重构方法-extract method …</td>
<td>ctrl+alt+m</td>
</tr>
<tr>
<td>重写父类的方法-override methods …</td>
<td>ctrl+o</td>
</tr>
<tr>
<td>实现接口的方法-implements methods …</td>
<td>ctrl+i</td>
</tr>
<tr>
<td>选中的结构的大小写的切换-toggle case</td>
<td>ctrl+shift+u</td>
</tr>
<tr>
<td>批量导包-optimize imports</td>
<td>ctrl+alt+o</td>
</tr>
</tbody></table>
<h3 id="第4组：类结构、查找和查看源码"><a href="#第4组：类结构、查找和查看源码" class="headerlink" title="第4组：类结构、查找和查看源码"></a>第4组：类结构、查找和查看源码</h3><table>
<thead>
<tr>
<th>说明</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>如何查看源码-go to class…</td>
<td>ctrl + 选中指定的结构 或 ctrl+n</td>
</tr>
<tr>
<td>显示当前类结构，支持搜索指定的方法、属性等-file structure</td>
<td>ctrl+f12</td>
</tr>
<tr>
<td>退回到前一个编辑的页面-back</td>
<td>ctrl+alt+←</td>
</tr>
<tr>
<td>进入到下一个编辑的页面-forward</td>
<td>ctrl+alt+→</td>
</tr>
<tr>
<td>打开的类文件之间切换-select previous&#x2F;next tab</td>
<td>alt+←&#x2F;→</td>
</tr>
<tr>
<td>光标选中指定的类，查看继承树结构-Type Hierarchy</td>
<td>ctrl+h</td>
</tr>
<tr>
<td>查看方法文档-quick documentation</td>
<td>ctrl+q</td>
</tr>
<tr>
<td>类的UML关系图-show uml popup</td>
<td>ctrl+alt+u</td>
</tr>
<tr>
<td>定位某行-go to line&#x2F;column</td>
<td>ctrl+g</td>
</tr>
<tr>
<td>回溯变量或方法的来源-go to implementation(s)</td>
<td>ctrl+alt+b</td>
</tr>
<tr>
<td>折叠方法实现-collapse all</td>
<td>ctrl+shift+ -</td>
</tr>
<tr>
<td>展开方法实现-expand all</td>
<td>ctrl+shift+ +</td>
</tr>
</tbody></table>
<h3 id="第5组：查找、替换与关闭"><a href="#第5组：查找、替换与关闭" class="headerlink" title="第5组：查找、替换与关闭"></a>第5组：查找、替换与关闭</h3><table>
<thead>
<tr>
<th>说明</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>查找指定的结构</td>
<td>ctlr+f</td>
</tr>
<tr>
<td>快速查找：选中的Word快速定位到下一个-find next</td>
<td>ctrl+l</td>
</tr>
<tr>
<td>查找与替换-replace</td>
<td>ctrl+r</td>
</tr>
<tr>
<td>直接定位到当前行的首位-move caret to line start</td>
<td>home</td>
</tr>
<tr>
<td>直接定位到当前行的末位 -move caret to line end</td>
<td>end</td>
</tr>
<tr>
<td>查询当前元素在当前文件中的引用，然后按 F3 可以选择</td>
<td>ctrl+f7</td>
</tr>
<tr>
<td>全项目搜索文本-find in path …</td>
<td>ctrl+shift+f</td>
</tr>
<tr>
<td>关闭当前窗口-close</td>
<td>ctrl+f4</td>
</tr>
</tbody></table>
<h3 id="第6组：调整格式"><a href="#第6组：调整格式" class="headerlink" title="第6组：调整格式"></a>第6组：调整格式</h3><table>
<thead>
<tr>
<th>说明</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>格式化代码-reformat code</td>
<td>ctrl+alt+l</td>
</tr>
<tr>
<td>使用单行注释-comment with line comment</td>
<td>ctrl + &#x2F;</td>
</tr>
<tr>
<td>使用&#x2F;取消多行注释-comment with block comment</td>
<td>ctrl + shift + &#x2F;</td>
</tr>
<tr>
<td>选中数行，整体往后移动-tab</td>
<td>tab</td>
</tr>
<tr>
<td>选中数行，整体往前移动-prev tab</td>
<td>shift + tab</td>
</tr>
</tbody></table>
<h3 id="Debug快捷键"><a href="#Debug快捷键" class="headerlink" title="Debug快捷键"></a>Debug快捷键</h3><table>
<thead>
<tr>
<th>说明</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>单步调试（不进入函数内部）- step over</td>
<td>F8</td>
</tr>
<tr>
<td>单步调试（进入函数内部）- step into</td>
<td>F7</td>
</tr>
<tr>
<td>强制单步调试（进入函数内部） - force step into</td>
<td>alt+shift+f7</td>
</tr>
<tr>
<td>选择要进入的函数 - smart step into</td>
<td>shift + F7</td>
</tr>
<tr>
<td>跳出函数 - step out</td>
<td>shift + F8</td>
</tr>
<tr>
<td>运行到断点 - run to cursor</td>
<td>alt + F9</td>
</tr>
<tr>
<td>继续执行，进入下一个断点或执行完程序 - resume program</td>
<td>F9</td>
</tr>
<tr>
<td>停止 - stop</td>
<td>Ctrl+F2</td>
</tr>
<tr>
<td>查看断点 - view breakpoints</td>
<td>Ctrl+Shift+F8</td>
</tr>
<tr>
<td>关闭 - close</td>
<td>Ctrl+F4</td>
</tr>
</tbody></table>
<h1 id="面试题整理"><a href="#面试题整理" class="headerlink" title="面试题整理"></a>面试题整理</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2>
        
            <div id="toc-article">
                
  <div class="widget-wrap" id="toc-wrap">
    <h3 class="widget-title"><i class="fa fa-toc"></i> Contents</h3>
    <div class="widget">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="toc-text">Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">Java程序编写和执行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89"><span class="toc-text">企业真题（一）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%80%E4%B8%AA%E2%80%9D-java%E2%80%9D%E6%BA%90%E6%96%87%E4%BB%B6%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%8C%85%E6%8B%AC%E5%A4%9A%E4%B8%AA%E7%B1%BB%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E9%99%90%E5%88%B6-%E6%98%8E-%E6%95%B0%E6%8D%AE"><span class="toc-text">1.一个”.java”源文件中是否可以包括多个类？有什么限制(明*数据)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Java-%E7%9A%84%E4%BC%98%E5%8A%BF%EF%BC%88%E9%98%BF-%E5%B7%B4%EF%BC%89"><span class="toc-text">2.Java 的优势（阿**巴）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E4%B8%AA%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-%E8%87%B3%E5%B0%914%E4%B8%AA-%EF%BC%88%E5%8C%97%E4%BA%AC%E6%95%B0%E5%AD%97-%EF%BC%89"><span class="toc-text">3.常用的几个命令行操作都有哪些？(至少4个)（北京数字**）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Java-%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E3%80%81%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%EF%BC%88%E6%8B%BC-%E5%A4%9A%EF%BC%89"><span class="toc-text">4.Java 中是否存在内存溢出、内存泄漏？如何解决？举例说明（拼*多）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85Java%E6%98%AF%E4%B8%80%E9%97%A8%E5%8D%8A%E7%BC%96%E8%AF%91%E5%8D%8A%E8%A7%A3%E9%87%8A%E5%9E%8B%E7%9A%84%E8%AF%AD%E8%A8%80%EF%BC%88%E6%90%BA-%EF%BC%89"><span class="toc-text">5. 如何看待Java是一门半编译半解释型的语言（携*）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-text">标识符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-text">变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%EF%BC%9Abyte%E3%80%81short%E3%80%81int%E3%80%81long"><span class="toc-text">整数类型：byte、short、int、long</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B%EF%BC%9Afloat%E3%80%81double"><span class="toc-text">浮点类型：float、double</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B%EF%BC%9Achar"><span class="toc-text">字符类型：char</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%EF%BC%9Aboolean"><span class="toc-text">布尔类型：boolean</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E9%97%B4%E8%BF%90%E7%AE%97%E8%A7%84%E5%88%99"><span class="toc-text">基本数据类型变量间运算规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E6%8F%90%E5%8D%87"><span class="toc-text">自动类型提升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">强制类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E-String-%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-text">基本数据类型与 String 的运算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%AF%86%EF%BC%9A%E8%BF%9B%E5%88%B6%E7%9A%84%E8%AE%A4%E8%AF%86"><span class="toc-text">常识：进制的认识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">算术运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">赋值运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">比较运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6-%E4%BA%86%E8%A7%A3"><span class="toc-text">位运算符(了解)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">条件运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89"><span class="toc-text">企业真题（二）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%AB%98%E6%95%88%E7%9A%84%E6%96%B9%E5%BC%8F%E8%AE%A1%E7%AE%972-8%E7%9A%84%E5%80%BC-%E6%96%87-%E8%BE%89%E3%80%81%E8%BD%AE-%E7%A7%91%E6%8A%80"><span class="toc-text">1. 高效的方式计算2 * 8的值 (文**辉、轮*科技)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-amp-%E5%92%8C-amp-amp-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F-%E6%81%92-%E7%94%B5%E5%AD%90%E3%80%81-%E5%BA%A6"><span class="toc-text">2. &amp;和&amp;&amp;的区别？(恒*电子、*度)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Java%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9FString-%E6%98%AF%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%90%97%EF%BC%9F-%E6%81%92-%E7%94%B5%E5%AD%90"><span class="toc-text">3. Java中的基本类型有哪些？String 是最基本的数据类型吗？(恒*电子)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Java%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%EF%BC%9F%EF%BC%88-%E7%B1%B3%EF%BC%89"><span class="toc-text">4. Java中的基本数据类型包括哪些？（*米）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Java%E5%BC%80%E5%8F%91%E4%B8%AD%E8%AE%A1%E7%AE%97%E9%87%91%E9%A2%9D%E6%97%B6%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F%EF%BC%885-%E5%88%B0%E5%AE%B6%EF%BC%89"><span class="toc-text">5. Java开发中计算金额时使用什么数据类型？（5*到家）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-char%E5%9E%8B%E5%8F%98%E9%87%8F%E4%B8%AD%E8%83%BD%E4%B8%8D%E8%83%BD%E5%AD%98%E5%82%A8%E4%B8%80%E4%B8%AA%E4%B8%AD%E6%96%87%E6%B1%89%E5%AD%97%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F-%E9%80%9A%E5%BF%AB%E9%80%92"><span class="toc-text">6. char型变量中能不能存储一个中文汉字，为什么？(*通快递)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-%E5%90%9B-%E7%A7%91%E6%8A%80%E3%80%81%E6%96%B0-%E9%99%86"><span class="toc-text">7. 代码分析(君*科技、新*陆)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-int-i-x3D-0-i-x3D-i-%E6%89%A7%E8%A1%8C%E8%BF%99%E4%B8%A4%E5%8F%A5%E5%8C%96%E5%90%8E%E5%8F%98%E9%87%8F-i-%E7%9A%84%E5%80%BC%E4%B8%BA%EF%BC%88-%E8%BD%AF%EF%BC%89"><span class="toc-text">8. int i&#x3D;0; i&#x3D;i++执行这两句化后变量 i 的值为（*软）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%A6%82%E4%BD%95%E5%B0%86%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC%E4%BA%92%E6%8D%A2%EF%BC%88%E5%8C%97%E4%BA%AC-%E5%BD%A9%E3%80%81%E4%B8%AD%E5%A4%96-%E8%AF%91%E5%92%A8%E8%AF%A2%EF%BC%89"><span class="toc-text">9. 如何将两个变量的值互换（北京*彩、中外*译咨询）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-boolean-%E5%8D%A0%E5%87%A0%E4%B8%AA%E5%AD%97%E8%8A%82%EF%BC%88%E9%98%BF-%E5%B7%B4%EF%BC%89"><span class="toc-text">10. boolean 占几个字节（阿**巴）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E4%B8%BA%E4%BB%80%E4%B9%88Java%E4%B8%AD0-1-0-2%E7%BB%93%E6%9E%9C%E4%B8%8D%E6%98%AF0-3%EF%BC%9F%EF%BC%88%E5%AD%97-%E8%B7%B3%E5%8A%A8%EF%BC%89"><span class="toc-text">11. 为什么Java中0.1 + 0.2结果不是0.3？（字*跳动）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84"><span class="toc-text">分支结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#if-else"><span class="toc-text">if-else</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch-case"><span class="toc-text">switch-case</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="toc-text">循环结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#for"><span class="toc-text">for</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#while"><span class="toc-text">while</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#do-while"><span class="toc-text">do-while</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#break%E5%92%8Ccontinue"><span class="toc-text">break和continue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Math%E7%B1%BB%E7%9A%84random"><span class="toc-text">Math类的random()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E4%B8%89%EF%BC%89"><span class="toc-text">企业真题（三）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-break%E5%92%8Ccontinue%E7%9A%84%E4%BD%9C%E7%94%A8-%E6%99%BA-%E5%9B%BE"><span class="toc-text">1. break和continue的作用(智*图)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-if%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E5%92%8Cswitch%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%BC%82%E5%90%8C%E4%B9%8B%E5%A4%84-%E6%99%BA-%E5%9B%BE"><span class="toc-text">2. if分支语句和switch分支语句的异同之处(智*图)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E8%AF%AD%E5%8F%A5if%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%80%89%E7%94%A8%E8%AF%AD%E5%8F%A5switch-%E7%81%B5%E4%BC%B4-%E6%9D%A5%E7%A7%91%E6%8A%80"><span class="toc-text">3. 什么时候用语句if，什么时候选用语句switch(灵伴*来科技)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-switch%E8%AF%AD%E5%8F%A5%E4%B8%AD%E5%BF%98%E5%86%99break%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88-%E5%8C%97%E4%BA%AC-%E8%93%9D"><span class="toc-text">4. switch语句中忘写break会发生什么(北京*蓝)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Java%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%E5%BE%AA%E7%8E%AF-%E4%B8%8A%E6%B5%B7-%E7%9D%BF"><span class="toc-text">5. Java支持哪些类型循环(上海*睿)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-while%E5%92%8Cdo-while%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB-%E5%9B%BD-%E7%A7%91%E6%8A%80%E7%A0%94%E7%A9%B6%E9%99%A2"><span class="toc-text">6. while和do while循环的区别(国*科技研究院)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IDEA%E7%9A%84%E8%AE%A4%E8%AF%86"><span class="toc-text">IDEA的认识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%9B%9B%EF%BC%89"><span class="toc-text">企业真题（四）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BC%80%E5%8F%91%E4%B8%AD%E4%BD%A0%E6%8E%A5%E8%A7%A6%E8%BF%87%E7%9A%84%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">1. 开发中你接触过的开发工具都有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9Eclipse%E5%92%8CIDEA%E4%BD%BF%E7%94%A8%E4%B8%8A%E7%9A%84%E6%84%9F%E5%8F%97%EF%BC%9F"><span class="toc-text">2. 谈谈你对Eclipse和IDEA使用上的感受？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-text">数组的概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-text">一维数组的使用（重要）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E9%9A%BE%E7%82%B9%EF%BC%89"><span class="toc-text">二维数组的使用（难点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-text">数组的常用算法（重要）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Arrays%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">Arrays工具类的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8"><span class="toc-text">数组中的常见异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E4%BA%94%EF%BC%89"><span class="toc-text">企业真题（五）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84%E6%9C%89%E6%B2%A1%E6%9C%89length-%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95-String%E6%9C%89%E6%B2%A1%E6%9C%89length-%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%9F%EF%BC%88-%E8%93%9D%EF%BC%89"><span class="toc-text">1. 数组有没有length()这个方法? String有没有length()这个方法？（*蓝）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9C%89%E6%95%B0%E7%BB%84int-arr%EF%BC%8C%E7%94%A8Java%E4%BB%A3%E7%A0%81%E5%B0%86%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E9%A1%BA%E5%BA%8F%E9%A2%A0%E5%80%92%EF%BC%88%E9%97%AA-%E8%B4%AD%EF%BC%89"><span class="toc-text">2. 有数组int[] arr，用Java代码将数组元素顺序颠倒（闪*购）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%B0%E7%BB%84%E8%A6%81%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%BC%96%E5%8F%B7%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF1-%E4%B8%AD-%E6%94%AF%E4%BB%98"><span class="toc-text">3. 为什么数组要从0开始编号，而不是1(中*支付)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%95%B0%E7%BB%84%E6%9C%89%E4%BB%80%E4%B9%88%E6%8E%92%E5%BA%8F%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%8B%EF%BC%88%E5%B9%B3-%E4%BF%9D%E9%99%A9%EF%BC%89"><span class="toc-text">4. 数组有什么排序的方式，手写一下（平*保险）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%8C%E8%AF%B4%E4%B8%8B%E5%BF%AB%E6%8E%92%E8%BF%87%E7%A8%8B%EF%BC%8C%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9F%EF%BC%885-%E5%88%B0%E5%AE%B6%EF%BC%89"><span class="toc-text">5. 常见排序算法，说下快排过程，时间复杂度？（5*到家）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE%EF%BC%88%E7%A5%9E%E8%88%9F-%E5%A4%A9%E8%BD%AF%E4%BB%B6%EF%BC%89"><span class="toc-text">6. 二分算法实现数组的查找（神舟*天软件）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%80%8E%E4%B9%88%E6%B1%82%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C%EF%BC%88%E6%90%BA-%EF%BC%89"><span class="toc-text">7. 怎么求数组的最大子序列和（携*）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Arrays-%E7%B1%BB%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%9A%84%EF%BC%9F%EF%BC%88%E9%98%BF-%E3%80%81%E9%98%BF-%E6%A0%A1%E6%8B%9B%EF%BC%89"><span class="toc-text">8. Arrays 类的排序方法是什么？如何实现排序的？（阿*、阿*校招）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%9F%BA%E7%A1%80"><span class="toc-text">面向对象-基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B-vs-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">面向过程 vs 面向对象（了解）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1"><span class="toc-text">类、对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%B1%9E%E6%80%A7%EF%BC%88%E6%88%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%89"><span class="toc-text">类的成员之一：属性（或成员变量）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%96%B9%E6%B3%95"><span class="toc-text">类的成员之二：方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%8D%E8%B0%88%E6%96%B9%E6%B3%95"><span class="toc-text">再谈方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD-overload"><span class="toc-text">方法的重载(overload)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E4%B8%AA%E6%95%B0%E5%BD%A2%E5%8F%82%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">可变个数形参的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%80%BC%E4%BC%A0%E9%80%92-%E9%87%8D%E7%82%B9%E3%80%81%E9%9A%BE%E7%82%B9"><span class="toc-text">方法的参数传递机制：值传递(重点、难点)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95"><span class="toc-text">递归方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84"><span class="toc-text">对象数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#package%E3%80%81import%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">package、import关键字的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#oop%E7%9A%84%E7%89%B9%E5%BE%81%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%B0%81%E8%A3%85%E6%80%A7"><span class="toc-text">oop的特征之一：封装性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E4%B9%8B%E4%B8%89%EF%BC%9A%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">类的成员之三：构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E5%B0%8F%E7%9F%A5%E8%AF%86"><span class="toc-text">三个小知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%B5%8B%E5%80%BC%E8%BF%87%E7%A8%8B%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-text">类的实例变量的赋值过程（重要）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JavaBean"><span class="toc-text">JavaBean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UML%E7%B1%BB%E5%9B%BE"><span class="toc-text">UML类图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%85%AD%EF%BC%89"><span class="toc-text">企业真题（六）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-text">2.1 类与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%EF%BC%88%E5%B9%B3-%E9%87%91%E6%9C%8D%E3%80%81%E8%8B%B1-%E8%BE%BE%EF%BC%89"><span class="toc-text">1. 面向对象，面向过程的理解？（平*金服、英**达）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Java-%E7%9A%84%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%88%E9%98%BF-%E6%A0%A1%E6%8B%9B%EF%BC%89"><span class="toc-text">2. Java 的引用类型有哪几种（阿*校招）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E5%87%A1-%E7%A7%91%E6%8A%80%E3%80%81%E4%B8%8A-%E9%93%B6%E8%A1%8C%EF%BC%89"><span class="toc-text">3. 类和对象的区别（凡*科技、上*银行）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%BD%A0%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%EF%BC%8C%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%E7%94%A8%E5%88%B0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9F%EF%BC%88%E7%87%95-%E9%87%91%E8%9E%8D%EF%BC%89"><span class="toc-text">4. 面向对象，你解释一下，项目中哪些地方用到面向对象？（燕*金融）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Java%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-text">2.2 Java内存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E5%86%85%E5%AD%98%E5%88%92%E5%88%86%E4%B8%BA%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%9F%9F%EF%BC%8C%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%EF%BC%88%E7%A5%9E-%E5%B2%B3%E3%80%81%E6%95%B0-%E4%BA%92%E8%9E%8D%EF%BC%89"><span class="toc-text">1. Java虚拟机中内存划分为哪些区域，详细介绍一下（神**岳、数*互融）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%9C%A8Java%E5%86%85%E5%AD%98%E7%9A%84%E5%93%AA%E5%9D%97%E5%8C%BA%E5%9F%9F%E9%87%8C%E9%9D%A2%EF%BC%9F%EF%BC%88%E9%98%BF-%EF%BC%89"><span class="toc-text">2. 对象存在Java内存的哪块区域里面？（阿*）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%88%E5%B0%81%E8%A3%85%E6%80%A7%EF%BC%89"><span class="toc-text">2.3 权限修饰符（封装性）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-private-%E3%80%81%E7%BC%BA%E7%9C%81%E3%80%81protected%E3%80%81public%E7%9A%84%E8%A1%A8%E6%A0%BC%E5%8C%96%E4%BD%9C%E7%94%A8%E5%8C%BA%E5%9F%9F%EF%BC%88%E7%88%B1-%E4%BF%A1%E3%80%81%E6%8B%93-%E6%80%9D%E3%80%81%E4%B8%AD-%E7%91%9E%E9%A3%9E%EF%BC%89"><span class="toc-text">1. private 、缺省、protected、public的表格化作用区域（爱*信、拓*思、中*瑞飞）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-main%E6%96%B9%E6%B3%95%E7%9A%84public%E8%83%BD%E4%B8%8D%E8%83%BD%E6%8D%A2%E6%88%90private%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E5%87%A1-%E7%A7%91%E6%8A%80%E3%80%81%E9%A1%BA-%EF%BC%89"><span class="toc-text">2. main方法的public能不能换成private？为什么？（凡*科技、顺*）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">2.4 构造器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%92%8C%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E5%87%A1-%E7%A7%91%E6%8A%80%E3%80%81%E8%BD%AF-%E5%8A%A8%E5%8A%9B%E3%80%81%E4%B8%AD-%E8%BD%AF%EF%BC%89"><span class="toc-text">1. 构造方法和普通方法的区别（凡*科技、软*动力、中*软）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9E%84%E9%80%A0%E5%99%A8Constructor%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%ABoverload-%EF%BC%88%E9%B8%BF-%E7%BD%91%E7%BB%9C%EF%BC%89"><span class="toc-text">2. 构造器Constructor是否可被overload?（鸿*网络）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E5%99%A8%E5%92%8C%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%BA%94%E7%94%A8%EF%BC%88%E5%8C%97%E4%BA%AC%E6%A5%9A-%E9%BE%99%EF%BC%89"><span class="toc-text">3. 无参构造器和有参构造器的的作用和应用（北京楚*龙）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%B1%9E%E6%80%A7%E5%8F%8A%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%E9%A1%BA%E5%BA%8F"><span class="toc-text">2.5 属性及属性赋值顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E8%89%BE-%E8%BD%AF%E4%BB%B6%EF%BC%89"><span class="toc-text">1. 成员变量与局部变量的区别（艾*软件）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC%E5%92%8C%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%8A%A0%E8%BD%BD%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98%EF%BC%88%E5%87%A1-%E7%A7%91%E6%8A%80%E3%80%81%E5%8D%9A-%E8%BD%AF%E4%BB%B6%EF%BC%89"><span class="toc-text">2. 变量赋值和构造方法加载的优先级问题（凡*科技、博*软件）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E8%BF%9B%E9%98%B6"><span class="toc-text">面向对象-进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">this关键字的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81%E4%BA%8C%EF%BC%9A%E7%BB%A7%E6%89%BF%E6%80%A7"><span class="toc-text">面向对象的特征二：继承性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99%EF%BC%88override-x2F-overwrite%EF%BC%89"><span class="toc-text">方法的重写（override &#x2F; overwrite）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">super关键字的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E7%86%9F%E6%82%89%EF%BC%89%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B"><span class="toc-text">（熟悉）子类对象实例化的全过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81%E4%B8%89%EF%BC%9A%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-text">面向对象的特征三：多态性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">Object类的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98-%E4%B8%83"><span class="toc-text">企业真题(七)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%BB%A7%E6%89%BF%E6%80%A7"><span class="toc-text">2.1 继承性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%88%B6%E7%B1%BB%E5%93%AA%E4%BA%9B%E6%88%90%E5%91%98%E5%8F%AF%E4%BB%A5%E8%A2%AB%E7%BB%A7%E6%89%BF%EF%BC%8C%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E8%A2%AB%E7%BB%A7%E6%89%BF%E5%90%97%EF%BC%9F%E5%8F%AF%E4%BB%A5%E6%88%96%E8%80%85%E4%B8%8D%E5%8F%AF%E4%BB%A5%EF%BC%8C%E8%AF%B7%E4%B8%BE%E4%B8%8B%E4%BE%8B%E5%AD%90%E3%80%82%EF%BC%88%E5%8C%97%E4%BA%AC%E6%98%8E-%E4%BF%A1%EF%BC%89"><span class="toc-text">1. 父类哪些成员可以被继承，属性可以被继承吗？可以或者不可以，请举下例子。（北京明**信）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E9%87%8D%E5%86%99"><span class="toc-text">2.2 重写</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFOverride%EF%BC%8C%E4%B8%8EOverload%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E9%A1%BA-%E3%80%81%E8%BD%AF-%E5%8A%9B%E3%80%81%E6%98%8E-%E6%95%B0%E6%8D%AE%E3%80%81%E9%98%B3-%E7%A7%91%E6%8A%80%E3%80%81%E4%B8%AD-%E8%BD%AF%EF%BC%89"><span class="toc-text">1. 什么是Override，与Overload的区别（顺*、软**力、明*数据、阳*科技、中*软）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Overload%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E7%B1%BB%E5%9E%8B-%EF%BC%88%E6%96%B0-%E9%99%86%EF%BC%89"><span class="toc-text">2. Overload的方法是否可以改变返回值的类型?（新*陆）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%9E%84%E9%80%A0%E5%99%A8Constructor%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%ABoverride-%EF%BC%88%E9%B8%BF-%E7%BD%91%E7%BB%9C%E3%80%81%E6%B7%B1%E5%9C%B3%E5%BE%B7-%E6%8A%80%E3%80%81%E8%88%AA-%E6%99%AE%EF%BC%89"><span class="toc-text">3. 构造器Constructor是否可被override?（鸿*网络、深圳德**技、航**普）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E9%87%8D%E8%BD%BD%EF%BC%8C%E6%88%91%E9%9A%8F%E4%BE%BF%E5%91%BD%E5%90%8D%E4%B8%80%E4%B8%AA%E5%88%AB%E7%9A%84%E5%87%BD%E6%95%B0%E5%90%8D%E4%B8%8D%E8%A1%8C%E5%90%97%EF%BC%9F%E8%B0%88%E8%B0%88%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E7%9A%84%E3%80%82%EF%BC%88%E8%85%BE-%EF%BC%89"><span class="toc-text">4. 为什么要有重载，我随便命名一个别的函数名不行吗？谈谈你是怎么理解的。（腾*）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">2.3 super关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-super%E5%92%8Cthis%E7%9A%84%E5%8C%BA%E5%88%AB-%E8%9A%82-%E6%9C%8D"><span class="toc-text">1. super和this的区别(蚂**服)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-this%E3%80%81super%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%86%E5%88%AB%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88-%E4%BB%A5%E5%8F%8A%E4%BB%96%E4%BB%AC%E5%90%84%E8%87%AA%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E4%BD%9C%E7%94%A8%E3%80%82%EF%BC%88%E5%8C%97%E4%BA%AC%E6%A5%9A-%E9%BE%99%EF%BC%89"><span class="toc-text">2. this、super关键字分别代表什么?以及他们各自的使用场景和作用。（北京楚*龙）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%A4%9A%E6%80%81"><span class="toc-text">2.4 多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E5%A4%9A%E6%80%81%E7%9A%84%E7%90%86%E8%A7%A3-%E4%B8%89-%E9%87%8D%E5%B7%A5%E3%80%81%E6%B1%9F-%E6%99%BA%E8%83%BD%E3%80%81%E9%93%B6-%E6%95%B0%E6%8D%AE%E3%80%81%E5%90%9B-%E7%A7%91%E6%8A%80"><span class="toc-text">1. 谈谈你对多态的理解(三*重工、江*智能、银*数据、君*科技)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A4%9A%E6%80%81new%E5%87%BA%E6%9D%A5%E7%9A%84%E5%AF%B9%E8%B1%A1%E8%B7%9F%E4%B8%8D%E5%A4%9A%E6%80%81new%E5%87%BA%E6%9D%A5%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%8C%BA%E5%88%AB%E5%9C%A8%E5%93%AA%EF%BC%9F%EF%BC%88%E4%B8%87-%E6%99%BA%E8%83%BD%EF%BC%89"><span class="toc-text">2. 多态new出来的对象跟不多态new出来的对象区别在哪？（万*智能）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E8%AE%A4%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9C%A8%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E4%BD%93%E7%8E%B0%EF%BC%88%E6%A5%9A-%E9%BE%99%EF%BC%89"><span class="toc-text">3. 说说你认为多态在代码中的体现（楚*龙）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-Object%E7%B1%BB"><span class="toc-text">2.5 Object类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-x3D-x3D-%E4%B8%8Eequals%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E6%8B%93-%E6%80%9D%EF%BC%89"><span class="toc-text">1. &#x3D;&#x3D;与equals的区别（拓*思）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E5%AE%89-%E7%BD%91%E7%BB%9C%E7%A7%91%E6%8A%80%EF%BC%89"><span class="toc-text">2. 重写equals方法要注意什么？（安**网络科技）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Java%E4%B8%AD%E6%89%80%E6%9C%89%E7%B1%BB%E7%9A%84%E7%88%B6%E7%B1%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BB%96%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%EF%BC%9F%EF%BC%88%E9%98%BF-%E6%A0%A1%E6%8B%9B%EF%BC%89"><span class="toc-text">3. Java中所有类的父类是什么？他都有什么方法？（阿*校招）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E9%AB%98%E7%BA%A7"><span class="toc-text">面向对象-高级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9Astatic"><span class="toc-text">关键字：static</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%88%96%E5%8D%95%E5%AD%90%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-text">单例模式（或单子模式）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3main-%E6%96%B9%E6%B3%95"><span class="toc-text">理解main()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E4%B9%8B%E5%9B%9B%EF%BC%9A%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">类的成员之四：代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9Afinal"><span class="toc-text">关键字：final</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9Aabstract"><span class="toc-text">关键字：abstract</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9Ainterface"><span class="toc-text">关键字：interface</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E4%B9%8B%E4%BA%94%EF%BC%9A%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">类的成员之五：内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%EF%BC%9Aenum"><span class="toc-text">枚举类：enum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3-Annotation"><span class="toc-text">注解:Annotation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">包装类的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%85%AB%EF%BC%89"><span class="toc-text">企业真题（八）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">2.1 static关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88%E4%BF%9D-%E4%B8%B0%E3%80%81-%E8%BD%AF%E5%9B%BD%E9%99%85%E3%80%81-%E8%BD%AF%E5%8D%8E-%E3%80%81%E5%8C%97%E4%BA%AC%E6%98%8E-%E4%BF%A1%EF%BC%89"><span class="toc-text">1. 静态变量和实例变量的区别？（保*丰、*软国际、*软华*、北京明**信）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E7%BB%A7%E6%89%BF%EF%BC%9F%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E5%86%99%EF%BC%9F%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9B%A0%EF%BC%9F%EF%BC%88-%E5%BA%A6%EF%BC%89"><span class="toc-text">2. 静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？（*度）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E4%BB%8E%E4%B8%80%E4%B8%AAstatic%E6%96%B9%E6%B3%95%E5%86%85%E9%83%A8%E5%8F%91%E5%87%BA%E5%AF%B9%E9%9D%9Estatic%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%EF%BC%9F%EF%BC%88%E5%90%8C-%E9%A1%BA%EF%BC%89"><span class="toc-text">3. 是否可以从一个static方法内部发出对非static方法的调用？（同*顺）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%A2%ABstatic%E4%BF%AE%E9%A5%B0%E7%9A%84%E6%88%90%E5%91%98-%E7%B1%BB%E3%80%81%E6%96%B9%E6%B3%95%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-%E8%83%BD%E5%90%A6%E5%86%8D%E4%BD%BF%E7%94%A8private%E8%BF%9B%E8%A1%8C%E4%BF%AE%E9%A5%B0%EF%BC%9F%EF%BC%88%E8%81%94-%E4%BC%98%E5%8A%BF%EF%BC%89"><span class="toc-text">4. 被static修饰的成员(类、方法、成员变量)能否再使用private进行修饰？（联*优势）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.2 设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F%EF%BC%88-%E9%80%9A%E5%BF%AB%E9%80%92%E3%80%81%E8%9A%82-%E6%9C%8D%EF%BC%89"><span class="toc-text">1. 知道哪些设计模式？（*通快递、蚂**服）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BC%80%E5%8F%91%E4%B8%AD%E9%83%BD%E7%94%A8%E5%88%B0%E4%BA%86%E9%82%A3%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%94%A8%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%BA%E5%90%88-%EF%BC%88%E4%B9%85-%E5%9B%BD%E9%99%85%E7%89%A9%E6%B5%81%EF%BC%89"><span class="toc-text">2. 开发中都用到了那些设计模式?用在什么场合? （久*国际物流）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-main"><span class="toc-text">2.3 main()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-main-%E6%96%B9%E6%B3%95%E7%9A%84public%E8%83%BD%E4%B8%8D%E8%83%BD%E6%8D%A2%E6%88%90private%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%88%E5%87%A1-%E7%A7%91%E6%8A%80%E3%80%81%E9%A1%BA-%EF%BC%89"><span class="toc-text">1. main()方法的public能不能换成private，为什么（凡*科技、顺*）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-main-%E6%96%B9%E6%B3%95%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%9F%EF%BC%88%E6%B5%A9-%E7%A7%91%E6%8A%80%EF%BC%89"><span class="toc-text">2. main()方法中是否可以调用非静态方法？（浩*科技）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">2.4 代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%B1%BB%E7%9A%84%E7%BB%84%E6%88%90%E5%92%8C%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F-%EF%BC%88%E8%88%AA-%E6%8B%93%E6%99%AE%EF%BC%89"><span class="toc-text">1. 类的组成和属性赋值执行顺序?（航*拓普）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%8C%E6%99%AE%E9%80%9A%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%8C%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%8C%E4%BB%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%BC%80%E5%A7%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F%EF%BC%88%E6%81%92-%E7%94%B5%E5%AD%90%EF%BC%89"><span class="toc-text">2. 静态代码块，普通代码块，构造方法，从类加载开始的执行顺序？（恒*电子）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">2.5 final关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B%E5%AF%B9final%E7%90%86%E8%A7%A3%EF%BC%88%E5%8D%8E-%E5%8D%9A%E6%99%AE%EF%BC%89"><span class="toc-text">1. 描述一下对final理解（华**博普）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%A4%E6%96%AD%E9%A2%98%EF%BC%9A%E4%BD%BF%E7%94%A8final%E4%BF%AE%E9%A5%B0%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E6%97%B6%EF%BC%8C%E6%98%AF%E5%BC%95%E7%94%A8%E4%B8%8D%E8%83%BD%E6%94%B9%E5%8F%98%EF%BC%8C%E5%BC%95%E7%94%A8%E6%8C%87%E5%90%91%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98%EF%BC%9F%EF%BC%88-%E7%B1%B3%EF%BC%89"><span class="toc-text">2. 判断题：使用final修饰一个变量时，是引用不能改变，引用指向的对象可以改变？（*米）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%A4%E6%96%AD%E9%A2%98%EF%BC%9Afinal%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BA%8E%E4%BF%AE%E9%A5%B0%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%9F%EF%BC%88%E8%81%94-%E4%BC%98%E5%8A%BF%EF%BC%89"><span class="toc-text">3. 判断题：final不能用于修饰构造方法？（联*优势）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-final%E6%88%96static-final-%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%8C%E8%83%BD%E4%B8%8D%E8%83%BD%E8%BF%9B%E8%A1%8C-%E6%93%8D%E4%BD%9C%EF%BC%9F%EF%BC%88%E4%BD%B3-%E8%B4%B8%E6%98%93%EF%BC%89"><span class="toc-text">4. final或static final 修饰成员变量，能不能进行++操作？（佳*贸易）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3"><span class="toc-text">2.6 抽象类与接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E4%B8%80%E4%B8%AA%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%9F%EF%BC%88%E6%98%93-%E6%94%AF%E4%BB%98%EF%BC%89"><span class="toc-text">1. 什么是抽象类？如何识别一个抽象类？（易*支付）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%94%A8abstract%E4%BF%AE%E9%A5%B0%E5%B1%9E%E6%80%A7%E3%80%81%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E3%80%81%E6%9E%84%E9%80%A0%E5%99%A8%E3%80%81%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E3%80%81final%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F%EF%BC%88%E6%AD%A2-%E5%96%84%EF%BC%89"><span class="toc-text">2. 为什么不能用abstract修饰属性、私有方法、构造器、静态方法、final的方法？（止**善）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88%E5%AD%97-%E8%B7%B3%E5%8A%A8%E3%80%81%E9%98%BF-%E6%A0%A1%E6%8B%9B%E3%80%81-%E5%BA%A6%E6%A0%A1%E6%8B%9B%E3%80%81-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8%E7%A0%94%E7%A9%B6%E6%89%80%E3%80%81%E8%88%AA-%E6%8B%93%E6%99%AE%E3%80%81%E7%BA%AC-%E3%80%81%E6%8B%9B-%E6%99%9F%E3%80%81%E6%B1%87-%E4%BA%91%E9%80%9A%E3%80%81%E6%95%B0%E4%BF%A1-%E7%A7%91%E6%8A%80%E3%80%81%E5%8C%97%E4%BA%AC%E6%B0%B8-%E9%BC%8E%E5%8A%9B%E3%80%81%E4%B8%8A%E6%B5%B7-%E8%BF%9E%E7%A7%91%E6%8A%80%EF%BC%89"><span class="toc-text">3. 接口与抽象类的区别？（字*跳动、阿*校招、*度校招、**计算机技术及应用研究所、航*拓普、纬*、招**晟、汇*云通、数信**科技、北京永*鼎力、上海*连科技）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%8E%A5%E5%8F%A3%E6%98%AF%E5%90%A6%E5%8F%AF%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3%EF%BC%9F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E5%AE%9E%E7%8E%B0%EF%BC%88implements%EF%BC%89%E6%8E%A5%E5%8F%A3%EF%BC%9F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%88concrete-class%EF%BC%89%EF%BC%9F%EF%BC%88%E8%88%AA-%E6%8B%93%E6%99%AE%E3%80%81-%E8%9D%B6%E3%80%81%E6%B7%B1%E5%9C%B3%E5%BE%B7-%E7%A7%91%E6%8A%80%EF%BC%89"><span class="toc-text">4. 接口是否可继承接口？抽象类是否可实现（implements）接口？抽象类是否可继承实现类（concrete class）？（航*拓普、*蝶、深圳德*科技）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%8E%A5%E5%8F%A3%E5%8F%AF%E4%BB%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E5%B1%9E%E6%80%A7%E5%90%97%EF%BC%9F%EF%BC%88%E5%8D%8E-%E4%B8%AD%E7%9B%9B%EF%BC%89"><span class="toc-text">5. 接口可以有自己属性吗？（华*中盛）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E8%AE%BF%E9%97%AE%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-%E4%B8%8A%E6%B5%B7-%E6%80%9D"><span class="toc-text">6. 访问接口的默认方法如何使用(上海*思)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">2.7 内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%86%85%E9%83%A8%E7%B1%BB%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F%EF%BC%88%E5%8D%8E%E6%B2%B9-%E6%99%AE%E3%80%81%E6%9D%A5-%E7%A7%91%E6%8A%80%EF%BC%89"><span class="toc-text">1. 内部类有哪几种？（华油**普、来*科技）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%89%B9%E7%82%B9%E8%AF%B4%E4%B8%80%E4%B8%8B%EF%BC%88%E6%8B%9B%E9%80%9A-%EF%BC%89"><span class="toc-text">2. 内部类的特点说一下（招通**）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%8C%BF%E5%90%8D%E7%B1%BB%E8%AF%B4%E4%B8%80%E4%B8%8B%EF%BC%88%E9%98%BF-%E6%A0%A1%E6%8B%9B%E3%80%81%E4%B8%8A%E6%B5%B7%E7%AB%8B-%E7%BD%91%E7%BB%9C%EF%BC%89"><span class="toc-text">8.匿名类说一下（阿*校招、上海立*网络）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-text">2.8 枚举类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9E%9A%E4%B8%BE%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E5%90%97-%EF%BC%88%E9%A1%BA-%EF%BC%89"><span class="toc-text">1. 枚举可以继承吗?（顺*）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-text">2.9 包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Java%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E5%87%A1-%E7%A7%91%E6%8A%80%EF%BC%89"><span class="toc-text">1. Java基本类型与包装类的区别（凡*科技）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-10-%E7%BB%BC%E5%90%88"><span class="toc-text">2.10 综合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3-%E5%90%9B-%E7%A7%91%E6%8A%80%E3%80%81%E8%88%AA-%E6%8B%93%E6%99%AE%E3%80%81%E2%80%A6"><span class="toc-text">1. 谈谈你对面向对象的理解(君*科技、航*拓普、…)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2-%EF%BC%88%E5%8C%97%E4%BA%AC%E6%A5%9A-%E9%BE%99%E3%80%81%E6%B7%B1%E5%9C%B3%E5%BE%B7-%E7%A7%91%E6%8A%80%E3%80%81%E7%9B%B4-%E7%A7%91%E6%8A%80%E3%80%81%E7%B1%B3-%E5%A5%87%E7%BD%91%E7%BB%9C%E3%80%81%E8%88%AA-%E6%8B%93%E6%99%AE%EF%BC%89"><span class="toc-text">2. 面向对象的特征有哪些方面? （北京楚*龙、深圳德*科技、直*科技、米*奇网络、航*拓普）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-text">异常的概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-text">异常的体系结构及常见的异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">异常处理的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#try-catch-finally"><span class="toc-text">try-catch-finally</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#throws"><span class="toc-text">throws</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8throw%E5%BC%82%E5%B8%B8%E5%AF%B9%E8%B1%A1"><span class="toc-text">手动throw异常对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="toc-text">如何自定义异常类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E4%B9%9D%EF%BC%89"><span class="toc-text">企业真题（九）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%BC%82%E5%B8%B8%E6%A6%82%E8%BF%B0"><span class="toc-text">2.1 异常概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Java%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%8B%EF%BC%88%E7%BD%91-%EF%BC%89"><span class="toc-text">1. Java的异常体系简单介绍下（网*）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%EF%BC%88-%E7%A7%91%E8%BD%AF%EF%BC%89"><span class="toc-text">2. Java异常处理机制（*科软）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%BC%82%E5%B8%B8%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%B1%BB%E5%9E%8B%EF%BC%8CError%E5%92%8CException%E7%9A%84%E5%8C%BA%E5%88%AB-%E4%B8%8A%E6%B5%B7%E5%86%A0-%E6%96%B0%E5%88%9B%E3%80%81%E5%8C%97%E4%BA%AC%E4%B8%AD-%E8%AF%91%E3%80%81-%E5%BA%A6"><span class="toc-text">3. 异常的两种类型，Error和Exception的区别(上海冠*新创、北京中**译、*度)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E4%B8%8E%E4%B8%80%E8%88%AC%E5%BC%82%E5%B8%B8%E6%9C%89%E4%BD%95%E5%BC%82%E5%90%8C%EF%BC%9F%EF%BC%88%E5%8D%8E-%E6%80%9D%E4%B8%BA%EF%BC%89"><span class="toc-text">4. 运行时异常与一般异常有何异同？（华*思为）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%AF%B4%E5%87%A0%E4%B8%AA%E4%BD%A0%E5%B8%B8%E8%A7%81%E5%88%B0%E7%9A%84%E5%BC%82%E5%B8%B8%EF%BC%88%E5%8D%8E%E6%B2%B9-%E6%99%AE%EF%BC%89"><span class="toc-text">5. 说几个你常见到的异常（华油**普）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-try-catch-finally"><span class="toc-text">2.2 try-catch-finally</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B4%E8%AF%B4final%E3%80%81finally%E3%80%81finalize%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E5%8C%97%E4%BA%AC%E4%B8%AD-%E8%AF%91%E3%80%81%E8%89%BE-%E8%BD%AF%E4%BB%B6%E3%80%81%E6%8B%93-%E6%80%9D%E3%80%81-%E7%A7%91%E8%BD%AF%EF%BC%89"><span class="toc-text">1. 说说final、finally、finalize的区别（北京中**译、艾*软件、拓*思、*科软）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A6%82%E6%9E%9C%E4%B8%8D%E4%BD%BF%E7%94%A8try-catch%EF%BC%8C%E7%A8%8B%E5%BA%8F%E5%87%BA%E7%8E%B0%E5%BC%82%E5%B8%B8%E4%BC%9A%E5%A6%82%E4%BD%95%EF%BC%9F-%E4%B8%8A%E6%B5%B7%E5%86%A0-%E6%96%B0%E5%88%9B%E7%A7%91%E6%8A%80"><span class="toc-text">2. 如果不使用try-catch，程序出现异常会如何？(上海冠*新创科技)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-try-%E2%80%A6-catch%E6%8D%95%E6%8D%89%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E5%BC%82%E5%B8%B8%EF%BC%9F%EF%BC%88%E5%8C%97%E4%BA%AC%E4%BA%BF-%E4%B8%9C%E6%96%B9%EF%BC%89"><span class="toc-text">3. try … catch捕捉的是什么异常？（北京亿*东方）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A6%82%E6%9E%9C%E6%89%A7%E8%A1%8Cfinally%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B9%8B%E5%89%8D%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E4%BA%86%E7%BB%93%E6%9E%9C%E6%88%96%E8%80%85jvm%E9%80%80%E5%87%BA%E4%BA%86%EF%BC%8C%E8%BF%99%E6%97%B6finally%E5%9D%97%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E8%BF%98%E4%BC%9A%E6%89%A7%E8%A1%8C%E5%90%97-%E6%81%92-%E7%94%B5%E5%AD%90"><span class="toc-text">4. 如果执行finally代码块之前方法返回了结果或者jvm退出了，这时finally块中的代码还会执行吗?(恒*电子)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%9C%A8try%E8%AF%AD%E5%8F%A5%E4%B8%AD%E6%9C%89return%E8%AF%AD%E5%8F%A5%EF%BC%8C%E6%9C%80%E5%90%8E%E5%86%99finally%E8%AF%AD%E5%8F%A5%EF%BC%8Cfinally%E8%AF%AD%E5%8F%A5%E4%B8%AD%E7%9A%84code%E4%BC%9A%E4%B8%8D%E4%BC%9A%E6%89%A7%E8%A1%8C%EF%BC%9F%E4%BD%95%E6%97%B6%E6%89%A7%E8%A1%8C%EF%BC%9F%E5%A6%82%E6%9E%9C%E6%89%A7%E8%A1%8C%E6%98%AF%E5%9C%A8return%E5%89%8D%E8%BF%98%E6%98%AF%E5%90%8E%EF%BC%88%E6%8B%93-%E6%80%9D%E3%80%81%E5%8D%8E-%E4%B8%BA%EF%BC%89"><span class="toc-text">5. 在try语句中有return语句，最后写finally语句，finally语句中的code会不会执行？何时执行？如果执行是在return前还是后（拓*思、华**为）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%E5%9C%A8catch%E5%9D%97%E9%87%8C%E4%B8%80%E5%AE%9A%E4%BC%9A%E8%BF%9B%E5%85%A5finally%E5%90%97%EF%BC%9Fcatch%E9%87%8C%E8%83%BDreturn%E5%90%97%EF%BC%9Fcatch%E9%87%8Creturn%E8%BF%98%E4%BC%9A%E8%BF%9Bfinally%E5%90%97%EF%BC%9F%E5%9C%A8try%E9%87%8Creturn%E6%98%AF%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%EF%BC%9F%EF%BC%88-%E8%93%9D%EF%BC%89"><span class="toc-text">6. 捕获异常在catch块里一定会进入finally吗？catch里能return吗？catch里return还会进finally吗？在try里return是什么情况？（*蓝）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-throw%E4%B8%8Ethrows"><span class="toc-text">2.3 throw与throws</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-throw%E5%92%8Cthrows%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88%E5%8C%97%E4%BA%AC%E4%BA%BF-%E6%96%B9%E3%80%81%E5%8C%97%E4%BA%AC%E6%96%B0-%E9%98%B3%E5%85%89%EF%BC%89"><span class="toc-text">1. throw和throws的区别？（北京亿**方、北京新*阳光）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AD%90%E7%B1%BB%E9%87%8D%E5%86%99%E7%88%B6%E7%B1%BB%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E8%83%BD%E5%90%A6%E6%8A%9B%E5%87%BA%E6%AF%94%E7%88%B6%E7%B1%BB%E6%9B%B4%E9%AB%98%E7%BA%A7%E5%88%AB%E7%9A%84%E5%BC%82%E5%B8%B8%E7%B1%BB%EF%BC%88%E9%A1%BA-%EF%BC%89"><span class="toc-text">2. 子类重写父类抛出异常的方法，能否抛出比父类更高级别的异常类（顺*）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-text">2.4 自定义异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%BC%82%E5%B8%B8%EF%BC%9F%EF%BC%88-%E8%BD%AF%E5%9B%BD%E9%99%85%EF%BC%89"><span class="toc-text">1. 如何自定义一个异常？（*软国际）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E4%B8%AA%E6%A6%82%E5%BF%B5"><span class="toc-text">几个概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-text">2. 如何创建多线程（重点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Thread%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">3. Thread类的常用方法、线程的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-%E9%87%8D%E7%82%B9%E3%80%81%E9%9A%BE%E7%82%B9"><span class="toc-text">4. 如何解决线程安全问题(重点、难点)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">5. 同步机制相关的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-text">6. 线程间的通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%8D%81%EF%BC%89"><span class="toc-text">企业真题（十）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-text">2.1 线程概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B-%E4%BA%91%E7%BD%91%E7%BB%9C"><span class="toc-text">1. 什么是线程(*云网络)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%E5%9B%A2%E3%80%81%E8%85%BE-%E3%80%81-%E4%BA%91%E7%BD%91%E7%BB%9C%E3%80%81%E7%A5%9E-%E5%B2%B3%E3%80%81%E8%A8%80-%E6%9C%89%E7%89%A9%E3%80%81%E7%9B%B4-%E7%A7%91%E6%8A%80"><span class="toc-text">2. 线程和进程有什么区别(*团、腾*、*云网络、神**岳、言*有物、直*科技)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%88%E5%98%89-%E5%8C%BB%E7%96%97%EF%BC%89"><span class="toc-text">3. 多线程使用场景（嘉*医疗）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">2.2 如何实现多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A6%82%E4%BD%95%E5%9C%A8Java%E4%B8%AD%E5%87%BA%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F-%E9%98%BF-%E6%A0%A1%E6%8B%9B%E3%80%81%E5%BD%93-%E7%BD%AE%E4%B8%9A%E3%80%81%E9%B8%BF-%E7%BD%91%E7%BB%9C%E3%80%81%E5%A5%A5-%E5%8C%BB%E8%8D%AF%E3%80%81-%E7%A7%91%E8%BD%AF%E3%80%81%E6%85%A7-%E3%80%81%E4%B8%8A%E6%B5%B7%E9%A9%BF-%E8%BD%AF%E4%BB%B6%E3%80%81%E6%B5%B7-%E7%A7%91"><span class="toc-text">1. 如何在Java中出实现多线程？(阿*校招、当*置业、鸿*网络、奥*医药、*科软、慧*、上海驿*软件、海*科)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Thread%E7%B1%BB%E4%B8%AD%E7%9A%84start-%E5%92%8Crun-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-%E5%8C%97%E4%BA%AC%E4%B8%AD%E6%B2%B9-%E3%80%81%E7%88%B1-%E4%BF%A1%E3%80%81%E7%A5%9E-%E6%B3%B0%E5%B2%B3%E3%80%81%E7%9B%B4-%E7%A7%91%E6%8A%80%EF%BC%8C-%E8%BD%AF%E5%9B%BD%E9%99%85%EF%BC%8C%E4%B8%8A%E6%B5%B7-%E5%AD%A6%E7%BD%91%E7%BB%9C"><span class="toc-text">2. Thread类中的start()和run()有什么区别？(北京中油**、爱*信、神*泰岳、直*科技，*软国际，上海*学网络)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%98%AF%E7%94%A8run-%E8%BF%98%E6%98%AFstart-%EF%BC%88-%E5%BA%A6%EF%BC%89"><span class="toc-text">3. 启动一个线程是用run()还是start()?（*度）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Java%E4%B8%ADRunnable%E5%92%8CCallable%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F-%E5%B9%B3-%E9%87%91%E6%9C%8D%E3%80%81%E9%93%B6-%E6%95%B0%E6%8D%AE%E3%80%81%E5%A5%BD-%E5%9C%A8%E3%80%81%E4%BA%BF-%E5%BE%81%E4%BF%A1%E3%80%81%E8%8A%B1%E5%84%BF-%E7%BD%91%E7%BB%9C"><span class="toc-text">4. Java中Runnable和Callable有什么不同？(平*金服、银*数据、好*在、亿*征信、花儿**网络)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%AE%83%EF%BC%9F-%E4%B8%8A%E6%B5%B7%E6%98%8E-%E7%89%A9%E8%81%94%E7%BD%91%E7%A7%91%E6%8A%80"><span class="toc-text">5. 什么是线程池，为什么要使用它？(上海明*物联网科技)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">2.3 常用方法、生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-sleep-%E5%92%8C-yield-%E5%8C%BA%E5%88%AB%EF%BC%9F-%E7%A5%9E-%E6%B3%B0%E5%B2%B3"><span class="toc-text">1. sleep() 和 yield()区别？(神*泰岳)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%81%E5%B1%9E%E6%80%A7%E6%83%85%E5%86%B5%EF%BC%9F-%E6%8B%9B%E9%80%9A-%E3%80%81%E6%95%B0-%E4%BA%92%E8%9E%8D"><span class="toc-text">2. 线程创建中的方法、属性情况？(招通**、数*互融)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F-%E4%B8%AD%E5%9B%BD-%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1%E4%B8%AD%E5%BF%83%E3%80%81-%E7%A7%91%E8%BD%AF%E3%80%81%E6%85%A7"><span class="toc-text">3. 线程的生命周期？(中国**电子商务中心、*科软、慧*)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F-%E7%9B%B4-%E7%A7%91%E6%8A%80"><span class="toc-text">4. 线程的基本状态以及状态之间的关系？(直*科技)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-stop-%E5%92%8Csuspend-%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BD%95%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%EF%BC%9F%EF%BC%88%E4%B8%8A%E6%B5%B7%E9%A9%BF-%E8%BD%AF%E4%BB%B6%EF%BC%89"><span class="toc-text">5. stop()和suspend()方法为何不推荐使用？（上海驿*软件）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Java-%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9A%E4%B9%89%E7%9A%84%EF%BC%9F%EF%BC%88%E8%BD%AF-%E5%8A%A8%E5%8A%9B%EF%BC%89"><span class="toc-text">6. Java 线程优先级是怎么定义的？（软*动力）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-text">2.4 线程安全与同步机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BD%A0%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E6%98%AF%E5%A6%82%E4%BD%95%E9%80%A0%E6%88%90%E7%9A%84%EF%BC%9F%EF%BC%88-%E8%BD%AF%E5%9B%BD%E9%99%85%EF%BC%89"><span class="toc-text">1. 你如何理解线程安全的？线程安全问题是如何造成的？（*软国际）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%B1%E7%94%A8%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%8F%98%E9%87%8F%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E5%8F%B2-%E5%A4%AB%E8%BD%AF%E4%BB%B6%EF%BC%89"><span class="toc-text">2. 多线程共用一个数据变量需要注意什么？（史*夫软件）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%80%E8%88%AC%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F%EF%BC%88%E6%9D%A5-%E7%A7%91%E6%8A%80%E3%80%81%E5%8C%97%E4%BA%AC-%E4%BF%A1%E5%A4%A9-%EF%BC%89"><span class="toc-text">3. 多线程保证线程安全一般有几种方式？（来*科技、北京*信天*）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%94%A8%E4%BB%80%E4%B9%88%E5%85%B3%E9%94%AE%E5%AD%97%E4%BF%AE%E9%A5%B0%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95-%EF%BC%88%E4%B8%8A%E6%B5%B7%E9%A9%BF-%E8%BD%AF%E4%BB%B6%EF%BC%89"><span class="toc-text">4. 用什么关键字修饰同步方法?（上海驿*软件）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-synchronized%E5%8A%A0%E5%9C%A8%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95%E5%8C%BA%E5%88%AB%EF%BC%88%E6%9D%A5-%E7%A7%91%E6%8A%80%EF%BC%89"><span class="toc-text">5. synchronized加在静态方法和普通方法区别（来*科技）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Java%E4%B8%ADsynchronized%E5%92%8CReentrantLock%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C-%E4%B8%89-%E9%87%8D%E5%B7%A5"><span class="toc-text">6. Java中synchronized和ReentrantLock有什么不同(三*重工)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%BD%93%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%BF%9B%E5%85%A5%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%80%E4%B8%AAsynchronized%E6%96%B9%E6%B3%95%E5%90%8E%EF%BC%8C%E5%85%B6%E5%AE%83%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E5%8F%AF%E8%BF%9B%E5%85%A5%E6%AD%A4%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B6%E5%AE%83%E6%96%B9%E6%B3%95-%EF%BC%88%E9%B8%BF-%E7%BD%91%E7%BB%9C%EF%BC%89"><span class="toc-text">7. 当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?（鸿*网络）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E9%98%BB%E5%A1%9E%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F%E5%90%8C%E6%AD%A5%E4%B8%80%E5%AE%9A%E9%98%BB%E5%A1%9E%E5%90%97%EF%BC%9F%E9%98%BB%E5%A1%9E%E4%B8%80%E5%AE%9A%E5%90%8C%E6%AD%A5%E5%90%97%EF%BC%9F%EF%BC%88%E9%98%BF-%E6%A0%A1%E6%8B%9B%E3%80%81%E8%A5%BF%E5%AE%89-%E5%88%9B%E4%BD%B3-%EF%BC%89"><span class="toc-text">8. 线程同步与阻塞的关系？同步一定阻塞吗？阻塞一定同步吗？（阿*校招、西安*创佳*）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E6%AD%BB%E9%94%81"><span class="toc-text">2.5 死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%EF%BC%8C%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6%EF%BC%88%E8%85%BE-%E3%80%81%E9%98%BF-%EF%BC%89"><span class="toc-text">1. 什么是死锁，产生死锁的原因及必要条件（腾*、阿*）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%EF%BC%9F-%E9%98%BF-%E3%80%81%E5%8C%97%E4%BA%AC-%E8%93%9D%E3%80%81-%E6%89%8B"><span class="toc-text">2. 如何避免死锁？(阿*、北京*蓝、*手)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-text">2.6 线程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Java%E4%B8%ADnotify-%E5%92%8CnotifyAll-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%E6%B1%87-%E5%A4%A9%E4%B8%8B"><span class="toc-text">1. Java中notify()和notifyAll()有什么区别(汇*天下)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88wait-%E5%92%8Cnotify-%E6%96%B9%E6%B3%95%E8%A6%81%E5%9C%A8%E5%90%8C%E6%AD%A5%E5%9D%97%E4%B8%AD%E8%B0%83%E7%94%A8-%E5%8C%97%E4%BA%AC-%E6%99%BA"><span class="toc-text">2. 为什么wait()和notify()方法要在同步块中调用(北京*智)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85%EF%BC%8C%E6%B6%88%E8%B4%B9%E8%80%85%E4%BB%A3%E7%A0%81%EF%BC%88%E5%90%8C%E6%AD%A5%E3%80%81wait%E3%80%81notifly%E7%BC%96%E7%A8%8B%EF%BC%89%EF%BC%88%E7%8C%AB-%E5%A8%B1%E4%B9%90%EF%BC%89"><span class="toc-text">3. 多线程：生产者，消费者代码（同步、wait、notifly编程）（猫*娱乐）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-wait-%E5%92%8Csleep-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E8%B0%83%E7%94%A8%E8%BF%99%E4%B8%A4%E4%B8%AA%E5%87%BD%E6%95%B0%E5%90%8E%EF%BC%8C%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%88%86%E5%88%AB%E4%BD%9C%E4%BD%95%E6%94%B9%E5%8F%98%EF%BC%9F%EF%BC%88%E5%AD%97-%E3%80%81-%E4%B8%9C%EF%BC%89"><span class="toc-text">4. wait()和sleep()有什么区别？调用这两个函数后，线程状态分别作何改变？（字*、*东）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%89"><span class="toc-text">2.7 单例模式（线程安全）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-Singleton-%EF%BC%8C%E8%BF%98%E8%A6%81%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%88-%E9%80%9A%E5%BF%AB%E9%80%92%E3%80%81%E5%90%9B-%E7%A7%91%E6%8A%80%EF%BC%89"><span class="toc-text">1. 手写一个单例模式(Singleton)，还要安全的（*通快递、君*科技）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E6%87%92%E6%B1%89%E5%BC%8F%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-amp-%E8%A7%A3%E5%86%B3%E5%85%B6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%8C%E5%B9%B6%E4%B8%94%E8%AF%B4%E6%98%8E%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E6%A0%B7%E5%AD%90%E5%8E%BB%E8%A7%A3%E5%86%B3%EF%BC%885-%EF%BC%89"><span class="toc-text">2. 手写一个懒汉式的单例模式&amp;解决其线程安全问题，并且说明为什么这样子去解决（5*）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%B1%BB%E4%B8%8E%E5%9F%BA%E7%A1%80API"><span class="toc-text">常用类与基础API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E7%B1%BB"><span class="toc-text">String类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuffer%E3%80%81StringBuilder%E7%B1%BB"><span class="toc-text">StringBuffer、StringBuilder类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jdk8%E4%B9%8B%E5%89%8D%E7%9A%84%E6%97%A5%E6%9C%9F%E3%80%81%E6%97%B6%E9%97%B4API"><span class="toc-text">jdk8之前的日期、时间API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jdk8%E4%B8%AD%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9F%E3%80%81%E6%97%B6%E9%97%B4API"><span class="toc-text">jdk8中新的日期、时间API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%99%A8-%E9%87%8D%E7%82%B9"><span class="toc-text">比较器(重点)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83API"><span class="toc-text">其它API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java-lang-System-%E7%B1%BB"><span class="toc-text">java.lang.System 类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java-lang-Runtime%E7%B1%BB"><span class="toc-text">java.lang.Runtime类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%92%8C%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB"><span class="toc-text">和数学相关的类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89"><span class="toc-text">企业真题（十一）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-String"><span class="toc-text">2.1 String</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%A5%E4%B8%8B%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E7%9A%84String%E5%AF%B9%E8%B1%A1%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F%EF%BC%88-%E5%9B%A2%EF%BC%89"><span class="toc-text">1. 以下两种方式创建的String对象有什么不同？（*团）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-String-s-x3D-new-String-%E2%80%9Cxyz%E2%80%9D-%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AAString-Object-%EF%BC%88%E6%96%B0-%E9%99%86%EF%BC%89"><span class="toc-text">2. String s &#x3D; new String(“xyz”);创建了几个String Object? （新*陆）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-String-a-x3D-%E2%80%9Dabc%E2%80%9D-String-b-x3D-%E2%80%9Da%E2%80%9D-%E2%80%9Dbc%E2%80%9D-%E9%97%AEa-x3D-x3D-b-%EF%BC%88%E7%BD%91-%E9%82%AE%E7%AE%B1%EF%BC%89"><span class="toc-text">3. String a&#x3D;”abc” String b&#x3D;”a”+”bc” 问a&#x3D;&#x3D;b?（网*邮箱）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-String-%E4%B8%AD-%E2%80%9C-%E2%80%9D-%E6%80%8E%E6%A0%B7%E5%AE%9E%E7%8E%B0-%EF%BC%88%E9%98%BF-%EF%BC%89"><span class="toc-text">4. String 中 “+” 怎样实现?（阿*）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Java%E4%B8%ADString%E6%98%AF%E4%B8%8D%E6%98%AFfinal%E7%9A%84%EF%BC%9F%EF%BC%88%E5%87%A1-%E7%A7%91%E6%8A%80%EF%BC%89"><span class="toc-text">5. Java中String是不是final的？（凡*科技）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-String%E4%B8%BA%E5%95%A5%E4%B8%8D%E5%8F%AF%E5%8F%98%EF%BC%8C%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%85%B7%E4%BD%93%E5%BD%A2%E6%80%81%EF%BC%9F%EF%BC%88%E9%98%BF-%EF%BC%89"><span class="toc-text">6. String为啥不可变，在内存中的具体形态？（阿*）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-String-%E5%8F%AF%E4%BB%A5%E5%9C%A8-switch%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%90%97-%E4%B8%8A%E6%B5%B7-%E7%9D%BF"><span class="toc-text">7. String 可以在 switch中使用吗?(上海*睿)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-String%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95-%E5%88%97%E4%B8%BE%E5%87%A0%E4%B8%AA%EF%BC%88%E9%97%AA-%E8%B4%AD%EF%BC%89"><span class="toc-text">8. String中有哪些方法?列举几个（闪*购）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-subString-%E5%88%B0%E5%BA%95%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88-%E9%93%B6-%E6%95%B0%E6%8D%AE"><span class="toc-text">9. subString()到底做了什么?(银*数据)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-String%E3%80%81StringBuffer%E3%80%81StringBuilder"><span class="toc-text">2.2 String、StringBuffer、StringBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Java%E4%B8%AD%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%EF%BC%9F%E4%BB%96%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E3%80%82%EF%BC%88%E5%8D%97-%E7%94%B5%E7%BD%91%EF%BC%89"><span class="toc-text">1. Java中操作字符串有哪些类？他们之间有什么区别。（南*电网）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-String%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%88%E9%97%AA-%E8%B4%AD%EF%BC%89"><span class="toc-text">2. String的线程安全问题（闪*购）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-StringBuilder%E5%92%8CStringBuffer%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%88%E6%B6%A6-%E8%BD%AF%E4%BB%B6%EF%BC%89"><span class="toc-text">3. StringBuilder和StringBuffer的线程安全问题（润*软件）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Comparator%E4%B8%8EComparable"><span class="toc-text">2.3 Comparator与Comparable</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4-Comparable-%E5%92%8C-Comparator-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%9C%BA%E6%99%AF%EF%BC%9F%EF%BC%88%E8%BD%AF-%E5%8A%9B%EF%BC%89"><span class="toc-text">1. 简单说说 Comparable 和 Comparator 的区别和场景？（软**力）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Comparable-%E6%8E%A5%E5%8F%A3%E5%92%8C-Comparator-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E6%AF%94%E8%BE%83%EF%BC%88%E9%98%BF-%EF%BC%89"><span class="toc-text">2. Comparable 接口和 Comparator 接口实现比较（阿*）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-text">集合框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E6%96%B9%E9%9D%A2%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E5%BC%8A%E7%AB%AF"><span class="toc-text">数组存储数据方面的特点和弊端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB%EF%BC%88java-util%E5%8C%85%E4%B8%8B%EF%BC%89"><span class="toc-text">Java集合框架体系（java.util包下）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">Collection的常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="toc-text">迭代器接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection%E7%9A%84%E5%AD%90%E6%8E%A5%E5%8F%A3%EF%BC%9AList"><span class="toc-text">Collection的子接口：List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection%E7%9A%84%E5%AD%90%E6%8E%A5%E5%8F%A3%EF%BC%9ASet"><span class="toc-text">Collection的子接口：Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map%E6%8E%A5%E5%8F%A3"><span class="toc-text">Map接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collections%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">Collections工具类的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89"><span class="toc-text">企业真题（十二）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0"><span class="toc-text">2.1 集合概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-List%EF%BC%8CSet%EF%BC%8CMap%E6%98%AF%E5%90%A6%E7%BB%A7%E6%89%BF%E8%87%AAcollection%E6%8E%A5%E5%8F%A3%EF%BC%9F%EF%BC%88%E5%8C%97%E4%BA%AC%E4%B8%AD-%E8%AF%91%E5%92%A8%E8%AF%A2%E3%80%81%E6%80%9D-%E8%B4%B8%E6%98%93%EF%BC%89"><span class="toc-text">1. List，Set，Map是否继承自collection接口？（北京中*译咨询、思*贸易）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AF%B4%E8%AF%B4List-Set-Map%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB-%E6%B0%91-%E9%93%B6%E8%A1%8C"><span class="toc-text">2. 说说List,Set,Map三者的区别(民*银行)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%86%99%E5%87%BAlist%E3%80%81map%E3%80%81set%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%8C%E5%B9%B6%E8%AF%B4%E5%87%BA%E5%85%B6%E7%89%B9%E7%82%B9%EF%BC%88%E5%8D%8E-%E4%B8%BA%EF%BC%89"><span class="toc-text">3. 写出list、map、set接口的实现类，并说出其特点（华**为）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%B8%B8%E8%A7%81%E9%9B%86%E5%90%88%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%88%E9%A5%BF-%EF%BC%89"><span class="toc-text">4. 常见集合类的区别和适用场景（饿**）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%9B%86%E5%90%88%E7%9A%84%E7%88%B6%E7%B1%BB%E6%98%AF%E8%B0%81%EF%BC%9F%E5%93%AA%E4%BA%9B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F%EF%BC%88%E5%8C%97%E4%BA%AC%E4%B8%AD-%E4%BF%A1%EF%BC%89"><span class="toc-text">5. 集合的父类是谁？哪些安全的？（北京中**信）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E9%9B%86%E5%90%88%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%93%AA%E4%BA%9B%E6%98%AF%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%88-%E7%A7%91%E8%BD%AF%EF%BC%89"><span class="toc-text">6. 集合说一下哪些是线程不安全的（*科软）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%EF%BC%88%E6%81%92-%E7%94%B5%E5%AD%90%EF%BC%89"><span class="toc-text">7. 遍历集合的方式有哪些？（恒*电子）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-List%E6%8E%A5%E5%8F%A3"><span class="toc-text">2.2 List接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-List%E4%B8%8B%E9%9D%A2%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%EF%BC%88%E8%BD%AF-%E5%8A%9B%EF%BC%89"><span class="toc-text">1. List下面有哪些实现（软**力）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-ArrayList%E4%B8%8ELinkedList%E5%8C%BA%E5%88%AB%EF%BC%9F-O-O%E3%80%81%E6%BB%B4-%E3%80%81%E6%B1%87-%E5%A4%A9%E4%B8%8B%E3%80%81%E6%8B%93-%E8%BD%AF%E4%BB%B6%E3%80%81%E5%8D%9A%E7%BA%B3-%E8%BD%AF%E4%BB%B6%E3%80%81%E4%B8%8A%E6%B5%B7-%E8%BF%9B%E5%A4%A9%E4%B8%8B%EF%BC%8C%E5%8C%97%E4%BA%AC%E6%B0%B8%E7%94%9F-%E4%BF%A1%E6%81%AF%E3%80%81-%E8%81%94%E3%80%81%E5%9C%A8-%E9%80%94%E6%B8%B8"><span class="toc-text">2. ArrayList与LinkedList区别？(O**O、滴*、汇*天下、拓*软件、博纳**软件、上海*进天下，北京永生**信息、*联、在*途游)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-ArrayList%E4%B8%8EVector%E5%8C%BA%E5%88%AB%E5%91%A2%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8ArrayList%E5%8F%96%E4%BB%A3Vector%E5%91%A2%EF%BC%9F-%E6%B9%96-%E5%88%A9%E8%BD%AF%E4%BB%B6"><span class="toc-text">3. ArrayList与Vector区别呢？为什么要用ArrayList取代Vector呢？(湖**利软件)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Java-util-ArrayList%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%EF%BC%88%E5%8D%8E-%E4%B8%BA%EF%BC%89"><span class="toc-text">4. Java.util.ArrayList常用的方法有哪些？（华**为）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Arraylist-%E6%98%AF%E6%9C%89%E5%BA%8F%E8%BF%98%E6%98%AF%E6%97%A0%E5%BA%8F%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E8%9C%9C-%E4%BF%A1%E6%81%AF%EF%BC%89"><span class="toc-text">5. Arraylist 是有序还是无序？为什么？（蜜*信息）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Set%E6%8E%A5%E5%8F%A3"><span class="toc-text">2.3 Set接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Set%E9%9B%86%E5%90%88%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%8C%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F%EF%BC%88%E6%8B%93-%E8%BD%AF%E4%BB%B6%EF%BC%89"><span class="toc-text">1. Set集合有哪些实现类，分别有什么特点？（拓*软件）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-List%E9%9B%86%E5%90%88%E5%92%8CSet%E9%9B%86%E5%90%88%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88%E4%BA%9A-%E7%A7%91%E6%8A%80%E3%80%81-%E6%B5%B7-%E7%BF%BC%E7%A7%91%E6%8A%80%EF%BC%8C-%E5%8D%8E%E7%94%B5-%E7%B3%BB%E7%BB%9F%EF%BC%8C%E8%BE%BE-%E8%B4%B7%EF%BC%89"><span class="toc-text">2. List集合和Set集合的区别？（亚*科技、*海*翼科技，*华电*系统，达*贷）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Set%E9%87%8C%E7%9A%84%E5%85%83%E7%B4%A0%E6%98%AF%E4%B8%8D%E8%83%BD%E9%87%8D%E5%A4%8D%E7%9A%84%EF%BC%8C%E9%82%A3%E4%B9%88%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E6%9D%A5%E5%8C%BA%E5%88%86%E9%87%8D%E5%A4%8D%E4%B8%8E%E5%90%A6%E5%91%A2-%E6%98%AF%E7%94%A8-x3D-x3D-%E8%BF%98%E6%98%AFequals-%E5%AE%83%E4%BB%AC%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB-%EF%BC%88%E9%B8%BF-%E7%BD%91%E7%BB%9C%EF%BC%89"><span class="toc-text">3. Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用&#x3D;&#x3D;还是equals()? 它们有何区别?（鸿*网络）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-TreeSet%E4%B8%A4%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F%E5%9C%A8%E4%BD%BF%E7%94%A8%E7%9A%84%E6%97%B6%E5%80%99%E6%80%8E%E4%B9%88%E8%B5%B7%E4%BD%9C%E7%94%A8%EF%BC%9F%EF%BC%88%E6%8B%93-%E8%BD%AF%E4%BB%B6%EF%BC%89"><span class="toc-text">4. TreeSet两种排序方式在使用的时候怎么起作用？（拓*软件）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-TreeSet%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88-%E7%B1%B3%EF%BC%89"><span class="toc-text">5. TreeSet的数据结构（*米）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-Map%E6%8E%A5%E5%8F%A3"><span class="toc-text">2.4 Map接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B4%E4%B8%80%E4%B8%8BJava%E7%9A%84%E9%9B%86%E5%90%88Map%E6%9C%89%E5%93%AA%E4%BA%9BMap%EF%BC%9F%EF%BC%88%E5%A5%A5-%E5%8C%BB%E8%8D%AF%EF%BC%89"><span class="toc-text">1. 说一下Java的集合Map有哪些Map？（奥*医药）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-final%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%8C%E4%BF%AE%E9%A5%B0Map%E5%8F%AF%E4%BB%A5%E7%BB%A7%E7%BB%AD%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE%E5%90%97%EF%BC%9F%EF%BC%88-%E6%B7%B1%E8%93%9D%EF%BC%89"><span class="toc-text">2. final怎么用，修饰Map可以继续添加数据吗？（*深蓝）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Set%E5%92%8CMap%E7%9A%84%E6%AF%94%E8%BE%83%EF%BC%88%E4%BA%9A-%E7%A7%91%E6%8A%80%EF%BC%89"><span class="toc-text">3. Set和Map的比较（亚*科技）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-HashMap%E8%AF%B4%E4%B8%80%E4%B8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%90%97%EF%BC%9F%EF%BC%88-%E7%B1%B3%EF%BC%89"><span class="toc-text">4. HashMap说一下，线程安全吗？（*米）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-HashMap%E5%92%8CHashbable%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F-%E9%93%B6-%E6%95%B0%E6%8D%AE%E3%80%81%E9%98%BF-%E5%B7%B4%E8%8A%9D%E9%BA%BB%E4%BF%A1%E7%94%A8%E3%80%81-%E4%BC%97%E9%93%B6%E8%A1%8C%E3%80%81%E7%88%B1-%E4%BF%A1%E3%80%81%E6%9D%AD%E5%B7%9E-%E6%99%BA%E5%85%AC%E5%8F%B8"><span class="toc-text">5. HashMap和Hashbable的区别？(银*数据、阿**巴芝麻信用、*众银行、爱*信、杭州*智公司)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Hashtable%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F%EF%BC%88%E8%BF%AA-%E5%88%9B%E6%96%B0%EF%BC%89"><span class="toc-text">6. Hashtable是怎么实现的，为什么线程安全？（迪*创新）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-HashMap%E5%92%8CLinkedHashMap%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E5%8C%97%E4%BA%AC-%E6%99%A8%E9%98%B3%E5%85%89%EF%BC%89"><span class="toc-text">7. HashMap和LinkedHashMap的区别（北京*晨阳光）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-HashMap-%E5%92%8C-TreeMap-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88-%E5%BA%A6%EF%BC%8C%E5%A4%AA%E6%9E%81-%E3%80%81-%E7%BA%BF%E9%80%94%E6%B8%B8%E3%80%81%E9%98%BF-%E6%A0%A1%E6%8B%9B%EF%BC%89"><span class="toc-text">8. HashMap 和 TreeMap 的区别（*度，太极**、*线途游、阿*校招）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-HashMap%E9%87%8C%E9%9D%A2%E5%AE%9E%E9%99%85%E8%A3%85%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E6%83%A0-%EF%BC%89"><span class="toc-text">9. HashMap里面实际装的是什么？（惠*）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-HashMap%E7%9A%84key%E5%AD%98%E5%82%A8%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F%E5%92%8Cvalue%E5%AD%98%E5%82%A8%E5%9C%A8%E4%B8%80%E8%B5%B7%E5%90%97%EF%BC%9F%E9%82%A3%E4%B9%88value%E5%AD%98%E5%82%A8%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F%E8%AF%B4%E5%85%B7%E4%BD%93%E7%82%B9%EF%BC%9F%EF%BC%88%E6%B9%96-%E5%88%A9%E8%BD%AF%E4%BB%B6%E3%80%81%E5%A4%A9-%E4%BC%9F%E4%B8%9A%EF%BC%89"><span class="toc-text">10. HashMap的key存储在哪里？和value存储在一起吗？那么value存储在哪里？说具体点？（湖**利软件、天*伟业）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BAKey%E4%B9%88%EF%BC%9F%EF%BC%88%E9%98%BF-%EF%BC%89"><span class="toc-text">11. 自定义类型可以作为Key么？（阿*）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collections"><span class="toc-text">Collections</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9B%86%E5%90%88%E7%B1%BB%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%98%AF%E8%B0%81%EF%BC%9F%E7%94%A8%E8%BF%87%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F%EF%BC%88%E9%A1%BA-%EF%BC%89"><span class="toc-text">1. 集合类的工具类是谁？用过工具类哪些方法？（顺*）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Collection-%E5%92%8C-Collections%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88%E5%B9%B3-%E9%87%91%E6%9C%8D%E3%80%81-%E8%BD%AF%EF%BC%89"><span class="toc-text">2. Collection 和 Collections的区别？（平*金服、*软）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-ArrayList-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%BA%8F%EF%BC%88%E9%98%BF-%EF%BC%89"><span class="toc-text">3. ArrayList 如何实现排序（阿*）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-HashMap%E6%98%AF%E5%90%A6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%8C%E6%80%8E%E6%A0%B7%E8%A7%A3%E5%86%B3HashMap%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%EF%BC%88%E4%B8%AD-%E5%8D%AB%E6%98%9F%EF%BC%89"><span class="toc-text">4. HashMap是否线程安全，怎样解决HashMap的线程不安全（中*卫星）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">泛型的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%9C%A8%E9%9B%86%E5%90%88%E3%80%81%E6%AF%94%E8%BE%83%E5%99%A8%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-text">泛型在集合、比较器中的使用（重点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%B1%BB-x2F-%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3%E3%80%81%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%EF%BC%88%E7%86%9F%E6%82%89%EF%BC%89"><span class="toc-text">自定义泛型类&#x2F;泛型接口、泛型方法（熟悉）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%9C%A8%E7%BB%A7%E6%89%BF%E4%B8%8A%E7%9A%84%E4%BD%93%E7%8E%B0"><span class="toc-text">泛型在继承上的体现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">通配符的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89"><span class="toc-text">企业真题（十三）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Java-%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%E5%92%8C%E4%BC%98%E7%82%B9%EF%BC%9FJDK-%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88%E8%BD%AF-%E5%8A%A8%E5%8A%9B%EF%BC%89"><span class="toc-text">1. Java 的泛型是什么？有什么好处和优点？JDK 不同版本的泛型有什么区别？（软*动力）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BA%86%E8%A7%A3%EF%BC%88-%E8%BD%AF%E5%9B%BD%E9%99%85%EF%BC%89"><span class="toc-text">2. 说说你对泛型的了解（*软国际）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81"><span class="toc-text">数据结构与集合源码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-text">链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88"><span class="toc-text">栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-text">队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">树与二叉树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E6%8E%A5%E5%8F%A3%E4%B8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-text">List接口下的实现类的源码剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-text">ArrayList源码解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-text">Vector源码解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-text">LinkedList源码解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map%E6%8E%A5%E5%8F%A3%E4%B8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-text">Map接口下的实现类的源码剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-text">HashMap源码解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedHashMap"><span class="toc-text">LinkedHashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashSet%E5%92%8CLinkedHashSet%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">HashSet和LinkedHashSet的源码分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89"><span class="toc-text">企业真题（十四）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3"><span class="toc-text">数据结构相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%93%BE%E8%A1%A8%E5%92%8C%E6%95%B0%E7%BB%84%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88%E8%85%BE-%EF%BC%89"><span class="toc-text">1. 链表和数组有什么区别？（腾*）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%A0%88%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84%EF%BC%9F-%E8%A5%BF-%E4%BF%A1%E6%81%AF%E6%8A%80%E6%9C%AF"><span class="toc-text">2. 栈是如何运行的？(西*信息技术)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E7%9B%B8%E5%85%B3"><span class="toc-text">List集合源码相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-ArrayList%E7%9A%84%E9%BB%98%E8%AE%A4%E5%A4%A7%E5%B0%8F%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%EF%BC%88%E9%A1%BA-%E3%80%81%E5%87%A1-%E7%A7%91%E6%8A%80%EF%BC%89"><span class="toc-text">1. ArrayList的默认大小是多少，以及扩容机制（顺*、凡*科技）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-ArrayList%E7%9A%84%E5%BA%95%E5%B1%82%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84-%EF%BC%88%E8%85%BE-%EF%BC%89"><span class="toc-text">2. ArrayList的底层是怎么实现的?（腾*）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9C%A8ArrayList%E4%B8%ADremove%E5%90%8E%E9%9D%A2%E5%87%A0%E4%B8%AA%E5%85%83%E7%B4%A0%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A-%EF%BC%88%E6%83%A0-%E3%80%81%E4%B8%AD-%E4%BA%BF%E8%BE%BE%EF%BC%89"><span class="toc-text">3. 在ArrayList中remove后面几个元素该怎么做?（惠*、中*亿达）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-ArrayList1-7%E5%92%8C1-8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E6%8B%93-%E6%80%9D%EF%BC%89"><span class="toc-text">4. ArrayList1.7和1.8的区别（拓*思）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%95%B0%E7%BB%84%E5%92%8C-ArrayList-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E9%98%BF-%E3%80%81-%E7%A7%91%E8%BD%AF%EF%BC%89"><span class="toc-text">5. 数组和 ArrayList 的区别（阿*、*科软）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84List%EF%BC%9F-%E5%B9%B3-%E9%87%91%E6%9C%8D"><span class="toc-text">6. 什么是线程安全的List？(平*金服)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E7%9B%B8%E5%85%B3"><span class="toc-text">HashMap集合源码相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B4%E8%AF%B4HahMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-%E6%96%B0-%E8%82%A1%E4%BB%BD%E3%80%81%E9%A1%BA-%E3%80%81%E7%8C%AB-%E5%A8%B1%E4%B9%90"><span class="toc-text">1. 说说HahMap底层实现(新*股份、顺*、猫*娱乐)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-HashMap%E5%88%9D%E5%A7%8B%E5%80%BC16%EF%BC%8C%E4%B8%B4%E7%95%8C%E5%80%BC12%E6%98%AF%E6%80%8E%E4%B9%88%E7%AE%97%E7%9A%84%EF%BC%88%E8%BD%AF-%E5%8A%9B%EF%BC%89"><span class="toc-text">2. HashMap初始值16，临界值12是怎么算的（软**力）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-HashMap%E9%95%BF%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF2%E7%9A%84%E5%B9%82%E6%AC%A1%E6%96%B9-%E5%9B%BD-%E6%97%B6%E4%BB%A3"><span class="toc-text">3. HashMap长度为什么是2的幂次方(国*时代)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-HashMap%E6%80%8E%E4%B9%88%E8%AE%A1%E7%AE%97%E5%93%88%E5%B8%8C%E5%80%BC%E5%92%8C%E7%B4%A2%E5%BC%95%EF%BC%9F%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3hash%E5%86%B2%E7%AA%81%EF%BC%9F%EF%BC%88-%E8%BD%AF%E5%9B%BD%E9%99%85%E3%80%81%E4%B8%AD%E8%BD%AF-%E8%85%BE%EF%BC%89"><span class="toc-text">4. HashMap怎么计算哈希值和索引？扩容机制？怎么解决hash冲突？（*软国际、中软*腾）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-HashMap%E5%BA%95%E5%B1%82%E6%98%AF%E6%95%B0%E7%BB%84-%E9%93%BE%E8%A1%A8%EF%BC%8C%E6%9C%89%E6%95%B0%E7%BB%84%E5%BE%88%E5%BF%AB%E4%BA%86%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8A%A0%E9%93%BE%E8%A1%A8%EF%BC%9F%EF%BC%88%E6%B6%A6-%E8%BD%AF%E4%BB%B6%EF%BC%89"><span class="toc-text">5. HashMap底层是数组+链表，有数组很快了，为什么加链表？（润*软件）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E9%95%BF%E5%BA%A6%E8%BE%BE%E5%88%B0%E4%B8%80%E5%AE%9A%E7%9A%84%E9%95%BF%E5%BA%A6%E8%A6%81%E8%BD%AC%E5%8C%96%E4%B8%BA%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%88-%E5%BA%A6%EF%BC%89"><span class="toc-text">6. HashMap为什么长度达到一定的长度要转化为红黑树（*度）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-HashMap%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%89%A9%E5%85%85%E4%B8%BA%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%88%E8%BF%94%E5%9B%9E%E5%88%B0%E9%93%BE%E8%A1%A8%EF%BC%9F%EF%BC%88%E6%B1%89-%EF%BC%89"><span class="toc-text">7. HashMap什么时候扩充为红黑树，什么时候又返回到链表？（汉*）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%9C%A8-JDK1-8%E4%B8%AD%EF%BC%8CHashMap%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E1-7%E7%9B%B8%E6%AF%94%E6%9C%89%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96%EF%BC%8C%E8%BF%99%E4%BA%9B%E5%8F%98%E5%8C%96%E7%9A%84%E5%A5%BD%E5%A4%84%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F%EF%BC%88%E6%B5%B7-%E7%A7%91%EF%BC%89"><span class="toc-text">8. 在 JDK1.8中，HashMap的数据结构与1.7相比有什么变化，这些变化的好处在哪里？（海*科）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-HashMap%E7%9A%84get-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86-%EF%BC%88%E9%A1%BA-%EF%BC%89"><span class="toc-text">9. HashMap的get()方法的原理?（顺*）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashCode%E5%92%8Cequals"><span class="toc-text">hashCode和equals</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-hashcode%E5%92%8Cequals%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88%E6%B5%B7-%E4%BE%9B%E5%BA%94%E9%93%BE%E7%AE%A1%E7%90%86%EF%BC%89"><span class="toc-text">1. hashcode和equals区别？（海*供应链管理）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-hashCode-%E4%B8%8E-equals-%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95%E3%80%81%E6%96%B9%E6%B3%95%E6%80%8E%E4%B9%88%E9%87%8D%E5%86%99%EF%BC%9F%EF%BC%88%E9%98%BF-%E6%A0%A1%E6%8B%9B%EF%BC%89"><span class="toc-text">2. hashCode() 与 equals() 生成算法、方法怎么重写？（阿*校招）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%AF%B4%E4%B8%80%E4%B8%8Bequals%E5%92%8C-x3D-x3D-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E7%84%B6%E5%90%8E%E9%97%AEequals%E7%9B%B8%E7%AD%89hash%E5%80%BC%E4%B8%80%E5%AE%9A%E7%9B%B8%E7%AD%89%E5%90%97%EF%BC%9Fhash%E5%80%BC%E7%9B%B8%E7%AD%89equals%E4%B8%80%E5%AE%9A%E7%9B%B8%E7%AD%89%E5%90%97%EF%BC%9F%EF%BC%88%E5%8D%97-%E7%94%B5%E7%BD%91%E3%80%81%E4%B8%8A%E6%B5%B7-%E6%99%BA%E7%BD%91%E7%BB%9C%EF%BC%89"><span class="toc-text">3. 说一下equals和&#x3D;&#x3D;的区别，然后问equals相等hash值一定相等吗？hash值相等equals一定相等吗？（南*电网、上海*智网络）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E7%9B%B8%E5%85%B3"><span class="toc-text">Set集合源码相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-HashSet%E5%AD%98%E6%94%BE%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9F%EF%BC%88%E6%8B%93-%E8%BD%AF%E4%BB%B6%EF%BC%89"><span class="toc-text">1. HashSet存放数据的方式？（拓*软件）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Set%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%85%83%E7%B4%A0%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7%EF%BC%9F%EF%BC%88%E6%B9%96-%E5%88%A9%E8%BD%AF%E4%BB%B6%EF%BC%89"><span class="toc-text">2. Set是如何实现元素的唯一性？（湖**利软件）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%94%A8%E5%93%AA%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%AE%9E%E7%8E%B0%E9%9B%86%E5%90%88%E7%9A%84%E6%8E%92%E5%BA%8F%EF%BC%88%E5%87%A1-%E7%A7%91%E6%8A%80%EF%BC%89"><span class="toc-text">3. 用哪两种方式来实现集合的排序（凡*科技）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#File%E7%B1%BB%E4%B8%8EIO%E6%B5%81"><span class="toc-text">File类与IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#File%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">File类的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E6%B5%81%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-text">IO流的概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E6%B5%81%E4%B9%8B%E4%B8%80%EF%BC%9A%E6%96%87%E4%BB%B6%E6%B5%81"><span class="toc-text">节点流之一：文件流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%B5%81%E4%B9%8B%E4%B8%80%EF%BC%9A%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-text">处理流之一：缓冲流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%B5%81%E4%B9%8B%E4%BA%8C%EF%BC%9A%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-text">处理流之二：转换流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%B5%81%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%AF%B9%E8%B1%A1%E6%B5%81"><span class="toc-text">处理流之三：对象流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">其它流的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89"><span class="toc-text">企业真题（十五）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E6%B5%81%E6%A6%82%E8%BF%B0"><span class="toc-text">IO流概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%B0%88%E8%B0%88Java-IO%E9%87%8C%E9%9D%A2%E7%9A%84%E5%B8%B8%E7%94%A8%E7%B1%BB%EF%BC%8C%E5%AD%97%E8%8A%82%E6%B5%81%EF%BC%8C%E5%AD%97%E7%AC%A6%E6%B5%81-%E9%93%B6-%E6%95%B0%E6%8D%AE"><span class="toc-text">1. 谈谈Java IO里面的常用类，字节流，字符流(银*数据)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Java-%E4%B8%AD%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%B5%81%EF%BC%9FJDK%E4%B8%BA%E6%AF%8F%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%B5%81%E6%8F%90%E4%BE%9B%E4%B8%80%E4%BA%9B%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%BB%A5%E4%BE%9B%E7%BB%A7%E6%89%BF%EF%BC%8C%E8%AF%B7%E8%AF%B4%E5%87%BA%E4%BB%96%E4%BB%AC%E5%88%86%E5%88%AB%E6%98%AF%E5%93%AA%E4%BA%9B%E7%B1%BB%EF%BC%9F%EF%BC%88%E4%B8%8A%E6%B5%B7-%E5%8E%A6-%E8%81%94%E7%BD%91%E3%80%81%E6%9E%81-%E7%A7%91%E6%8A%80%EF%BC%89"><span class="toc-text">2. Java 中有几种类型的流？JDK为每种类型的流提供一些抽象类以供继承，请说出他们分别是哪些类？（上海*厦*联网、极*科技）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%B5%81%E4%B8%80%E8%88%AC%E9%9C%80%E4%B8%8D%E9%9C%80%E8%A6%81%E5%85%B3%E9%97%AD%EF%BC%9F%E5%A6%82%E6%9E%9C%E5%85%B3%E9%97%AD%E7%9A%84%E8%AF%9D%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%EF%BC%9F%E5%A4%84%E7%90%86%E6%B5%81%E6%98%AF%E6%80%8E%E4%B9%88%E5%85%B3%E9%97%AD%E7%9A%84%EF%BC%9F-%E9%93%B6-%E6%95%B0%E6%8D%AE"><span class="toc-text">3. 流一般需不需要关闭？如果关闭的话用什么方法？处理流是怎么关闭的？(银*数据)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-OutputStream%E9%87%8C%E9%9D%A2%E7%9A%84write-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D-%E5%90%9B-%E7%A7%91%E6%8A%80"><span class="toc-text">4. OutputStream里面的write()是什么意思?(君*科技)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-text">缓冲流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-BufferedReader%E5%B1%9E%E4%BA%8E%E5%93%AA%E7%A7%8D%E6%B5%81%EF%BC%9F%E4%BB%96%E4%B8%BB%E8%A6%81%E6%98%AF%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F-%E5%9B%BD-%E7%94%B5%E7%BD%91"><span class="toc-text">1. BufferedReader属于哪种流？他主要是用来做什么的？(国*电网)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F-%E5%8C%97%E4%BA%AC%E4%B8%AD%E6%B2%B9"><span class="toc-text">2. 什么是缓冲区？有什么作用？(北京中油**)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-text">转换流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E8%BD%AC%E6%8D%A2%EF%BC%9F-%E5%8C%97%E4%BA%AC%E8%93%9D-%E3%80%81-%E6%B5%B7-%E4%BE%9B%E5%BA%94%E9%93%BE%E7%AE%A1%E7%90%86%EF%BC%89"><span class="toc-text">1. 字节流和字符流是什么？怎么转换？(北京蓝*、*海*供应链管理）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFJava%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-%E5%90%9B-%E7%A7%91%E6%8A%80%E3%80%81%E4%B8%8A%E6%B5%B7-%E5%8E%A6%E7%89%A9%E8%81%94%E7%BD%91"><span class="toc-text">1. 什么是Java序列化，如何实现(君*科技、上海*厦物联网)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Java%E6%9C%89%E4%BA%9B%E7%B1%BB%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%AE%9E%E7%8E%B0Serializable%E6%8E%A5%E5%8F%A3%EF%BC%9F%EF%BC%88%E9%98%BF-%E6%A0%A1%E6%8B%9B%EF%BC%89"><span class="toc-text">2. Java有些类中为什么需要实现Serializable接口？（阿*校招）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-text">网络编程概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E7%B4%A01%EF%BC%9AIP%E5%9C%B0%E5%9D%80"><span class="toc-text">要素1：IP地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E7%B4%A02%EF%BC%9A%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-text">要素2：端口号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E7%B4%A03%EF%BC%9A%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="toc-text">要素3：网络通信协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">TCP网络编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">UDP网络编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#URL%E7%BC%96%E7%A8%8B"><span class="toc-text">URL编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89"><span class="toc-text">企业真题（十六）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-TCP%E5%8D%8F%E8%AE%AE%E5%92%8CUDP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E5%8D%8E-%E4%B8%BA%EF%BC%89"><span class="toc-text">1. TCP协议和UDP协议的区别（华**为）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%9C%BA%E5%88%B6-%EF%BC%88-%E7%A7%91%E8%BD%AF%EF%BC%89"><span class="toc-text">2. 简单说说TCP协议的三次握手与四次挥手机制 （*科软）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="toc-text">反射机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-text">反射的概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class-%E5%8F%8D%E5%B0%84%E7%9A%84%E6%BA%90%E5%A4%B4"><span class="toc-text">Class:反射的源头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E3%80%81%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89"><span class="toc-text">类的加载过程、类的加载器（理解）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A81%EF%BC%9A%E5%88%9B%E5%BB%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-text">反射的应用1：创建运行时类的对象（重点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A82%EF%BC%9A%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E6%89%80%E6%9C%89%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">反射的应用2：获取运行时类所有的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A83%EF%BC%9A%E8%B0%83%E7%94%A8%E6%8C%87%E5%AE%9A%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-text">反射的应用3：调用指定的结构（重点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A84%EF%BC%9A%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">反射的应用4：注解的使用（了解）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%93%E4%BC%9A%EF%BC%9A%E5%8F%8D%E5%B0%84%E7%9A%84%E5%8A%A8%E6%80%81%E6%80%A7"><span class="toc-text">体会：反射的动态性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89"><span class="toc-text">企业真题（十七）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%A6%82%E8%BF%B0"><span class="toc-text">反射概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AF%B9%E5%8F%8D%E5%B0%84%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E5%8F%8D%E5%B0%84%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8F%8D%E5%B0%84%EF%BC%9F%EF%BC%88%E5%BE%AE-%E9%93%B6%E8%A1%8C%EF%BC%89"><span class="toc-text">1. 对反射了解吗？反射有什么好处？为什么需要反射？（微*银行）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E5%90%88%E5%92%8C%E4%BD%9C%E7%94%A8%E3%80%81%E5%8F%8A%E5%85%B6%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%88-%E8%BD%AF%E5%9B%BD%E9%99%85%EF%BC%89"><span class="toc-text">2. 反射的使用场合和作用、及其优缺点（*软国际）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AE%9E%E7%8E%B0Java%E5%8F%8D%E5%B0%84%E7%9A%84%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F-%E5%90%9B-%E7%A7%91%E6%8A%80"><span class="toc-text">3. 实现Java反射的类有什么？(君*科技)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%8F%8D%E5%B0%84%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F%EF%BC%88%E4%B8%8A%E6%B5%B7%E7%AB%8B-%E7%BD%91%E7%BB%9C%EF%BC%89"><span class="toc-text">4. 反射是怎么实现的？（上海立*网络）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">Class的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Class%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F%E7%94%9F%E6%88%90Class%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-%E9%A1%BA"><span class="toc-text">1. Class类的作用？生成Class对象的方法有哪些？(顺*)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Class-forName-%E2%80%9C%E5%85%A8%E8%B7%AF%E5%BE%84%E2%80%9D-%E4%BC%9A%E8%B0%83%E7%94%A8%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95-%EF%BC%9F-%E4%BC%9A%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%90%97%EF%BC%9F%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%B1%BB%E4%BC%9A%E6%94%BE%E5%9C%A8%E5%93%AA%EF%BC%9F%EF%BC%88%E4%B8%8A-%E9%93%B6%E8%A1%8C%E5%A4%96%E5%8C%85%EF%BC%89"><span class="toc-text">2. Class.forName(“全路径”) 会调用哪些方法 ？ 会调用构造方法吗？加载的类会放在哪？（上*银行外包）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="toc-text">类的加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%EF%BC%88%E6%B1%87-%E9%80%9A%E3%80%81%E5%90%8C-%E9%A1%BA%E3%80%81%E5%87%A1-%E7%A7%91%E6%8A%80%EF%BC%89"><span class="toc-text">1. 类加载流程（汇**通、同*顺、凡*科技）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">创建对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%9F%EF%BC%88%E5%8D%8E%E6%B2%B9-%E9%9B%86%E5%9B%A2%E3%80%81-%E7%A7%91%E8%BD%AF%E3%80%81%E5%87%A1-%E7%A7%91%E6%8A%80%EF%BC%89"><span class="toc-text">1. 说一下创建对象的几种方法？（华油***集团、*科软、凡*科技）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%AF%B9%E8%B1%A1%E5%AE%9E%E9%99%85%E7%B1%BB%E7%9A%84%EF%BC%9F%EF%BC%88-%E5%BA%A6%EF%BC%89"><span class="toc-text">2. 如何找到对象实际类的？（*度）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Java%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%95%88%E7%8E%87%E9%AB%98%E8%BF%98%E6%98%AF%E9%80%9A%E8%BF%87new%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%95%88%E7%8E%87%E9%AB%98%EF%BC%9F-%E4%B8%89-%E9%87%8D%E5%B7%A5"><span class="toc-text">3. Java反射创建对象效率高还是通过new创建对象的效率高？(三*重工)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%B1%9E%E6%80%A7%E3%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">调用属性、方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%9D%A5%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F%EF%BC%88%E7%A5%9E%E5%B7%9E-%E8%BD%AF%E4%BB%B6%EF%BC%89"><span class="toc-text">1. 如何利用反射机制来访问一个类的方法？（神州**软件）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AF%B4%E4%B8%80%E4%B8%8BJava%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%EF%BC%8C%E5%A6%82%E4%BD%95%E6%94%B9%E5%8F%98%E5%80%BC%EF%BC%9F%EF%BC%88%E9%98%BF-%E9%BA%BB%E4%BF%A1%E7%94%A8%E9%A1%B9%E7%9B%AE%E7%BB%84%EF%BC%89"><span class="toc-text">2. 说一下Java反射获取私有属性，如何改变值？（阿****麻信用项目组）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">JDK8-17新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E7%89%88%E6%9C%AC%E8%BF%AD%E4%BB%A3%E6%A6%82%E8%BF%B0"><span class="toc-text">Java版本迭代概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%89%88%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-text">各版本介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#jdk-9"><span class="toc-text">jdk 9</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jdk-10"><span class="toc-text">jdk 10</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jdk-11"><span class="toc-text">jdk 11</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jdk-12"><span class="toc-text">jdk 12</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jdk-13"><span class="toc-text">jdk 13</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jdk-14"><span class="toc-text">jdk 14</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jdk-15"><span class="toc-text">jdk 15</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jdk-16"><span class="toc-text">jdk 16</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jdk-17"><span class="toc-text">jdk 17</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9ALambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">Java8新特性：Lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF"><span class="toc-text">场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lambda-%E5%8F%8A%E5%85%B6%E8%AF%AD%E6%B3%95"><span class="toc-text">Lambda 及其语法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E5%87%BD%E6%95%B0%E5%BC%8F-Functional-%E6%8E%A5%E5%8F%A3"><span class="toc-text">Java8新特性：函数式(Functional)接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">什么是函数式接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">如何理解函数式接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">Java 内置函数式接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-text">练习</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E4%B8%8E%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"><span class="toc-text">Java8新特性：方法引用与构造器引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-text">方法引用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E6%A0%BC%E5%BC%8F"><span class="toc-text">方法引用格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E4%BD%BF%E7%94%A8%E5%89%8D%E6%8F%90"><span class="toc-text">方法引用使用前提</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"><span class="toc-text">构造器引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%9E%84%E9%80%A0%E5%BC%95%E7%94%A8"><span class="toc-text">数组构造引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E5%BC%BA%E5%A4%A7%E7%9A%84Stream-API"><span class="toc-text">Java8新特性：强大的Stream API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Stream%E7%9A%84%E6%93%8D%E4%BD%9C%E4%B8%89%E4%B8%AA%E6%AD%A5%E9%AA%A4"><span class="toc-text">Stream的操作三个步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAStream%E5%AE%9E%E4%BE%8B"><span class="toc-text">创建Stream实例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E7%B3%BB%E5%88%97%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C"><span class="toc-text">一系列中间操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2%E6%93%8D%E4%BD%9C"><span class="toc-text">终止操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java9%E6%96%B0%E5%A2%9EAPI"><span class="toc-text">Java9新增API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84"><span class="toc-text">新语法结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E7%9A%84REPL%E5%B7%A5%E5%85%B7%EF%BC%9A-jShell%E5%91%BD%E4%BB%A4"><span class="toc-text">Java的REPL工具： jShell命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B9%8Btry-catch%E8%B5%84%E6%BA%90%E5%85%B3%E9%97%AD"><span class="toc-text">异常处理之try-catch资源关闭</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-text">局部变量类型推断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#instanceof%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-text">instanceof的模式匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#switch%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">switch表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E5%9D%97"><span class="toc-text">文本块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Record"><span class="toc-text">Record</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%86%E5%B0%81%E7%B1%BB"><span class="toc-text">密封类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-text">API的变化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Optional-%E7%B1%BB"><span class="toc-text">Optional 类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%92%8CAPI%E5%8F%98%E6%9B%B4"><span class="toc-text">String存储结构和API变更</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Description"><span class="toc-text">Description</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK17%EF%BC%9A%E6%A0%87%E8%AE%B0%E5%88%A0%E9%99%A4Applet-API"><span class="toc-text">JDK17：标记删除Applet API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E7%BB%93%E6%9E%84%E5%8F%98%E5%8C%96"><span class="toc-text">其它结构变化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK9%EF%BC%9AUnderScore-%E4%B8%8B%E5%88%92%E7%BA%BF-%E4%BD%BF%E7%94%A8%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-text">JDK9：UnderScore(下划线)使用的限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK11%EF%BC%9A%E6%9B%B4%E7%AE%80%E5%8C%96%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="toc-text">JDK11：更简化的编译运行程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GC%E6%96%B9%E9%9D%A2%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">GC方面新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#G1-GC"><span class="toc-text">G1 GC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Shenandoah-GC"><span class="toc-text">Shenandoah GC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%A9%E5%91%BD%E6%80%A7%E7%9A%84-ZGC"><span class="toc-text">革命性的 ZGC</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89"><span class="toc-text">企业真题（十八）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JDK%E6%96%B0%E7%89%B9%E6%80%A7%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-text">1. JDK新特性的概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-JDK8-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">2. JDK8:lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">2.1 什么情况下可以使用lambda表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">2.2 函数式接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E3%80%81%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8%E3%80%81%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8"><span class="toc-text">2.3 方法引用、构造器引用、数组引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-JDK8-Stream-API%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">3. JDK8:Stream API的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-JDK8%E4%B9%8B%E5%90%8E%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E8%AF%AD%E6%B3%95%E5%B1%82%E9%9D%A2"><span class="toc-text">4. JDK8之后的新特性：语法层面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-JDK8%E4%B9%8B%E5%90%8E%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E5%85%B6%E5%AE%83"><span class="toc-text">5. JDK8之后的新特性：其它</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BC%81%E4%B8%9A%E7%9C%9F%E9%A2%98"><span class="toc-text">二、企业真题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK8%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">JDK8新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%B0%88%E8%B0%88java8%E6%96%B0%E7%89%B9%E6%80%A7-%E4%BA%AC-%E6%97%97%E4%B8%8B%E3%80%81%E6%97%B6%E4%BB%A3-%E5%AE%87%EF%BC%8C%E4%BF%A1%E5%BF%85-%E3%80%81%E6%8B%9B-%E4%BF%A1%E8%AF%BA%EF%BC%8C%E4%B8%AD-%E5%A4%96%E5%8C%85%EF%BC%8C%E9%87%91-%E8%BD%AF%E4%BB%B6%E3%80%81%E9%98%BF-%E5%B7%B4"><span class="toc-text">1. 谈谈java8新特性(京*旗下、时代*宇，信必*、招*信诺，中*外包，金*软件、阿**巴)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-JDK1-8%E5%9C%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A%E5%8F%91%E7%94%9F%E4%BA%86%E5%93%AA%E4%BA%9B%E5%8F%98%E5%8C%96-%EF%BC%9F%EF%BC%88%E9%93%B6-%E6%95%B0%E6%8D%AE%EF%BC%89"><span class="toc-text">2. JDK1.8在数据结构上发生了哪些变化 ？（银*数据）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BD%A0%E8%AF%B4%E7%9A%84%E4%BA%86%E8%A7%A3-Java%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7-%EF%BC%8C%E4%BD%A0%E8%AF%B4%E8%AF%B4JDK8%E6%94%B9%E8%BF%9B%E7%9A%84%E5%9C%B0%E6%96%B9%EF%BC%9F%EF%BC%88%E9%93%B6-%E7%A7%91%E6%8A%80%EF%BC%89"><span class="toc-text">3. 你说的了解 Java的新特性 ，你说说JDK8改进的地方？（银*科技）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-JDK1-8%E7%94%A8%E7%9A%84%E6%98%AF%E5%93%AA%E4%B8%AA%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9F%EF%BC%88O-O%EF%BC%89"><span class="toc-text">4. JDK1.8用的是哪个垃圾回收器？（O**O）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">Lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9C%89%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%8C%E8%AF%B4%E8%AF%B4%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%9A%84%EF%BC%88O-O%EF%BC%89"><span class="toc-text">1. Lambda表达式有了解吗，说说如何使用的（O**O）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%EF%BC%9F%E6%9C%89%E5%87%A0%E7%A7%8D%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%EF%BC%88%E9%98%BF-%E5%B7%B4%EF%BC%89"><span class="toc-text">2. 什么是函数式接口？有几种函数式接口（阿**巴）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stream-API"><span class="toc-text">Stream API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BAStream%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%88%E9%98%BF-%E5%B7%B4%EF%BC%89"><span class="toc-text">1. 创建Stream的方式（阿**巴）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%A0%E8%AE%B2%E8%AE%B2stream%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%98%AF%E5%92%8B%E7%94%A8%E7%9A%84%EF%BC%8C%E5%B9%B2%E5%95%A5%E7%9A%84%EF%BC%9F%EF%BC%88%E4%B8%AD-%E5%9B%BD%E9%99%85%EF%BC%8C%E4%B8%8A%E6%B5%B7-%E7%BD%91%E7%BB%9C%EF%BC%89"><span class="toc-text">2. 你讲讲stream表达式是咋用的，干啥的？（中*国际，上海**网络）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%9B%86%E5%90%88%E7%94%A8Stream%E6%B5%81%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E8%BF%87%E6%BB%A4%EF%BC%9F%EF%BC%88%E6%B6%A6-%E8%BD%AF%E4%BB%B6%EF%BC%89"><span class="toc-text">3. 集合用Stream流怎么实现过滤？（润*软件）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%94%A8Stream%E6%80%8E%E4%B9%88%E9%80%89%E5%87%BAList%E9%87%8C%E6%83%B3%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9F%EF%BC%88%E6%83%A0-%EF%BC%89"><span class="toc-text">4. 用Stream怎么选出List里想要的数据？（惠*）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E7%89%88%E6%9C%AC%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">其它版本新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B4%E8%AF%B4JDK15%E3%80%81JDK16%E3%80%81JDK17%E4%B8%AD%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F-%E9%93%B6-%E6%95%B0%E6%8D%AE"><span class="toc-text">1. 说说JDK15、JDK16、JDK17中的新特性都有什么？(银*数据)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IDEA%E7%9A%84%E6%97%A5%E5%B8%B8%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%92%8CDebug"><span class="toc-text">IDEA的日常快捷键和Debug</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%BB%84%EF%BC%9A%E9%80%9A%E7%94%A8%E5%9E%8B"><span class="toc-text">第1组：通用型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%BB%84%EF%BC%9A%E6%8F%90%E9%AB%98%E7%BC%96%E5%86%99%E9%80%9F%E5%BA%A6%EF%BC%88%E4%B8%8A%EF%BC%89"><span class="toc-text">第2组：提高编写速度（上）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%BB%84%EF%BC%9A%E6%8F%90%E9%AB%98%E7%BC%96%E5%86%99%E9%80%9F%E5%BA%A6%EF%BC%88%E4%B8%8B%EF%BC%89"><span class="toc-text">第3组：提高编写速度（下）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%BB%84%EF%BC%9A%E7%B1%BB%E7%BB%93%E6%9E%84%E3%80%81%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9F%A5%E7%9C%8B%E6%BA%90%E7%A0%81"><span class="toc-text">第4组：类结构、查找和查看源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%BB%84%EF%BC%9A%E6%9F%A5%E6%89%BE%E3%80%81%E6%9B%BF%E6%8D%A2%E4%B8%8E%E5%85%B3%E9%97%AD"><span class="toc-text">第5组：查找、替换与关闭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%BB%84%EF%BC%9A%E8%B0%83%E6%95%B4%E6%A0%BC%E5%BC%8F"><span class="toc-text">第6组：调整格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Debug%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-text">Debug快捷键</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86"><span class="toc-text">面试题整理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text"></span></a></li></ol></li></ol>
    </div>
  </div>


            </div>
        
        
          <blockquote id="copyright">
              <p>Original link: <a href="http://example.com/2023/04/10/offer-Java/">http://example.com/2023/04/10/offer-Java/</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
        
<nav id="article-nav">
  
    <a href="/2023/04/10/offer-JUC/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">older</strong>
      <div class="article-nav-title">
        
          offer---JUC
        
      </div>
    </a>
  
  
    <a href="/2023/04/27/Dialog-Papers/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">newer</strong>
      <div class="article-nav-title">
        
          Dialog Papers
        
      </div>
    </a>
  
</nav>

      
      
        








      
    </footer>
  </div>
</article>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-posts"></i> Recent</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/09/04/offer-%E5%BE%AE%E6%9C%8D%E5%8A%A1/">offer-微服务</a>
          </li>
        
          <li>
            <a href="/2024/07/04/redis7/">redis7</a>
          </li>
        
          <li>
            <a href="/2024/06/17/offer-ES/">offer-ES</a>
          </li>
        
          <li>
            <a href="/2024/04/18/Java-gulimall/">Java-gulimall</a>
          </li>
        
          <li>
            <a href="/2024/03/11/offer-JVM/">offer-JVM</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-tag"></i> Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CRS/" style="font-size: 20px;">CRS</a> <a href="/tags/ChatGPT/" style="font-size: 20px;">ChatGPT</a> <a href="/tags/Dialog/" style="font-size: 10px;">Dialog</a> <a href="/tags/JAVA/" style="font-size: 15px;">JAVA</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/LLM/" style="font-size: 10px;">LLM</a> <a href="/tags/PyTorch/" style="font-size: 10px;">PyTorch</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/SSM/" style="font-size: 10px;">SSM</a> <a href="/tags/Web/" style="font-size: 10px;">Web</a> <a href="/tags/flask-vue-mysql/" style="font-size: 10px;">flask,vue,mysql</a>
    </div>
  </div>

  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-archive"></i> Archive</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/">2024年</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/">2023年</a><span class="archive-list-count">17</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-tag"></i> Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CRS/" rel="tag">CRS</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ChatGPT/" rel="tag">ChatGPT</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dialog/" rel="tag">Dialog</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LLM/" rel="tag">LLM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PyTorch/" rel="tag">PyTorch</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSM/" rel="tag">SSM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flask-vue-mysql/" rel="tag">flask,vue,mysql</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-link"></i> Blogroll</h3>
    <div class="widget">
      <ul>
      
        <li>
          <a target="_blank" rel="noopener" href="http://www.example1.com/">site-name1</a>
        </li>
      
        <li>
          <a target="_blank" rel="noopener" href="http://www.example2.com/">site-name2</a>
        </li>
      
        <li>
          <a target="_blank" rel="noopener" href="http://www.example3.com/">site-name3</a>
        </li>
      
      </ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <a id="totop" href="#top"></a>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <p>
        <a href="/sitemap.xml">Site Map</a>
        <span> | </span><a href="/atom.xml">Subscribe to this site</a>
        <span> | </span><a href="/about/">Contact the blogger</a>
      </p>
      
        <p>
          <i class="fa fa-visitors"></i>
          <i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>
          ，
          <i class="fa fa-views"></i>
          <i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>
        </p>
      
      <p>
        <span>Copyright &copy; 2024 JupiterTop.</span>
        <span>Theme by <a href="https://github.com/chaooo/hexo-theme-BlueLake/" target="_blank">BlueLake.</a></span>
        <span>Powered by <a href="https://hexo.io/" target="_blank">Hexo.</a></span>
      </p>
    </div>
  </div>
</footer>


    </div>
  </div>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/search.json.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>






  
<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  
    
<script src="/localshare/js/social-share.js"></script>

    
<script src="/localshare/js/qrcode.js"></script>

  
  



  

  

  

  

  

  

  

  
  





</body>
</html>