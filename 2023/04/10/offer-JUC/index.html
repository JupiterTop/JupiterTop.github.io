<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>offer---JUC | wBlog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  
  
    <link rel="alternate" href="/atom.xml" title="wBlog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="/localshare/css/share.css">

  
  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">wBlog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/."><i class="fa fa-home"></i> Home</a>
        
          <a class="main-nav-link" href="/archives/"><i class="fa fa-archive"></i> Archive</a>
        
          <a class="main-nav-link" href="/about/"><i class="fa fa-user"></i> About</a>
        
          <a class="main-nav-link" href="/atom.xml"><i class="fa fa-rss"></i> RSS</a>
        
      </nav>
    </div>
    <div id="search-form">
      <div id="result-mask" class="hide"></div>
      <label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label>
      <div id="result-wrap" class="hide">
        <div id="search-result"></div>
      </div>
      <div class="hide">
        <template id="search-tpl">
          <div class="item">
            <a href="/{path}" title="{title}">
              <div class="title">{title}</div>
              <div class="time">{date}</div>
              <div class="tags">{tags}</div>
            </a>
          </div>
        </template>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-offer-JUC" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      offer---JUC
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2023-04-10T10:30:06.000Z" itemprop="datePublished">2023年04月10日</time>
</span>
      
      
        <span class="article-views">
  <i class="fa fa-views"></i>
  <i id="busuanzi_container_page_pv">
      <i id="busuanzi_value_page_pv"></i>
  </i>
</span>
      
      
<a href="/2023/04/10/offer-JUC/#comments" class="article-comment-link">
  
    
    
    
    
    
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


      
    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="JAVA并发编程—JUC-基础篇-java-util-concurrent"><a href="#JAVA并发编程—JUC-基础篇-java-util-concurrent" class="headerlink" title="JAVA并发编程—JUC-基础篇  (java.util.concurrent)"></a>JAVA并发编程—JUC-基础篇  (java.util.concurrent)</h1><h2 id="JUC概述"><a href="#JUC概述" class="headerlink" title="JUC概述"></a>JUC概述</h2><ul>
<li>进程与线程的区别  </li>
<li>线程的状态（New新建，Runnable准备就绪，Blocked阻塞，Waiting不见不散，Timed_waiting过时不候）  </li>
<li>wait和sleep的区别：<ol>
<li>sleep是Thread的静态方法，wait是Object的方法，任何对象实例都能调用。  </li>
<li>sleep不会释放锁，它也不需要占用锁。wait会释放锁，但调用它的前提是当前线程占有锁（即代码要在synchronized中）。  </li>
<li>它们都可以被interrupted方法中断。</li>
</ol>
</li>
<li>并发和并行的区别：同一时刻多个线程在访问同一个资源，多个线程对一个点（春运抢票）；多项工作一起执行，之后再汇总（泡面的例子）。  </li>
<li>管程、用户线程和守护线程</li>
</ul>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>Monitor监视器，锁，是一种同步机制，保证同一个时间，只有一个线程访问被保护数据或者代码。JVM同步基于进入和退出，使用管程对象实现的。  </p>
<h3 id="用户线程和守护线程"><a href="#用户线程和守护线程" class="headerlink" title="用户线程和守护线程"></a>用户线程和守护线程</h3><ul>
<li>用户线程：自定义线程（主线程结束了，用户线程还在运行，JVM存活）</li>
<li>守护线程：默默执行在后台的线程，比如垃圾回收（没有用户线程了，都是守护线程，JVM结束）</li>
</ul>
<h2 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h2><h3 id="Synchronized关键字"><a href="#Synchronized关键字" class="headerlink" title="Synchronized关键字"></a>Synchronized关键字</h3><p>同步锁。 </p>
<ol>
<li>修饰一个代码块；  </li>
<li>修饰一个方法；  </li>
<li>修饰一个静态方法；</li>
<li>修改一个类。</li>
</ol>
<p>多线程编程的步骤：1. 创建资源类，在资源类中创建属性和操作方法；2. 在资源类操作方法，判断，干活，通知；3. 创建多个线程，调用资源类的操作方法；  </p>
<p>卖票示例：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: 卖出 :&quot;</span> + (number--) + <span class="string">&quot;剩下:&quot;</span> + number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicket</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                    ticket.sale();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;aa&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                    ticket.sale();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;bb&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                    ticket.sale();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;cc&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="什么是Lock接口"><a href="#什么是Lock接口" class="headerlink" title="什么是Lock接口"></a>什么是Lock接口</h3><p>手动实现上锁、释放锁。  </p>
<ul>
<li>可重入锁  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockTicket</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: 卖出 :&quot;</span> + (number--) + <span class="string">&quot;剩下:&quot;</span> + number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>Lock和synchronized的不同： </p>
<ol>
<li>Lock是一个接口，而synchronized是Java中的关键字；  </li>
<li>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unlock()去释放锁，则很可能造成死锁现象，这也是为什么需要在finally块中释放锁；  </li>
<li>Lock可以让等待锁的线程响应中断，而synchronized缺不行，等待的线程会一直等待下去，不能够响应中断；  </li>
<li>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到；  </li>
<li>Lock可以提高多个线程进行读操作的效率。</li>
</ol>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><ol>
<li>判断； </li>
<li>干活；  </li>
<li>通知；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Share</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//判断 if改成while</span></span><br><span class="line">        <span class="keyword">if</span> (number != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;:&quot;</span> +number);</span><br><span class="line">        <span class="comment">//通知其他线程</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//判断</span></span><br><span class="line">        <span class="keyword">if</span> (number != <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;:&quot;</span> +number);</span><br><span class="line">        <span class="comment">//通知其他线程</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Share</span> <span class="variable">share</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Share</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    share.incr();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;INCR&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    share.decr();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;DECR&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>虚假唤醒问题：wait()方法特点，在哪里睡，在哪里醒，就会导致if判断失效。所以解决方法是把if改成while。</li>
</ul>
<p>Lock实现：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockShare</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">0</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;:&quot;</span> +number);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">1</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;:&quot;</span> +number);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>进程间定制化通信：启动三个线程，按照“AA打印5次，BB打印10次，CC打印15次”进行十轮</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomShare</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">conditionA</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print5</span><span class="params">(<span class="type">int</span> loop)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">1</span>) &#123;</span><br><span class="line">                conditionA.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span> ; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + (i+<span class="number">1</span>) + <span class="string">&quot;:轮数:&quot;</span> + loop);</span><br><span class="line">            &#125;</span><br><span class="line">            flag = <span class="number">2</span>;</span><br><span class="line">            conditionA.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print10</span><span class="params">(<span class="type">int</span> loop)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">2</span>) &#123;</span><br><span class="line">                conditionA.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + (i+<span class="number">1</span>) + <span class="string">&quot;:轮数:&quot;</span> + loop);</span><br><span class="line">            &#125;</span><br><span class="line">            flag = <span class="number">3</span>;</span><br><span class="line">            conditionA.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print15</span><span class="params">(<span class="type">int</span> loop)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">3</span>) &#123;</span><br><span class="line">                conditionA.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">15</span> ; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + (i+<span class="number">1</span>) + <span class="string">&quot;:轮数:&quot;</span> + loop);</span><br><span class="line">            &#125;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            conditionA.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockCustomThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CustomShare</span> <span class="variable">customShare</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomShare</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                customShare.print5(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                customShare.print10(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                customShare.print15(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;CC&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="集合线程安全"><a href="#集合线程安全" class="headerlink" title="集合线程安全"></a>集合线程安全</h3><ol>
<li>List</li>
</ol>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">8</span>));   <span class="comment">// 报错位置</span></span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>报异常：java.util.ConcurrentModificationException  </p>
</li>
<li><p>原因是List.add()方法没有synchronized关键字修饰  </p>
</li>
<li><p>解决方案（一）：vector<br>  List<String> list &#x3D; new Vector&lt;&gt;();  &#x2F;&#x2F; JDK 1.0 Vector类中的方法有synchronized关键字修饰  </p>
</li>
<li><p>解决方案（二）：Collection工具类<br>  List<String> list &#x3D; Collections.synchronizedList(new ArrayList&lt;&gt;());   &#x2F;&#x2F; Collections.synchronizedList返回同步列表  </p>
</li>
<li><p>解决方案（三）：CopyOnWriteArrayList<br>  List<String> list &#x3D; new CopyOnWriteArrayList();  &#x2F;&#x2F; 写时复制技术，并发读、复制一份新内容，独立写  </p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><p>HashSet<br>解决方案：CopyOnWriteArraySet  </p>
</li>
<li><p>HashMap<br>解决方案：ConcurrentHashMap</p>
</li>
</ol>
<h2 id="多线程锁"><a href="#多线程锁" class="headerlink" title="多线程锁"></a>多线程锁</h2><h3 id="锁的范围"><a href="#锁的范围" class="headerlink" title="锁的范围"></a>锁的范围</h3><p>案例： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对应8</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;====endSMS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;====endEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;====getHello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailSMSThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone1.sendSMS();;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone2.sendEmail();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 8锁</span></span><br><span class="line"><span class="comment">1. 标准访问，先打印短信还是邮件；</span></span><br><span class="line"><span class="comment">====endSMS</span></span><br><span class="line"><span class="comment">====endEmail</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 停4秒在短信方法内，先打印短信还是邮件；</span></span><br><span class="line"><span class="comment">====endSMS</span></span><br><span class="line"><span class="comment">====endEmail</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. 新增普通的hello方法，先打印短信还是hello；</span></span><br><span class="line"><span class="comment">====getHello</span></span><br><span class="line"><span class="comment">====endSMS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4. 现在有两部手机，先打短信还是邮件；</span></span><br><span class="line"><span class="comment">====endEmail</span></span><br><span class="line"><span class="comment">====endSMS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5. 两个静态同步方法，一部手机，先打印短信还是邮件；</span></span><br><span class="line"><span class="comment">====endSMS</span></span><br><span class="line"><span class="comment">====endEmail</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">6. 两个静态同步方法，两部手机，先打印短信还是邮件；</span></span><br><span class="line"><span class="comment">====endSMS</span></span><br><span class="line"><span class="comment">====endEmail</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">7. 一个静态同步方法，一个普通同步方法，一部手机，先打印短信还是邮件；</span></span><br><span class="line"><span class="comment">====endEmail</span></span><br><span class="line"><span class="comment">====endSMS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">8. 一个静态同步方法，一个普通同步方法，两部手机，先打印短信还是邮件；</span></span><br><span class="line"><span class="comment">====endEmail</span></span><br><span class="line"><span class="comment">====endSMS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>1、2锁的是当前对象；3新增的普通方法与锁无关，所以先执行；4有两个对象，两把锁，各锁各的；5、6锁的范围是类Class；7、8一个锁的是对象，一个锁的是类。  </li>
<li>总结：synchronized实现同步的基础是Java中的每一个对象都可以作为锁。  <ol>
<li>对于普通同步方法，锁是当前实例对象。  </li>
<li>对于静态同步方法，锁是当前类的Class对象。  </li>
<li>对于同步方法块，锁是Synchronized括号里配置的对象。</li>
</ol>
</li>
</ul>
<h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><p>卖票案例中，三个线程，可能只有一个线程卖了全部的票，导致其他线程饿死，这是非公平锁的情况。</p>
<ul>
<li>非公平锁：线程饿死、效率高； 公平锁：阳光普照、效率相对低。</li>
</ul>
<h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><ul>
<li>又叫递归锁，synchronized（隐式）和Lock（显式）都是可重入锁（一把锁可进入各个区域）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        add();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;外层&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;中层&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;内层&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出: 外层、中层、内层</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li>两个或者两个以上进程在执行过程中，因为争夺资源而造成一种互相等待的现象。如果没有外力干涉，它们无法再执行下去。</li>
<li>原因：1. 系统资源不足 2. 进程运行推进顺序不合适  3. 资源分配不当</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (a)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;持有锁a，试图获取锁b&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (b)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;持有锁b&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (b)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;持有锁b，试图获取锁a&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (a)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;持有锁a&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>验证是否是死锁  <ol>
<li>jps -l类似linux ps -ef；先获取当前运行程序的进程号  </li>
<li>jstack jvm自带的堆栈跟踪工具，根据进程号查询。</li>
</ol>
</li>
</ul>
<h2 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h2><h3 id="创建线程的多种方式"><a href="#创建线程的多种方式" class="headerlink" title="创建线程的多种方式"></a>创建线程的多种方式</h3><ol>
<li>继承Thread类；  </li>
<li>实现Runnable接口；  </li>
<li>实现Callable接口；  </li>
<li>线程池的方式。</li>
</ol>
<h3 id="Runnable和Callable接口的区别"><a href="#Runnable和Callable接口的区别" class="headerlink" title="Runnable和Callable接口的区别"></a>Runnable和Callable接口的区别</h3><p>（1）是否有返回值：无；有<br>（2）是否抛出异常：无；有<br>（3）实现方法名称：run()；call()  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;come in callable&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// Runnable接口创建</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread1</span>(),<span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Callable接口，报错</span></span><br><span class="line">        <span class="comment">// new Thread(new MyThread2(),&quot;BB&quot;).start();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// FutureTask：一个可取消的异步计算</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask1 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyThread2</span>());</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask2 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;come in callable&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask1,<span class="string">&quot;jack&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask2,<span class="string">&quot;lucy&quot;</span>).start();</span><br><span class="line">        System.out.println(futureTask1.get());</span><br><span class="line">        System.out.println(futureTask2.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="辅助类"><a href="#辅助类" class="headerlink" title="辅助类"></a>辅助类</h2><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><ul>
<li><p>减法计数器；countDown()用来减一，该线程不会阻塞；当一个或多个线程调用await()方法时，这些线程会阻塞；当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行。  </p>
</li>
<li><p>示例：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">CountDownDemo</span> &#123;</span><br><span class="line">    <span class="comment">// 六个同学陆续离开教室之后，班长才可以锁门</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 同学离开了教室&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;班长锁门走人了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><ul>
<li>循环栅栏，加法计数器  </li>
<li>示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line">    <span class="comment">//创建固定值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NUMBER</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(NUMBER,()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;集齐7颗，召唤神龙&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;星龙被收集了&quot;</span>);</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><ul>
<li>计数信号量；信号量维护了一个许可集，如有必要，在许可可用前会阻塞每一个acquire()，然后再获取该许可。每个release()添加一个许可，从而可能释放一个正在阻塞的获取者。一个场景就是控制并发量。  </li>
<li>示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line">    <span class="comment">// 6辆车，停3个车位</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建Semaphore，设置许可数量</span></span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 6辆车  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//抢占</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;抢到了车位&quot;</span>);</span><br><span class="line">                    <span class="comment">//设置随机停车时间</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">5</span>));</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;离开了车位&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//释放</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><h3 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h3><p>悲观锁：不支持并发操作，频繁地上锁、释放锁，效率低。<br>乐观锁：支持并发，版本号控制，适用于多读的应用类型，这样可以提高吞吐量。  </p>
<ul>
<li>乐观锁的缺点：</li>
</ul>
<ol>
<li><p>ABA 问题</p>
<p> 如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 “ABA”问题。</p>
<p> JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
</li>
<li><p>循环时间长开销大</p>
<p> 自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p>
</li>
<li><p>只能保证一个共享变量的原子操作</p>
<p> CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。</p>
</li>
</ol>
<h3 id="表锁和行锁"><a href="#表锁和行锁" class="headerlink" title="表锁和行锁"></a>表锁和行锁</h3><ol>
<li><p>行锁（Row Lock）：<br> a. 锁定范围： 行锁是对表中的一行数据进行锁定，而不是锁定整个表。这意味着其他事务仍然可以访问表中的其他行，不受锁定行的影响。<br> b. 适用场景： 适用于高并发读写的情况，允许多个事务同时访问表的不同行，降低了锁的争用。</p>
</li>
<li><p>表锁（Table Lock）：<br> a. 锁定范围： 表锁是对整个表进行锁定，当一个事务获取了对表的锁时，其他事务无法同时访问该表，即使它们要访问的是不同的行。<br> b. 适用场景： 适用于需要保证整个表的一致性的场景，例如在对整个表进行大批量更新或者维护操作时。</p>
</li>
<li><p>粒度：<br> a. 行锁： 锁定的粒度更细，只影响到实际需要修改的行，不会对表的其他部分产生影响。<br> b. 表锁： 锁定的粒度更大，会阻塞对整个表的访问，可能导致并发性能下降。</p>
</li>
<li><p>性能：<br> a. 行锁： 在高并发读写的场景中性能较好，因为允许多个事务同时访问表的不同行。<br> b. 表锁： 在高并发写入的场景中可能会导致性能问题，因为需要等待对整个表的锁释放。</p>
</li>
<li><p>死锁风险：<br> a. 行锁： 会死锁；锁定粒度小，发生锁冲突的概率较低。<br> b. 表锁： 无死锁；锁定粒度大，发生锁冲突的概率最高。</p>
</li>
</ol>
<h3 id="读锁和写锁"><a href="#读锁和写锁" class="headerlink" title="读锁和写锁"></a>读锁和写锁</h3><ul>
<li>读锁：共享锁，会死锁。如1修改要等2读之后，2修改要等1读之后。  </li>
<li>写锁：独占锁，会死锁。<br>读写锁：一个资源可以被多个读线程访问，或者可以被一个写线程访问，但是不能同时存在读写进程，读写互斥，读读共享的。</li>
</ul>
<ol>
<li>无锁，多线程抢断资源；</li>
<li>添加锁，使用synchronized和ReentrantLock，都是独占的，每次只能来一个操作；</li>
<li>读写锁，读读可以共享，提升性能，同时多人进行读操作，缺点（1造成锁饥饿，一直读没有写；2读时候，不能写，只有读完成之后，才可以写，写操作可以读）</li>
</ol>
<ul>
<li>锁降级：将写入锁降级为读锁，读锁不能升级为写锁</li>
</ul>
<h3 id="读写锁案例"><a href="#读写锁案例" class="headerlink" title="读写锁案例"></a>读写锁案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCache</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReadWriteLock</span> <span class="variable">readWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="comment">// 放数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key,Object value)</span>&#123;</span><br><span class="line">        readWriteLock.writeLock().lock();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在写操作&quot;</span> +key);</span><br><span class="line">        map.put(key,value);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;写完了&quot;</span> +key);</span><br><span class="line">        readWriteLock.writeLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取数据</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        readWriteLock.readLock().lock();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在读操作&quot;</span> +key);</span><br><span class="line">        result = map.get(key);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;读完了&quot;</span> +key);</span><br><span class="line">        readWriteLock.readLock().unlock();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyCache</span> <span class="variable">myCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCache</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                myCache.put(num+<span class="string">&quot;&quot;</span>,num+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                myCache.get(num+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>通过一个共享的队列，使数据由队列的一端输入，从另外一端输出；当队列空时，获取元素的线程会被阻塞；当队列满时，添加元素的线程会被阻塞。  </p>
<p><img src="/../images/JUC/blockingQueue.png">  </p>
<p>为什么需要BlockingQueue？ 好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，BlockingQueue一手包办。  </p>
<p>BlockingQueue<E>的实现类：  </p>
<ol>
<li>ArrayBlockingQueue 由数组结构组成的有界阻塞队列  </li>
<li>LinkedBlockingQueue 由链表结构组成的有界（integer.MAX_VALUE）阻塞队列  </li>
<li>DelayQueue 使用优先级队列实现的延迟无界阻塞队列  </li>
<li>PriorityBlockingQueue 支持优先级排序的无界阻塞队列  </li>
<li>SynchronousQueue 不存储元素的阻塞队列，也即单个元素的队列  </li>
<li>LinkedTransferQueue 由链表结构组成的无界阻塞队列  </li>
<li>LinkedBlockingDeque 由链表结构组成的双向阻塞队列</li>
</ol>
<p>核心方法：<br><img src="/../images/JUC/blockingMethod.png">  </p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>优势：线程池做的工作只是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。<br>特点：  </p>
<ol>
<li>降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗；  </li>
<li>提高响应速度：当任务到达时，任务可以不需要等待线程创建就能立即执行；  </li>
<li>提高线程的可管理性：利用线程池进行统一的分配，调优和监控。</li>
</ol>
<h3 id="线程池的使用方式"><a href="#线程池的使用方式" class="headerlink" title="线程池的使用方式"></a>线程池的使用方式</h3><ol>
<li>Executors.newFixedThreadPool(int) 一池N线程  </li>
<li>Executors.newSingleThreadExecutor() 一个任务一个任务执行，一池一线程  </li>
<li>Executors.newCachedThreadPool() 线程池根据需求创建线程，可扩容</li>
</ol>
<h3 id="ThreadPoolExecutor的七个参数"><a href="#ThreadPoolExecutor的七个参数" class="headerlink" title="ThreadPoolExecutor的七个参数"></a>ThreadPoolExecutor的七个参数</h3><ul>
<li>int corePoolSize 常驻线程数量  </li>
<li>int maximumPoolSize 最大线程数量  </li>
<li>long KeepAliveTime, TimeUnit unit 线程存活时间  </li>
<li>BlockingQueue<Runnable> workQueue 阻塞队列  </li>
<li>ThreadFactory threadFactory 线程工厂  </li>
<li>RejectedExecutionHandler handle 拒绝策略</li>
</ul>
<p>线程池的工作流程：<br><img src="/../images/JUC/pool.png">  </p>
<p>JDK内置的拒绝策略：<br><img src="/../images/JUC/policy.png">  </p>
<h3 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h3><p>一般情况下，不允许使用Executors创建线程池，而是通过自定义ThreadPoolExecutor的方式，以规避资源耗尽的风险。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">2</span>,<span class="number">5</span>,<span class="number">2L</span>,TimeUnit.SECONDS,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">    Executors.defaultThreadFactory(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()</span><br><span class="line">);</span><br><span class="line">threadPool.execute(()-&gt;&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="Fork-x2F-Join"><a href="#Fork-x2F-Join" class="headerlink" title="Fork&#x2F;Join"></a>Fork&#x2F;Join</h2><p>Fork：把一个复杂任务进行分拆，大事化小<br>Join：把分拆任务的结果进行合并  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ForkJoinSumCalculate</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Long&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">259195479995561737L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> end;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">THURSHOLD</span> <span class="operator">=</span> <span class="number">10000L</span>;  <span class="comment">//临界值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ForkJoinSumCalculate</span><span class="params">(<span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Long <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">length</span> <span class="operator">=</span> end - start;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(length &lt;= THURSHOLD)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">middle</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="type">ForkJoinSumCalculate</span> <span class="variable">left</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinSumCalculate</span>(start, middle); </span><br><span class="line">            left.fork(); <span class="comment">//进行拆分，同时压入线程队列</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">ForkJoinSumCalculate</span> <span class="variable">right</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinSumCalculate</span>(middle+<span class="number">1</span>, end);</span><br><span class="line">            right.fork(); <span class="comment">//</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> left.join() + right.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h2><p>CompletableFuture  </p>
<ol>
<li><p>无返回值的异步调用  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CompletableFuture&lt;Void&gt; cf = CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">cf.get();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>有返回值的异步调用</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; cf = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1024</span>; </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">cf.whenComplete((u,t)-&gt;&#123;</span><br><span class="line">   <span class="comment">// u 返回值；t 异常信息 </span></span><br><span class="line">&#125;).get();</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="1-并发和并行"><a href="#1-并发和并行" class="headerlink" title="1. 并发和并行"></a>1. 并发和并行</h3><p>并发：一台机器上“同时”处理多个任务，但同一时刻只有一个在发生；<br>并行：在同一时刻，在多台处理器上同时处理多个任务。  </p>
<h3 id="2-进程、线程、管程"><a href="#2-进程、线程、管程" class="headerlink" title="2. 进程、线程、管程"></a>2. 进程、线程、管程</h3><p>进程：应用程序的一次执行过程，动态的，包括进程从创建、运行和消亡的过程。系统运行程序的基本单元。<br>线程：轻量级线程。同类的线程共享进程的堆和方法区，每个线程有自己的程序计数器、虚拟机栈和本地方法栈；操作系统调度的基本单元。<br>管程：Monitor，锁，一种同步机制。JVM同步基于管程，底层由C++实现。当JVM对象被用作同步锁时，JVM会为该对象关联一个Monitor；而该对象不再被用作同步锁或对象被垃圾回收时，Monitor可能会被JVM内部释放或重新利用。  </p>
<h3 id="3-线程的分类"><a href="#3-线程的分类" class="headerlink" title="3. 线程的分类"></a>3. 线程的分类</h3><p>1） 用户线程；2）守护线程：为其他线程服务的。thread.setDaemon(true)。没有用户线程，JVM结束。  </p>
<h3 id="4-Future接口（FutureTask实现类）-—JDK5"><a href="#4-Future接口（FutureTask实现类）-—JDK5" class="headerlink" title="4. Future接口（FutureTask实现类） —JDK5"></a>4. Future接口（FutureTask实现类） —JDK5</h3><p>特点：多线程，有返回值，异步任务<br>优点：和线程池异步多线程任务配合使用效率高；<br>缺点：get() 阻塞；isDone()轮询耗费CPU资源。  </p>
<h3 id="5-CompletableFuture-—JDK8"><a href="#5-CompletableFuture-—JDK8" class="headerlink" title="5. CompletableFuture  —JDK8"></a>5. CompletableFuture  —JDK8</h3><ul>
<li>出现的原因：1）针对Future的缺点；2）传入回调参数，实现复杂功能，以观察者模式。  </li>
<li>接口CompletionStage和类CompletableFuture  </li>
<li>静态构造方法：1）runAsyn无返回值；2）supplyAsyn有返回值。  </li>
<li>Executor参数说明：若未指定，则使用默认的ForkJoinPoolCommonPool()；自定义线程池为非守护线程，所以就会继续执行。用ForkJoinPool是守护线程，可能会出现main线程结束后，JVM也结束了。  </li>
<li>CompletableFuture可传入回调对象，当异步任务完成或发生异常时，自动调用回调对象。</li>
</ul>
<h3 id="6-函数式接口"><a href="#6-函数式接口" class="headerlink" title="6. 函数式接口"></a>6. 函数式接口</h3><table>
<thead>
<tr>
<th>接口名称</th>
<th>方法名称</th>
<th>参数</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>Runnable</td>
<td>run</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>Function</td>
<td>apply</td>
<td>1</td>
<td>有</td>
</tr>
<tr>
<td>Consume</td>
<td>accept</td>
<td>1</td>
<td>无</td>
</tr>
<tr>
<td>Supplier</td>
<td>get</td>
<td>无</td>
<td>有</td>
</tr>
<tr>
<td>BiConsumer</td>
<td>accept</td>
<td>2</td>
<td>无</td>
</tr>
</tbody></table>
<h3 id="7-CompletableFuture常用方法"><a href="#7-CompletableFuture常用方法" class="headerlink" title="7. CompletableFuture常用方法"></a>7. CompletableFuture常用方法</h3><ol>
<li><p>获取结果和主动触发计算：  </p>
<ul>
<li>get()；  </li>
<li>get(long timeout, TimeUnit unit)；  </li>
<li>join() 和get一样用，只是不抛出异常；  </li>
<li>getNow(T valuelfAbsent) —&gt;计算完成就返回正常值，否则返回备胎值（传入的参数），立即获取结果不阻塞  </li>
<li>complete(T value) —-&gt;是否打断get方法立即返回括号值</li>
</ul>
</li>
<li><p>对计算结果进行处理：  </p>
<ul>
<li>thenApply：计算结果存在依赖关系，串行化，有异常叫停  </li>
<li>handle：有异常也往下走  </li>
<li>thenAccept：接受任务的处理结果，并消费处理，无返回结果</li>
</ul>
<p> 如果执行第一个任务传入了自定义线程池，thenRun执行第二个任务，则共用同一个线程池；若用thenRunAsync则各用各的。<br> 原因：带Async的方法底层调用uniRunStage(asyncPool, action)更改线程池为默认的，而不是自定义的。  </p>
</li>
<li><p>对计算速度进行选用：<br> playA.applyToEither(playB, f -&gt; {<br>     return f + “ is winner”;<br> });  </p>
</li>
<li><p>对计算结果进行了合并：<br> 两个CompletableStage任务都完成后，最终能把两个任务的结果一起交给thenCombine来处理；先完成的先等着，等待其他分支任务。</p>
</li>
</ol>
<h3 id="8-悲观锁和乐观锁"><a href="#8-悲观锁和乐观锁" class="headerlink" title="8. 悲观锁和乐观锁"></a>8. 悲观锁和乐观锁</h3><p>悲观锁：synchronized和Lock的实现类，适合写操作多的场景；<br>乐观锁：版本号机制Version，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。适合读操作多的场景。  </p>
<h3 id="9-synchronized线程8锁问题"><a href="#9-synchronized线程8锁问题" class="headerlink" title="9. synchronized线程8锁问题"></a>9. synchronized线程8锁问题</h3><ul>
<li>对于普通同步方法，锁的是当前实例对象，通常指this，所有的同步方法用的都是同一把锁—&gt;实例对象本身  </li>
<li>对于静态同步方法，锁的时当前类的Class对象  </li>
<li>对于同步方法块，锁的时synchronized括号内的对象</li>
</ul>
<h3 id="10-从字节码角度分析synchronized实现"><a href="#10-从字节码角度分析synchronized实现" class="headerlink" title="10. 从字节码角度分析synchronized实现"></a>10. 从字节码角度分析synchronized实现</h3><ul>
<li>synchronized同步代码块：实现使用的是monitorenter和monitorexit指令；一般是一个enter两个exit，一个正常情况退出锁，一个异常情况退出锁。  </li>
<li>synchronized普通同步方法：ACC_SYNCHRONIZED访问标志。  </li>
<li>synchronized静态同步方法：ACC_STATIC、ACC_SYNCHRONIZED访问标志。</li>
</ul>
<p>为什么任何一个对象都可以成为一个锁？<br>C++源码：ObjectMonitor.java—&gt;ObjectMonitor.cpp—&gt;ObjectMonitor.hpp<br>每个对象天生都带着一个对象监视器，每一个被锁住的对象都会和Monitor关联起来。  </p>
<h3 id="11-公平锁与非公平锁"><a href="#11-公平锁与非公平锁" class="headerlink" title="11. 公平锁与非公平锁"></a>11. 公平锁与非公平锁</h3><ol>
<li><p>为什么会有公平锁&#x2F;非公平锁的设计？为什么默认非公平？<br> 非公平锁能更充分地利用CPU的时间片，尽量减少CPU空闲状态时间。减少线程切换的开销。可能产生线程饥饿。  </p>
</li>
<li><p>什么时候用公平？什么时候用非公平？<br> 如果为了更高的吞吐量，很显然非公平锁是比较合适的，因为节省了很多线程切换的时间，吞吐量自然就上去了；否则就用公平锁，大家公平使用。</p>
</li>
</ol>
<h3 id="12-可重入锁"><a href="#12-可重入锁" class="headerlink" title="12. 可重入锁"></a>12. 可重入锁</h3><ol>
<li>隐式锁（即synchronized关键字使用的锁）；  </li>
<li>显式锁（即Lock）也有ReentrantLock这样的可重入锁；<br>Objectmonitor底层会维护一个计数器每lock一次就+1，每unlock一次-1，0表示没有线程占用。(因此lock和unlock要成对出现)</li>
</ol>
<h3 id="13-死锁及排查"><a href="#13-死锁及排查" class="headerlink" title="13. 死锁及排查"></a>13. 死锁及排查</h3><p>死锁产生原因：<br>    - 系统资源不足<br>    - 进程运行推进顺序不合适<br>    - 系统资源分配不当  </p>
<p>排查：  </p>
<ol>
<li>jps -l +   jstack 进程编号  </li>
<li>jconsole图形化</li>
</ol>
<h3 id="14-线程中断"><a href="#14-线程中断" class="headerlink" title="14. 线程中断"></a>14. 线程中断</h3><ul>
<li>一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止，所以，Thread.stop,Thread.suspend,Thread.resume都已经被废弃了  </li>
<li>Java中没有办法立即停止一条线程，Java提供了一种用于停止线程的协商机制—-中断，中断的过程完全需要程序员自行实现。</li>
</ul>
<p>三个方法：  </p>
<ol>
<li>public void interrupt() 仅仅是设置线程的中断状态为true，发起一个协商而不会立刻停止线程  </li>
<li>public static boolean interrupted() 判断线程是否被中断并清除当前中断状态，重新设置为false  </li>
<li>public boolean isInterrupted()   判断当前线程是否被中断（通过检查中断标志位）</li>
</ol>
<p><strong>如何停止终端运行中的线程？</strong>  </p>
<ol>
<li><p>通过一个volatile变量实现  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        if (isStop) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; isStop的值被改为true，t1程序停止&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;-----------hello volatile&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &quot;t1&quot;).start();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过AutomicBoolean  </p>
</li>
<li><p>通过Thread类自带的中断API实例方法实现—-在需要中断的线程中不断监听中断状态，一旦发生中断，就执行相应的中断处理业务逻辑stop线程。</p>
</li>
</ol>
<p><strong>当前线程的中断标识为true，是不是线程就立刻停止？</strong>  </p>
<ul>
<li>如果线程处于正常活动状态，那么会将该线程的中断标志设置为true，仅此而已，被设置中断标志的线程将继续正常运行，不受影响，所以interrupt()并不能真正的中断线程，需要被调用的线程自己进行配合才行，对于不活动的线程没有任何影响。  </li>
<li>如果线程处于阻塞状态（例如sleep,wait,join状态等），在别的线程中调用当前线程对象的interrupt方法，那么线程将立即退出被阻塞状态（interrupt状态也将被清除），并抛出一个InterruptedException异常。</li>
</ul>
<p><strong>静态方法Thread.interrupted()，谈谈你的理解？</strong><br>中断标识被清空，如果该方法连续被调用两次，第二次调用将返回false；除非当前线程在第一次调用和第二次调用该方法之间再次被interrupt。  </p>
<h3 id="15-LockSupport"><a href="#15-LockSupport" class="headerlink" title="15. LockSupport"></a>15. LockSupport</h3><p>LockSupport是用来创建锁和其他同步类的基本线程阻塞原语，其中park()和unpack()而作用分别是阻塞线程和解除阻塞线程。  </p>
<p><strong>三种让线程等待和唤醒的方法</strong>  </p>
<ol>
<li>使用Object中的wait()方法让线程等待，使用Object中的notify()方法唤醒线程  </li>
<li>使用JUC包中的Condition的await()方法让线程等待，使用signal()方法唤醒线程  </li>
<li>LockSupport类可以阻塞当前线程以及唤醒指定被阻塞的线程</li>
</ol>
<p><strong>LockSupport类中的park等待和unpark唤醒</strong>  </p>
<ul>
<li>LockSupport类使用了一种名为Permit（许可）的概念来做到阻塞和唤醒线程的功能，每个线程都有一个许可（Permit），许可证只能有一个，累加上限是1。  </li>
<li>park&#x2F;park(Object blocker)——-阻塞当前线程&#x2F;阻塞传入的具体线程；  </li>
<li>unpark(Thread thread)——唤醒处于阻塞状态的指定线程</li>
</ul>
<p><strong>为什么要有LockSupport</strong>  </p>
<ol>
<li>wait和notify方法必须要在同步代码块或者方法里面，且成对出现使用，先wait再notify才ok。  </li>
<li>Condition中的线程等待和唤醒方法，需要先获取锁；一定要先await后signal。  </li>
<li>因为unpark获得了一个凭证，之后再调用park方法，就可以名正言顺的凭证消费，故不会阻塞，先发放了凭证后续可以畅通无阻。</li>
</ol>
<p><strong>为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程？</strong><br>因为凭证的数量最多为1，连续调用两次unpark和调用一次unpark效果一样，只会增加一个凭证，而调用两次park却需要消费两个凭证，证不够，不能放行。 </p>
<h3 id="16-Java内存模型之JMM"><a href="#16-Java内存模型之JMM" class="headerlink" title="16. Java内存模型之JMM"></a>16. Java内存模型之JMM</h3><p><strong>你知道什么是Java内存模型JMM吗？</strong><br>JMM（Java内存模型Java Memory Model）本身是一种抽象的概念并不真实存在，它仅仅描述的是一组约定或规范。通过这组规范定义了程序中（尤其是多线程）各个变量的读写访问方式并决定一个线程对共享变量的写入以及如何变成对另一个线程可见，关键技术点都是围绕多线程的原子性、可见性和有序性展开的。    </p>
<p><strong>为什么要有JMM，它为什么出现？作用和功能是什么？</strong><br>CPU的运行并不是直接操作内存而是先把内存里面的数据读到缓存，而内存的读和写操作的时候会造成不一致的问题。通过JMM来实现线程和主内存之间的抽象关系（线程之间的共享变量存储在主内存中，每个线程都有一个自己的本地工作内存，本地工作内存中存储了该线程用来读写共享变量的副本），屏蔽各个硬件平台和操作系统的内存访问差异以实现让Java程序在各种平台下都能达到一致性的内存访问效果。  </p>
<p><strong>JMM没有哪些特征或者它的三大特征是什么？</strong>  </p>
<ol>
<li>可见性：是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道该变更，JMM规定了所有的变量都存储在主内存中。  </li>
<li>原子性：指一个操作是不可被打断的，即多线程环境下，操作不能被其他线程干扰。  </li>
<li>有序性：为了提升性能，编译器和处理器通常会对指令序列进行重新排序。Java规范规定JVM线程内部维持顺序化语义，即只要程序的最终结果与它顺序话执行的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。指令重排可以保证串行语义一致，但没有义务保证多线程的语义也一致（可能产生“脏读”）。</li>
</ol>
<p><strong>JMM和volatile他们两个之间的关系？</strong><br>volatile关键字：<br>1、可见性；2、不保证原子性；3、禁止指令重排。</p>
<p><strong>happens-before先行原则你有了解过吗？</strong>  </p>
<ul>
<li>在JVM中，如果一个操作<strong>执行的结果</strong>需要对另一个操作可见或者代码重排序，那么这两个操作之间必须存在happens-before（先行发生）原则，逻辑上的先后关系。包含<strong>可见性</strong>和<strong>有序性</strong>的约束。</li>
</ul>
<p>八条规则：  </p>
<ol>
<li>次序规则：一个线程内，按照代码的顺序，写在前面的操作先行发生于写在后面的操作；  </li>
<li>锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作；  </li>
<li>volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作；  </li>
<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；  </li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作；  </li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；  </li>
<li>线程终止规则：线程中的所有操作都优先发生于对此线程的终止检测；  </li>
<li>对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。</li>
</ol>
<h3 id="17-volatile与JMM"><a href="#17-volatile与JMM" class="headerlink" title="17. volatile与JMM"></a>17. volatile与JMM</h3><p><strong>被volatile修饰的变量有什么特点？</strong>  </p>
<ul>
<li>可见性和有序性，但不保证原子性；  </li>
<li>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值立即刷新回主内存中；  </li>
<li>当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，重新回到主内存中读取最新共享变量的值；  </li>
<li>volatile凭什么可以保证可见性和有序性？——&gt;  内存屏障Memory Barrier  </li>
<li>系统底层确认变量的ACC_VOLATILE标识标志在相应的位置加入内存屏障。</li>
</ul>
<p><strong>内存屏障是什么？</strong><br>内存屏障（也称内存栅栏，屏障指令等）是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作，避免代码重排序。  </p>
<p><strong>内存屏障的分类</strong><br>粗分两种：  </p>
<ol>
<li>读屏障（Load Barrier）：在读指令之前插入读屏障，让工作内存或CPU高速缓存 当中的缓存数据失效，重新回到主内存中获取最新数据。  </li>
<li>写屏障（Store Barrier）：在写指令之后插入写屏障，强制把缓冲区的数据刷回到主内存中。</li>
</ol>
<p>细分四种：  </p>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>指令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LoadLoad</td>
<td>Load1;LoadLoad;Load2</td>
<td>保证Load1的读取操作在Load2及后续读取操作之前执行</td>
</tr>
<tr>
<td>StoreStore</td>
<td>Store1;StoreStore;Store2</td>
<td>在store2及其后的写操作执行前，保证Store1的写操作已经刷新到主内存</td>
</tr>
<tr>
<td>LoadStore</td>
<td>Load1;LoadStore;Store2</td>
<td>在Store2及其后的写操作执行前，保证Load1的读操作已经结束</td>
</tr>
<tr>
<td>StoreLoad</td>
<td>Store1;StoreLoad;Load2</td>
<td>保证Store1的写操作已经刷新到主内存后，Load2及其后的读操作才能执行</td>
</tr>
</tbody></table>
<p><strong>happens-before之volatile变量规则</strong>  </p>
<ul>
<li><p>当第一个操作为volatile读时，不论第二个操作是什么，都不能重排序，这个操作保证了volatile读之后的操作不会被重排到volatile读之前。  </p>
</li>
<li><p>当第一个操作为volatile写时，第二个操作为volatile读时，不能重排。  </p>
</li>
<li><p>当第二个操作为volatile写时，不论第一个操作是什么，都不能重排序，这个操作保证了volatile写之前的操作不会被重排到volatile写之后。  </p>
</li>
<li><p>读屏障：在每个volatile读操作的后面插入一个LoadLoad屏障和LoadStore屏障。  </p>
</li>
<li><p>写屏障：在每个volatile写操作的前面插入StoreStore屏障；在每个volatile写操作的后面插入StoreLoad屏障。</p>
</li>
</ul>
<p><strong>怎么理解volatile变量的复合操作不具有原子性</strong><br>对于voaltile变量具备可见性，JVM只是保证从主内存加载到线程工作内存的值是最新的，<em>也仅仅是数据加载时是最新的</em>。但是多线程环境下，“数据计算”和“数据赋值”操作可能多次出现，若数据在加载之后，若主内存volatile修饰变量发生修改之后，线程工作内存的操作将会作废去读主内存最新值，操作出现写丢失问题。即<em>各线程私有内存和主内存公共内存中变量不同步</em>，进而导致数据不一致。由此可见volatile解决的是变量读时的可见性问题，但无法保证原子性，对于多线程修改主内存共享变量的场景必须加锁同步。<br>举例i++的例子；  </p>
<p><strong>如何正确使用volatile</strong>  </p>
<ol>
<li>单一赋值可以，但是含复合运算赋值不可以；  </li>
<li>状态标志，判断业务是否结束；  </li>
<li>开销较低的读，写锁策略；当读远多于写，结合使用内部锁和volatile变量来减少同步的开销；  </li>
<li>DCL双端锁的发布，多线程下的解决方案适合加volatile修饰。   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 隐患：多线程环境下，由于重排序，该对象可能未完成初始化就被其他线程读取。</span></span><br><span class="line">                    <span class="comment">// 1. 为 uniqueInstance 分配内存空间; 2. 初始化 uniqueInstance; 3. 将 uniqueInstance 指向分配的内存地址。</span></span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="18-CAS"><a href="#18-CAS" class="headerlink" title="18. CAS"></a>18. CAS</h3><p><strong>CAS是什么？有什么缺点</strong>  </p>
<ul>
<li>没有CAS之前：多线程环境中使用valatile+synchronized保证线程安全i++；  </li>
<li>使用CAS之后：多线程环境中使用原子类CAS保证线程安全i++，类似于乐观锁。<br>CAS(compare and swap)，用于保证共享变量的<em>原子性</em>更新，它包含三个操作数—内存位置、预期原值与更新值。</li>
</ul>
<p>缺点：  </p>
<ol>
<li>循环时间长开销大。底层getAndAddInt方法有一个do while，如果CAS失败，会一直进行尝试，如果CAS长时间一直不成功，可能会给CPU带来很大开销；  </li>
<li>ABA问题。可使用版本号时间戳原子引用AtomicStampedReference<V> 。</li>
</ol>
<p><strong>CAS底层原理？谈谈对Unsafe类的理解？</strong><br>Unsafe类是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问，基于Unsafe类可以直接操作特定内存的数据。存在于sun.misc包中，Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的所有方法都直接调用操作系统底层资源执行相应任务。<br>问题：我们知道i++是线程不安全的，那AtomicInteger.getAndIncrement()如何保证原子性？  </p>
<ul>
<li>AtomicInteger类主要利用CAS+volatile和native方法来保证<em>原子操作</em>，从而避免synchronized的高开销，执行效率大为提升；调用Unsafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令。这是一种完全依赖于硬件的功能，通过它实现了原子操作。  </li>
<li>JDK提供的CAS机制，在汇编层级会禁止变量两侧的指令优化，然后使用compxchg指令比较并更新变量值（原子性）。</li>
</ul>
<p><strong>CAS与自旋锁</strong><br>CAS是实现自旋锁的基础，CAS利用CPU指令保证了操作的原子性，以达到锁的效果。自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁。好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。<br>实现一个自旋锁，借鉴CAS思想：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinLockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t --------come in&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="literal">null</span>, thread)) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        atomicReference.compareAndSet(thread, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t --------task over,unLock.........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="19-原子操作类"><a href="#19-原子操作类" class="headerlink" title="19. 原子操作类"></a>19. 原子操作类</h3><p>基本类型原子类：  </p>
<ul>
<li>AtomicInteger 整型原子类  </li>
<li>AtomicBoolean 布尔型原子类</li>
<li>AtomicLong 长整型原子类</li>
</ul>
<p>数组类型原子类：  </p>
<ul>
<li>AtomicIntegerArray 整型数组原子类</li>
<li>AtomicLongrArray 长整型数组原子类</li>
<li>AtomicReferenceArray 引用类型数组原子类</li>
</ul>
<p>引用类型原子类：  </p>
<ul>
<li>AtomicReference 引用类型原子类</li>
<li>AtomicStampedReference 原子更新带有版本号的引用类型，<em>解决修改过几次</em>  </li>
<li>AtomicMarkableReference 原子更新带有标记的引用类型，<em>解决是否修改过</em>，将标记戳简化为true&#x2F;false</li>
</ul>
<p>对象的属性修改原子类：  </p>
<ul>
<li><p>AtomicIntegerFieldUpdater 原子更新对象中int类型字段的值  </p>
</li>
<li><p>AtomicLongFieldUpdater 原子更新对象中Long类型字段的值  </p>
</li>
<li><p>AtomicReferenceFieldUpdater 原子更新对象中引用类型字段的值  </p>
<p>  <strong>使用要求</strong>：更新的对象属性必须使用public volatile修饰符；因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。</p>
</li>
</ul>
<p>原子操作增强类：  </p>
<ul>
<li>DoubleAccumulator 一个或多个变量，它们一起保持运行double使用所提供的功能更新值  </li>
<li>DoubleAdder 一个或多个变量一起保持初始为零double总和  </li>
<li>LongAccumulator 一个或多个变量，一起保持使用提供的功能更新运行的值long ，提供了自定义的函数操作</li>
<li>LongAdder 一个或多个变量一起维持初始为零long总和（重点），只能用来计算加法，且从0开始计算；sum()在并发情况下不保证返回精确值</li>
</ul>
<p><strong>热点商品点赞计算器，点赞数加加统计，不要求实时精确</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClickNumber</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">clickBySynchronized</span><span class="params">()</span> &#123;</span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">AtomicLong</span> <span class="variable">atomicLong</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clickByAtomicLong</span><span class="params">()</span> &#123;</span><br><span class="line">        atomicLong.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">LongAdder</span> <span class="variable">longAdder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAdder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clickByLongAdder</span><span class="params">()</span> &#123;</span><br><span class="line">        longAdder.increment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">LongAccumulator</span> <span class="variable">longAccumulator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAccumulator</span>((x, y) -&gt; x + y, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clickByLongAccumulator</span><span class="params">()</span> &#123;</span><br><span class="line">        longAccumulator.accumulate(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>和AtomicLong比，LongAdder为什么这么快？</strong>  </p>
<ul>
<li>LongAdder是Striped64的子类；Striped64的基本结构里的base变量，类似于AtomicLong中全局的value；collide 扩容意向；cellsBusy 初始化cells或者cells扩容时需要获取锁，0无1有；casCellsBusy() 通过CAS操作修改cellsBusy的值，成功代表获取锁；NCPU 扩容时会用到cpu数量；getProbe() 获取当前线程的hash值；advanceProbe() 重置当前线程的hash值。  </li>
<li>cell是java.util.concurrent.atomic下Striped64的一个内部类，cells数组的长度初始默认值是2，扩容为原来的2倍  </li>
<li>LongAdder的基本思路就是<em>分散热点</em>，将value值分散到一个<em>Cell数组</em>中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作（<em>减少乐观锁的重试次数</em>），这样热点就被分散了，冲突的概率就小很多，如果要获取真正的long值，只要将各个槽中的变量值累加返回</li>
<li>sum()会将所有的Cell数组中的value和base累加作为返回值</li>
<li>化整为零，分散热点，空间换时间</li>
</ul>
<h3 id="20-ThreadLocal"><a href="#20-ThreadLocal" class="headerlink" title="20. ThreadLocal"></a>20. ThreadLocal</h3><p><strong>ThreadLocal是什么？能干吗？</strong><br>ThreadLocal提供线程局部变量，每一个线程在访问ThreadLocal实例的时候（通过其get或set方法）都有自己的、独立初始化的变量副本。不和其他线程共享，从而避免了线程安全问题。withInitial(supplier)静态方法创建线程局部变量。 </p>
<p><strong>ThreadLocal中ThreadLocalMap的数据结构和关系</strong><br>Thread.java ——&gt; ThreadLocal.ThredLocalMap threadLocals &#x3D; null<br>ThreadLocal.java ——&gt; static class ThreadLocalMap<br>                        ——&gt; static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt;  </p>
<p>ThreadLocalMap实际上就是一个以ThreadLocal实例为Key，任意对象为value的Entry对象；当我们为ThreadLocal变量赋值，实际上就是以当前ThreadLocal实例为Key，值为value的Entry往这个ThreadLocalMap中存放。ThreadLocal本身并不存储值。</p>
<p><strong>ThreadLocal的key是弱引用，这是为什么？</strong><br>关于引用：  </p>
<ol>
<li>强引用：对于强引用的对象，就算是出现了OOM也不会对该对象进行回收，死都不收，当一个对象被强引用变量引用时，它处于可达状态，是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到，JVM也不会回收。除非对象引用置为null，或者超过作用域，即变为不可达，此时可以回收。  </li>
<li>软引用：当系统内存充足时，不会被回收，当系统内存不足时，他会被回收。  </li>
<li>弱引用：只要垃圾回收机制一运行，不管JVM的内存空间是否足够，都会回收该对象占用的内存。  </li>
<li>虚引用：虚引用必须和引用队列联合使用，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都有可能被垃圾回收器回收，它不能单独使用也不能通过它访问对象。虚引用的主要作用是跟踪对象被垃圾回收的状态。仅仅是提供了一种确保对象被finalize后，做某些事情的通知机制。虚引用被干掉，将会进入引用队列，在队列中发现有对象，则说明被GC过。</li>
</ol>
<p>关于为什么用弱引用：  </p>
<ul>
<li>当方法执行完毕后，栈帧销毁，强引用tl也就没有了，但此时线程的ThreadLocalMap里某个entry的Key引用还指向这个对象，若这个Key是强引用，就会导致Key指向的ThreadLocal对象即key指向的对象不能被gc回收，造成内存泄露；  </li>
<li>使用弱引用就可以使ThreadLocal对象在方法执行完毕后顺利被回收且entry的key引用指向为null，大概率会减少内存泄漏的问题。（<em>还得考虑value不为null的问题</em>）</li>
</ul>
<p><strong>ThreadLocal内存泄漏问题你知道吗？ThreadLocal中最后为什么要加remove方法？</strong>  </p>
<ul>
<li>不再会被使用的对象或者变量占用的内存不能被回收，就是<em>内存泄漏</em>；  </li>
<li>虽然弱引用，保证了Key指向的ThreadLocal对象能够被及时回收，但是v指向的value对象是需要ThreadLocalMap调用get、set时发现key为null时才会去回收整个entry、value，<em>因此弱引用不能100%保证内存不泄露，我们要在不使用某个ThreadLocal对象后，手动调用remove方法来删除它</em>。  </li>
<li>都会通过expungeStaleEntry，cleanSomeSlots，replaceStaleEntry这三个方法回收键为null的Entry对象的值（即为具体实例）以及entry对象本身从而防止内存泄漏，属于安全加固的方法。</li>
</ul>
<h3 id="21-AbstractQueuedSynchronizer之AQS"><a href="#21-AbstractQueuedSynchronizer之AQS" class="headerlink" title="21. AbstractQueuedSynchronizer之AQS"></a>21. AbstractQueuedSynchronizer之AQS</h3><p><strong>AQS是什么</strong><br>抽象的队列同步器：  </p>
<ul>
<li>是用来实现锁或者其他同步器组件的公共基础部分的抽象实现；  </li>
<li>主要用于解决锁分配给“谁”的问题；  </li>
<li>整体就是一个抽象的FIFO队列来完成资源获取线程的排队工作，并通过一个int类变量表示持有锁的状态。</li>
</ul>
<p><strong>AQS为什么是JUC内容中最重要的基石？</strong>  </p>
<ul>
<li>ReentrantLock、CountDownLatch、ReentrantReadWriteLock、Semaphore等等类的内部都有抽象的静态内部类Sync继承自AQS：abstract static class Sync extends AbstractQueuedSynchronizer{}；  </li>
<li>进一步理解锁和同步器的关系：锁，面向锁的使用者，定义了程序员和锁交互的使用层API，隐藏了实现细节，你调用即可；同步器，面向锁的实现者，Java并发大神DoungLee，提出了统一规范并简化了锁的实现，将其抽象出来，屏蔽了同步状态管理、同步队列的管理和维护、阻塞线程排队和通知、唤醒机制等，是一切锁和同步组件实现的。</li>
</ul>
<p><strong>AQS的排队等候机制</strong><br>如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中，这个队列就是AQS同步队列的抽象表现。它将要请求共享资源的线程及自身的等待状态封装成队列的节点对象（<em>Node</em>），通过CAS、自旋以及LockSupport.park()的方式，维护着state变量的状态，使其达到同步的状态。<br><img src="/../images/JUC/CLH.png">  </p>
<ul>
<li>AQS内部体系架构—-内部类Node：Node的等待状态waitState成员变量；<br><img src="/../images/JUC/Node.png"></li>
</ul>
<p><strong>AQS源码深度分析</strong>  </p>
<ol>
<li>公平锁和非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()—–公平锁加锁时判断等待队列中是否存在有效节点的方法。  </li>
<li>lock() ——&gt; acquire(1) 第二个线程及后续线程抢占  </li>
<li>if(!tryAcquire(arg)&amp;&amp;acquireQueued(addWaiter(Node.EXCLUSIVE),arg))  </li>
<li>addWaiter若链表没初始化就先初始化，否则入队enq(Node)；compareAndSetHead和compareAndSetTail；在双向链表中，第一个节点为虚节点（也叫做哨兵节点），其实不存储任何信息，只是占位。真正的第一个有数据的节点，是从第二个节点开始的。  </li>
<li>acquireQueued中自旋tryAcquire、前置节点状态得为SIGNAL、阻塞当前节点parkAndCheckInterrupt()，里面调用的是LockSupport.park(this)。</li>
<li>unlock() ——&gt; release(1) ——&gt; tryRelease(arg) 释放锁、修改资源的占有状态 ——&gt; unparkSuccessor(h) 唤醒头结点的后置结点，里面调用的是LockSupport.unpark(s.thread)。</li>
</ol>
<h3 id="22-读写锁ReentrantReadWriteLock"><a href="#22-读写锁ReentrantReadWriteLock" class="headerlink" title="22. 读写锁ReentrantReadWriteLock"></a>22. 读写锁ReentrantReadWriteLock</h3><p><strong>是什么？特点有哪些？</strong>  </p>
<ul>
<li>一个资源能够被<em>多个读线程</em>访问，或者被<em>一个写线程</em>访问，<em>但是不能同时存在读写线程</em>；  </li>
<li>读读共存，读写互斥，写写互斥；  </li>
<li>只有在读多写少情景之下，读写锁才具有较高的性能体现。</li>
</ul>
<p><strong>读写锁中的锁降级</strong>  </p>
<ul>
<li>将写锁降级为读锁 —— 遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级为读锁；  </li>
<li>如果一个线程持有了写锁，在没有释放写锁的情况下，它还可以继续获得读锁；</li>
<li>从读锁升级到写锁是不可能的。</li>
</ul>
<p><strong>有没有比读写锁更快的锁？StampedLock邮戳锁</strong><br>是什么：</p>
<ul>
<li>StampedLock是JDK1.8中新增的一个读写锁，也是对JDK1.5中的读写锁ReentrantReadWriteLock的优化；  </li>
<li>stamp 代表了锁的状态。当stamp返回零时，表示线程获取锁失败，并且当释放锁或者转换锁的时候，都要传入最初获取的stamp值；  </li>
<li>ReentrantReadWriteLock实现了读写分离，当前有可能会一直存在读锁，而无法获得写锁，锁饥饿；StampedLock类采取乐观获取锁，其他线程尝试获取写锁时不会被阻塞，在获取乐观读锁后，还需要对结果进行校验。</li>
</ul>
<p>特点：  </p>
<ul>
<li>所有获取锁的方法，都返回一个邮戳，stamp为零表示失败，其余都表示成功；</li>
<li>所有释放锁的方法，都需要一个邮戳，这个stamp必须是和成功获取锁时得到的stamp一致；</li>
<li>StampedLock是不可重入的，危险（如果一个线程已经持有了写锁，在去获取写锁的话会造成死锁）  </li>
<li>三种访问模式：Reading（读模式悲观）、Writing（写模式）、Optimistic reading（乐观读模式）</li>
<li>读的时候也可以写，如果读的时候被写了，那就重新读一次。对短的只读代码段，使用乐观模式通常可以减少争用并提高吞吐量</li>
<li>StampedLock 的悲观读锁和写锁都不支持条件变量(Condition),这个也需要注意；</li>
<li>使用 StampedLock一定不要调用中断操作,即不要调用interrupt()方法。</li>
</ul>
<h3 id="23-Java对象内存布局和对象头"><a href="#23-Java对象内存布局和对象头" class="headerlink" title="23. Java对象内存布局和对象头"></a>23. Java对象内存布局和对象头</h3><h3 id="24-Synchronized与锁升级"><a href="#24-Synchronized与锁升级" class="headerlink" title="24. Synchronized与锁升级"></a>24. Synchronized与锁升级</h3>
        
            <div id="toc-article">
                
  <div class="widget-wrap" id="toc-wrap">
    <h3 class="widget-title"><i class="fa fa-toc"></i> Contents</h3>
    <div class="widget">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94JUC-%E5%9F%BA%E7%A1%80%E7%AF%87-java-util-concurrent"><span class="toc-text">JAVA并发编程—JUC-基础篇  (java.util.concurrent)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JUC%E6%A6%82%E8%BF%B0"><span class="toc-text">JUC概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B"><span class="toc-text">管程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-text">用户线程和守护线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lock%E6%8E%A5%E5%8F%A3"><span class="toc-text">Lock接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronized%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">Synchronized关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFLock%E6%8E%A5%E5%8F%A3"><span class="toc-text">什么是Lock接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-text">进程间通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-text">集合线程安全</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%94%81"><span class="toc-text">多线程锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="toc-text">锁的范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-text">公平锁和非公平锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-text">可重入锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-text">死锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Callable%E6%8E%A5%E5%8F%A3"><span class="toc-text">Callable接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">创建线程的多种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Runnable%E5%92%8CCallable%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">Runnable和Callable接口的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E7%B1%BB"><span class="toc-text">辅助类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CountDownLatch"><span class="toc-text">CountDownLatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CyclicBarrier"><span class="toc-text">CyclicBarrier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Semaphore"><span class="toc-text">Semaphore</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-text">读写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-text">悲观锁和乐观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E9%94%81%E5%92%8C%E8%A1%8C%E9%94%81"><span class="toc-text">表锁和行锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E9%94%81%E5%92%8C%E5%86%99%E9%94%81"><span class="toc-text">读锁和写锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E6%A1%88%E4%BE%8B"><span class="toc-text">读写锁案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-text">阻塞队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">线程池的使用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadPoolExecutor%E7%9A%84%E4%B8%83%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="toc-text">ThreadPoolExecutor的七个参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">自定义线程池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fork-x2F-Join"><span class="toc-text">Fork&#x2F;Join</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83"><span class="toc-text">异步回调</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="toc-text">1. 并发和并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E7%AE%A1%E7%A8%8B"><span class="toc-text">2. 进程、线程、管程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">3. 线程的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Future%E6%8E%A5%E5%8F%A3%EF%BC%88FutureTask%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%89-%E2%80%94JDK5"><span class="toc-text">4. Future接口（FutureTask实现类） —JDK5</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-CompletableFuture-%E2%80%94JDK8"><span class="toc-text">5. CompletableFuture  —JDK8</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">6. 函数式接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-CompletableFuture%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">7. CompletableFuture常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-text">8. 悲观锁和乐观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-synchronized%E7%BA%BF%E7%A8%8B8%E9%94%81%E9%97%AE%E9%A2%98"><span class="toc-text">9. synchronized线程8锁问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90synchronized%E5%AE%9E%E7%8E%B0"><span class="toc-text">10. 从字节码角度分析synchronized实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-text">11. 公平锁与非公平锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-text">12. 可重入锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E6%AD%BB%E9%94%81%E5%8F%8A%E6%8E%92%E6%9F%A5"><span class="toc-text">13. 死锁及排查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD"><span class="toc-text">14. 线程中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-LockSupport"><span class="toc-text">15. LockSupport</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B9%8BJMM"><span class="toc-text">16. Java内存模型之JMM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-volatile%E4%B8%8EJMM"><span class="toc-text">17. volatile与JMM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-CAS"><span class="toc-text">18. CAS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB"><span class="toc-text">19. 原子操作类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-ThreadLocal"><span class="toc-text">20. ThreadLocal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-AbstractQueuedSynchronizer%E4%B9%8BAQS"><span class="toc-text">21. AbstractQueuedSynchronizer之AQS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock"><span class="toc-text">22. 读写锁ReentrantReadWriteLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="toc-text">23. Java对象内存布局和对象头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-Synchronized%E4%B8%8E%E9%94%81%E5%8D%87%E7%BA%A7"><span class="toc-text">24. Synchronized与锁升级</span></a></li></ol></li></ol></li></ol>
    </div>
  </div>


            </div>
        
        
          <blockquote id="copyright">
              <p>Original link: <a href="http://example.com/2023/04/10/offer-JUC/">http://example.com/2023/04/10/offer-JUC/</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li></ul>

          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
        
<nav id="article-nav">
  
    <a href="/2023/03/20/CRS-Adversarial-Examples/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">older</strong>
      <div class="article-nav-title">
        
          CRS-Adversarial Examples
        
      </div>
    </a>
  
  
    <a href="/2023/04/10/offer-Java/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">newer</strong>
      <div class="article-nav-title">
        
          offer---Java
        
      </div>
    </a>
  
</nav>

      
      
        








      
    </footer>
  </div>
</article>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-posts"></i> Recent</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/07/04/redis7/">redis7</a>
          </li>
        
          <li>
            <a href="/2024/06/17/offer-ES/">offer-ES</a>
          </li>
        
          <li>
            <a href="/2024/04/18/Java-gulimall/">Java-gulimall</a>
          </li>
        
          <li>
            <a href="/2024/03/11/offer-JVM/">offer-JVM</a>
          </li>
        
          <li>
            <a href="/2023/08/29/offer-SSM/">offer-SSM</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-tag"></i> Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CRS/" style="font-size: 20px;">CRS</a> <a href="/tags/ChatGPT/" style="font-size: 20px;">ChatGPT</a> <a href="/tags/Dialog/" style="font-size: 10px;">Dialog</a> <a href="/tags/JAVA/" style="font-size: 15px;">JAVA</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/LLM/" style="font-size: 10px;">LLM</a> <a href="/tags/PyTorch/" style="font-size: 10px;">PyTorch</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/SSM/" style="font-size: 10px;">SSM</a> <a href="/tags/Web/" style="font-size: 10px;">Web</a> <a href="/tags/flask-vue-mysql/" style="font-size: 10px;">flask,vue,mysql</a>
    </div>
  </div>

  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-archive"></i> Archive</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/">2024年</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/">2023年</a><span class="archive-list-count">17</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-tag"></i> Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CRS/" rel="tag">CRS</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ChatGPT/" rel="tag">ChatGPT</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dialog/" rel="tag">Dialog</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LLM/" rel="tag">LLM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PyTorch/" rel="tag">PyTorch</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSM/" rel="tag">SSM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flask-vue-mysql/" rel="tag">flask,vue,mysql</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-link"></i> Blogroll</h3>
    <div class="widget">
      <ul>
      
        <li>
          <a target="_blank" rel="noopener" href="http://www.example1.com/">site-name1</a>
        </li>
      
        <li>
          <a target="_blank" rel="noopener" href="http://www.example2.com/">site-name2</a>
        </li>
      
        <li>
          <a target="_blank" rel="noopener" href="http://www.example3.com/">site-name3</a>
        </li>
      
      </ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <a id="totop" href="#top"></a>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <p>
        <a href="/sitemap.xml">Site Map</a>
        <span> | </span><a href="/atom.xml">Subscribe to this site</a>
        <span> | </span><a href="/about/">Contact the blogger</a>
      </p>
      
        <p>
          <i class="fa fa-visitors"></i>
          <i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>
          ，
          <i class="fa fa-views"></i>
          <i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>
        </p>
      
      <p>
        <span>Copyright &copy; 2024 JupiterTop.</span>
        <span>Theme by <a href="https://github.com/chaooo/hexo-theme-BlueLake/" target="_blank">BlueLake.</a></span>
        <span>Powered by <a href="https://hexo.io/" target="_blank">Hexo.</a></span>
      </p>
    </div>
  </div>
</footer>


    </div>
  </div>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/search.json.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>






  
<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  
    
<script src="/localshare/js/social-share.js"></script>

    
<script src="/localshare/js/qrcode.js"></script>

  
  



  

  

  

  

  

  

  

  
  





</body>
</html>