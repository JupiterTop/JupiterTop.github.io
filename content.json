[{"title":"redis7","date":"2024-07-04T05:12:08.000Z","path":"2024/07/04/redis7/","text":"Redis 7入门概述是什么？ Redis: Remote Dictionary Server(远程字典服务) C语言编写的，key-value键值对的in-momery database 作者安特雷兹github和个人博客包含redis的更新和新特性 能做啥 before（MySQL）： 硬件：disk磁盘 查询：全表扫描 关系的处理：关系型数据库 after（Redis）： 硬件：memory内存 查询：kv键值对查询 关系的处理：NoSQL非关系型数据库 分布式缓存，挡在mysql数据库之前的带刀护卫 两者并不是相互竞争的关系，而是相互配合。 支持内存存储和持久化（RDB+AOF），支持异步将内存中的数据持久化到disk硬盘上，同时不影响继续使用服务 高可用架构搭配，单机、主从、哨兵、集群 缓存穿透、击穿、雪崩、分布式锁、队列 排行榜、点赞应用场景 优势： 性能极高，读的速度是110000次&#x2F;秒，写的速度是81000次&#x2F;秒，所以适用于秒杀任务； Redis数据类型丰富，除了kv类型的数据，还提供了list，set，zset，hash等数据结构的存储 支持数据的持久化 支持数据的备份，即master-slave模式的数据备份 版本演变和redis7新特性 Redis Functions 针对Lua Client-eviction 针对性能提升 Multi-part AOF 支持多个AOP文件，性能提升 ACL v2 精细化权限管理 新增命令 listpack替代ziplist 底层性能优化 安装配置虚拟机：CentOS9检查操作系统位数和gcc编译环境。redis版本：7.2.4redis.conf配置文件，改完后确保生效，记得重启 1 默认daemonize no 改为 daemonize yes 2 默认protected-mode yes 改为 protected-mode no 3 默认bind 127.0.0.1 改为 直接注释掉(默认bind 127.0.0.1只能本机访问)或改成本机IP地址，否则影响远程IP连接 4 添加redis密码 改为 requirepass 你自己设置的密码 redis 10 大数据类型注意：key一般都是字符串，value是十大类型；命令不区分大小写，而key是区分大小写的。help@类型 提供对应类型的帮助命令 1 字符串（String）单值单value。 12345set key value [NX|XX] [GET] [EX seconds|PX milliseconds|EXAT unix-time-seconds|PXAT unix-time-milliseconds|KEEPTTL]get key NX: 键不存在时设置键值；XX：键存在的时侯设置键值；EX|PX: 以秒|毫秒为单位设置过期时间；EXAT|PXAT: 设置以秒|毫秒为单位的UNIX时间戳所对应的时间为过期时间，可通过“System.out.println(Long.toString(System.currentTimeMillis()&#x2F;1000L));”获得UNIX时间戳；GET: 返回指定键值原来的值，若键不存在时返回nil；KEEPTTL: 保留设置前指定键的生存时间。 其他命令： mset:同时设置一个或多个 key-value 对。 mget:获取所有(一个或多个)给定 key 的值。 msetnx:同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。 getrange:获取指定区间范围内的值，类似between……and的关系，substring 从零到负一表示全部。 setrange设置指定区间范围内的值，格式是setrange key值 具体值。 数值增减：一定是数字才能进行增减；INCR|DECR key；INCRBY|DECRBY key increment|decrement。 获取字符串长度和内容追加，STRLEN key；APPEND key value。 分布式锁有关：setnx key value；setex(set with expire)；setnx(set if not exist)。 getset:将给定 key 的值设为 value ，并返回 key 的旧值(old value)。 应用场景： 短视频点赞，点一下加一次； 是否喜欢文章。 2 列表（List）单key多value；底层是双端链表；常用命令: lpush&#x2F;rpush&#x2F;lrange lpop&#x2F;rpop lindex 按照索引下标获取元素 llen 获取列表中的元素个数 lrem key N value 删除N个值等于value的元素 ltrim key start stop 截取指定范围的值后再赋值给key rpoplpush 源列表 目的列表 移除列表的最后一个元素，并将该元素添加到另一个列表并返回 lset key index value linsert key before&#x2F;after 已有值 插入的值 应用场景：微信公众号订阅消息 3 哈希表（Hash）KV模式不变，但V是一个键值对 &lt;&#x3D;&gt; Map&lt;String,Map&lt;Object,Object&gt;&gt; 常用命令： hset&#x2F;hget&#x2F;hmset&#x2F;hmget&#x2F;hgetall&#x2F;hel hlen 获取某个key内的全部数量 hexists key field 判断key里面的某个field是否存在 hkeys&#x2F;hvals hincrby&#x2F;hincrbyfloat hsetnx 不存在赋值，存在了无效 应用场景： JD购物车早期，目前不再采用，当前中小厂可用如 12345678910新增商品 → hset shopcar:uid1024 334488 1新增商品 → hset shopcar:uid1024 334477 1增加商品数量 → hincrby shopcar:uid1024 334477 1商品总数 → hlen shopcar:uid1024全部选择 → hgetall shopcar:uid1024 4 集合（Set）底层可以是intset或hashtable，String的无序集合，不允许重复。单值多value，无重复。 常用命令： SADD key values 添加元素 SMEMBERS key 遍历集合中的所有元素 SISMEMBER key member 判断元素是否在集合中 SREM key member 删除元素 scard key 获取集合里面的元素个数 SRANDMEMBER key [数字] 从集合中随机展现设置的数字个数元素，元素不删除 SPOP key [数字] 从集合中随机弹出元素，元素删除 smove key1 key2 value1 将key1中存在的value1赋给key2 集合的差集运算A-B ：属于A但不属于B的元素构成的集合，SDIFF A B 并集运算A∪B：SUNION A B 交集运算A∩B：SINTER A B（返回集合）；SINTERCARD numkeys A B [LIMIT limit] （返回基数） 应用场景： 微信小程序抽奖： 12345678用户ID，立即参与按钮 → sadd key 用户ID 显示已经有多少人参与了 → SCARD key抽奖(从set中任意选取N个中奖人): SRANDMEMBER key 2 → 随机抽奖2个人，元素不删除 SPOP key 3 → 随机抽奖3个人，元素会删除 微信朋友圈点赞，查看同赞好友： 1234567新增点赞 → sadd pub:msgID 点赞用户ID1 点赞用户ID2取消点赞 → srem pub:msgID 点赞用户ID展现所有点赞过的用户 → SMEMBERS pub:msgID点赞用户数统计，就是常见的点赞红色数字 → scard pub:msgID判断某个朋友是否对楼主点赞过 → SISMEMBER pub:msgID 用户ID QQ内推可能认识的人：集合运算 5 有序集合（sorted set）每个元素都会关联一个double类型的分数，通过该分数来进行排序，成员唯一，但分数可以重复。通过哈希表实现。 常用命令： ZADD key score member […] 添加元素 ZRANGE key start stop [WITHSCORES] 按照元素分数从大到小的顺序，返回索引从start到stop之间的所有元素 ZREVARANGE 反转排序 ZRANGEBYSCORE key min max [WITHSCORES][LIMIT offset count] 获取指定分数范围的元素，（代表不包含 ZSCORE key member 获取元素的分数 ZCARD key 获取集合中元素的数量 zrem key member 删除元素 ZINCRBY key increment member 增加某个元素的分数 ZCOUNT key min max 获得指定分数范围内的元素个数 ZMPOP 弹出元素 zrank key value 获得下标值 zrevrank key value 逆序获得下标值 应用场景：根据商品销售对商品进行排序显示如 12345678910思路：定义商品销售排行榜(sorted set集合)，key为goods:sellsort，分数为商品销售数量。商品编号1001的销量是9，商品编号1002的销量是15→ zadd goods:sellsort 9 1001 15 1002有一个客户又买了2件商品1001，商品编号1001销量加2→ zincrby goods:sellsort 2 1001求商品销量前10名→ ZRANGE goods:sellsort 0 9 withscores 6 地理空间（GEO）存储地理位置。 type geo → zset 常用命令： GEOADD 多个经度（longitude）、纬度（latitude）、位置名称（member）添加到指定的key中。处理中文乱码：redis-cli –raw GEOPOS 从键里返回所有给定位置元素的经纬度 GEORADIUS 以给定的经纬度为中心，返回与中心的距离不超过给定最大距离的所有位置元素 GEODIST 返回两个给定位置之间的距离 GEORADIUSBYMEMBER 跟GEORADIUS类似，不过是以member为中心 GEOHASH 返回一个或多个位置元素的hash表示 应用场景： 美团地图位置附近的酒店推送 高德地图附近的核酸检查点 7 基数统计（HyperLogLog）基数统计 ，如访问量、点击率等庞大数据。 需求：统计某个网站的UV、统计某个文章的UV（Unique Visitor 独立访客，一般理解为客户端IP），需要去重考虑 基数：是一种数据集，去重复后的真实个数。 常用命令： PFADD key element 添加指定元素 PFCOUNT key 返回给定key的基数估算值（因为会有误差） PFMERGE destkey sourcekey1 sourcekey2 将多个HyperLogLog合并成一个 应用场景：天猫网站首页亿级UV的Redis统计方案 8 位图（bitmap）由0和1状态表现的二进制位的bit数组。用String类型作为底层数据结构实现的一种统计二值状态的数据类型。需求：用户是否登录过Y，N；钉钉打卡，上班统计…… 常用命令： setbit key offset value 偏移量从零开始 getbit key offset strlen 不是字符串长度而是占据几个字节，超过8位后自己按照8位一组一byte再扩容 bitcount 全部键里含有1的个数 bitop 可以用于统计两个键之间的关系，支持与或非操作，如统计连续两天都签到的用户 应用场景： 123按年去存储一个用户的签到情况，365 天只需要 365 / 8 ≈ 46 Byte，1000W 用户量一年也只需要 44 MB 就足够了。此外，在实际使用时，最好对Bitmap设置过期时间，让Redis自动删除不再需要的签到记录以节省内存开销。 9 位域（bitfield）可以一次性操作多个比特位域（指的是连续的多个比特位）。将一个 Redis 字符串看作是一个由二进制位组成的数组，并对这个数组中任意偏移进行访问。作用：1. 位域修改 2. 溢出控制 123BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL] 常用命令： BITFIELD key GET type offset 返回指定的位域 BITFIELD key SET type offset value 设置指定位域的值并返回它的原值 BITFIELD key INCRBY type offset increment 默认overflow为wrap，即循环溢出 BITFIELD key OVERFLOW WRAP|SAT|FAIL 溢出控制 1）WRAP: 使用回绕(wrap around)方法处理有符号整数和无符号整数的溢出情况；2）SAT:使用饱和计算(saturation arithmetic)方法处理溢出下溢计算的结果为最小的整数值，而上溢计算的结果为最大的整数值；3）FAIL: 命令将拒绝执行那些会导致上溢或者下溢情况出现的计算并向用户返回空值表示计算未被执行 10 流（Stream）redis5.0版本新增的数据结构，主要用于消息队列。 redis5.0之前痛点：redis消息队列的两种方案 1）List实现： 缺点：点对点的模式。 2）Pub&#x2F;Sub： 缺点：消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃。而且也没有 Ack 机制来保证数据的可靠性，假设一个消费者都没有，那消息就直接被丢弃了。 redis5.0版本新增Stream数据结构：实现消息队列，它支持消息的持久化、支持自动生成全局唯-ID、支持ack确认消息的模式、支持消费组模式等，让消息队列更加的稳定和可靠。 特殊符号： “- +” —— 最小和最大可能出现的id “$” —— 只消费新的消息，当前流中最大的id，可用于将要到来的信息 “&gt;” —— 用于XREADGROUP命令，表示迄今还没有发送给组中使用者的信息，会更新消费者组的最后ID “*” —— 用于XADD命令中，让系统自动生成id 队列相关常用命令： XADD mystream * id 11 name z3 默认用星号表示自动生成id，Redis对于ID有强制要求，格式必须是时间戳-自增Id这样的方式，且后续ID不能小于前一个ID XRANGE mystream - + [count x] 获取消息列表，可以指定范围 XREVRANGE mystream + - 反向获取，end在前，start在后 XDEL id XLEN 获取Stream队列的消息的长度 XTRIM 对Stream的长度进行截取，如超长会进行截取，MAXLEN允许的最大长度，对流进行修剪限制长度；MINID允许的最小id，从某个id值开始比该id值小的将会被抛弃 XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key …] ID [ID …] block表示是否以阻塞的方式读取消息，默认不阻塞。$代表特殊ID，表示以当前Stream已经存储的最大的ID作为最后一个ID，当前Stream中不存在大于当前最大ID的消息，因此此时返回nil；0-0代表从最小的ID开始获取Stream中的消息，当不指定count，将会返回Stream中的所有消息，注意也可以使用0（00&#x2F;000也都是可以的……）。阻塞情况： 消费组常用命令： XGROUP CREATE 创建消费者组，创建消费者组的时候必须指定 ID, ID 为 0 表示从头开始消费，为 $ 表示只消费新的消息，队尾新来 XREADGROUP GROUP groupA consumer1 STREAMS mystream &gt; 读完未被消费的消息。不同消费组的消费者可以消费同一条消息。消费组的目的：让组内的多个消费者共同分担读取消息，所以，我们通常会让每个消费者读取部分消息，从而实现消息读取负载在多个消费者间是均衡分布的 XPENDING 查询每个消费组内所有消费者[已读取、但尚未确认]的消息；或查看某个消费者具体读取了哪些数据 XACK mystream groupA id 向消息队列确认消息处理已完成 XINFO 打印Stream\\Consumer\\Group的详细信息 键（key操作） Redis持久化 RDB (Redis DataBase)概述：在指定的时间间隔，执行数据库的时间点快照，全量快照，以dump.rdb文件的形式保存；恢复时再将硬盘中的快照文件读回内存里。 自动触发bgsave配置： Redis6.0.16以下 In the example below the behavior will be to save: after 900 sec(15 min)if at least 1 key changed after 300 sec(5 min)if at least 10 keys changed after 60 sec if at least 10000 keys changed save 900 1 save 300 10 save 60 10000 Redis6.2以及Redis7 Unless specified otherwise, by default Redis will save the DB: After 3600 seconds(an hour) if at least 1 change was performed After 300 seconds (5 minutes) if at least 100 changes were performed After 60 seconds if at least 10000 changes were performed save 3600 1 300 100 60 10000 自定义修改的路径且可以进入redis里用CONFIG GET dir获取目录（line 505）；修改dump文件名称 dbfilename xxxx.rdb（line 482） 触发RDB快照的情况： 满足配置文件中的自动触发条件 手动save&#x2F;bgsave命令 执行flushall&#x2F;flushdb命令也会产生dump.rdb文件，但内容为空，无意义 主从复制时，主节点自动触发 恢复：重启服务即可自动恢复；物理恢复，一定要服务和备份分机隔离，分开各自存储，以防生产机物理损坏后备份文件也挂了。 手动触发RDB快照 Save：在主程序中执行会阻塞当前redis服务器，直到持久化工作完成；执行save命令期间，Redis不能处理其他命令，线上禁止使用。 BGSAVE（默认）：Redis会在后台异步进行快照操作，不阻塞快照同时还可以响应客户端请求,该触发方式会fork一个子进程由子进程复制持久化过程，允许主进程同时可以修改数据。 LASTSAVE：获取最后一次成功执行快照的时间戳。 其他： 检查修复dump.rdb文件，使用redis-check-rdb xxxx.rdb 禁用快照：1）动态所有停止RDB保存规则的方法redis-cli config set save “”；2）配置文件里改 配置文件SNAPSHOTTING模块 save dbfilename dir stop-writes-on-bgsave-error保证数据一致性 rdbcompression压缩存储 rdbchecksum数据校验 rdb-del-sync-files在没有持久性的情况下删除复制中使用的RDB文件启用 优势：适合大规模的数据恢复；按照业务定时备份；对数据完整性和一致性要求不高；RDB文件在内存中的加载速度比AOF快得多。 劣势：在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失从当前至最近一次快照期间的数据，快照之间的数据会丢失；内存数据的全量同步，如果数据量太大会导致I&#x2F;0严重影响服务器性能；RDB依赖于主进程的fork，在更大的数据集中，这可能会导致服务请求的瞬间延迟；fork的时候内存中的数据被克隆了一份，大致2倍的膨胀性，需要考虑。 AOF (Append Only File)以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。默认情况下，redis是没有开启AOF(append only file)的。开启AOF功能需要设置配置:appendonly yes。保存的文件是appendonly.aof。 AOF持久化工作流程： 三种写回策略： Always 同步写回，每个写命令执行完立刻同步地将日志写回磁盘 everysec 每秒写回，每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔1秒把缓冲区中的内容写入磁盘 no 每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘默认写回策略，每秒钟 appendsync everysec AOF文件-保存路径：redis6的AOF文件位置和RDB保存文件的位置是一样的，都是通过dir配置（line 506）；redis7之后通过appenddirname “xxxx”配置（line 1414）。 AOF文件-保存名称：redis6有且只有一个，通过appendfilename “appendonly.aof”配置；redis7之后，新特性采取Multi Part AOF的设计，拆分为三个文件。base基本文件（最多只有一个），incr增量文件（可能存在多个），manifest清单文件（跟踪、管理这些AOF）。 异常修复命令:redis-check-aof –fix 修复AOF文件 优势：更好的保护数据不丢失、性能高、可做紧急恢复劣势：相同数据集的数据而言AOF文件要远大于RDB文件，恢复速度慢于RDB；AOF运行效率要慢于RDB，每秒同步策略效率较好，不同步效率和RDB相同。 AOF重写机制：启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。自动触发默认配置： auto-aof-rewrite-percentage 100 根据上次重写后的aof大小，判断当前aof大小是不是增长了1倍 auto-aof-rewrite-min-size 64mb 重写时满足的文件大小注意，同时满足，且的关系才会触发。 手动触发：客户端向服务器发送bgrewriteaof命令。 重写原理： 在重写开始前，redis会创建一个“重写子进程”，这个子进程会读取现有的AOF文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。 与此同时，主进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的AOF文件中，这样做是保证原有的AOF文件的可用性，避免在重写过程中出现意外。 当“重写子进程”完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新AOF文件中。 当追加结束后，redis就会用新AOF文件来代替旧AOF文件，之后再有新的写指令，就都会追加到新的AOF文件中。 重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似。 RDB-AOF混合持久化同时开启两种持久化方式，在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢?乍者建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)，留着RDB作为一个万一的手段。结论：RDB镜像做全量持久化，AOF做增量持久化。 纯缓存模式同时关闭RDB和AOF： save “” 禁用RDB配置；在禁用RDB持久化模式下，仍然可以使用save、bgsave生成RDB文件 appendonly no 禁用AOF配置；禁用AOF持久化模式下，仍然可以使用命令bgrewriteaof生成AOF文件 Redis事务事务：可以一次执行多个命令，本质是一组命令的集合。一个事务中的所有命令都会序列化，按顺序地串行化执行而不会被其它命令插入，不许加塞。 Redis事务 VS 数据库事务 单独的隔离操作。Redis的事务仅仅是保证事务里的操作会被连续独占的执行，redis命令执行是单线程架构，在执行完事务内所有指令前是不可能再去同时执行其他客户端的请求的； 没有隔离级别的概念。因为事务提交前任何指令都不会被实际执行，也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这种问题了； 不保证原子性。Redis的事务不保证原子性，也就是不保证所有指令同时成功或同时失败，只有决定是否开始执行全部指令的能力，没有执行到一半进行回滚的能力； 排它性.Redis会保证一个事务内的命令依次执行，而不会被其它命令插入。 case1：正常执行先MULTI命令，然后写若干命令，加入到队列中，最后EXEC命令提交； case2：放弃事务先MULTI命令，然后写若干命令，加入到队列中，最后DISCARD放弃事务提交； case3：全体连坐先MULTI命令，然后写若干命令，其中出现某一条语法编译不通过，然后EXEC，事务中的所有命令执行失败； case4：冤头债主前期语法都没错，编译通过，但执行EXEC后报错，这种情况下对的执行，错的不执行。Redis不提供事务回滚的功能，开发者必须在事务执行出错后，自行恢复数据库状态。而传统数据库事务，要么一起成功要么一起失败。 case5：watch监控Redis使用Watch来提供乐观锁定，类似于CAS（Check-and-Set）；unwatch解除锁定。一旦执行了exec，之前的监控锁都会被取消掉了。 Redis管道Redis是一种基于客户端-服务端模型以及请求&#x2F;响应协议的TCP服务。一个请求会遵循以下步骤：1 客户端向服务端发送命令分四步(发送命令→命令排队→命令执行→返回结果)，并监听Socket返回，通常以阻塞模式等待服务端响应。2 服务端处理命令，并将结果返回给客户端。上述两步称为：Round Trip Time(简称RTT,数据包往返于两端的时间)。如果同时需要执行大量的命令，那么就要等待上一条命令应答后再执行，这中间不仅仅多了RTT（Round Time Trip），而且还频繁调用系统IO，发送网络请求，同时需要redis调用多次read()和write()系统方法，系统方法会将数据从用户态转移到内核态，这样就会对进程上下文有比较大的影响了，性能不太好。 如何优化频繁命令往返造成的性能瓶颈？ —— 管道。管道(pipeline)可以一次性发送多条命令给服务端，服务端依次处理完完毕后，通过一条响应一次性将结果返回，通过减少客户端与redis的通信次数来实现降低往返延时时间。pipeline实现的原理是队列，先进先出特性就保证数据的顺序性。 cat cmd.txt | redis-cli -a 111111 –pipe pipeline VS 原生批量命令： 原生批量命令是原子性(例如:mset,mget)，pipeline是非原子性； 原生批量命令一次只能执行一种命令，pipeline支持批量执行不同数据类型的命令； 原生批命令是服务端实现，而pipeline需要服务端与客户端共同完成。 pipeline VS 事务： 事务具有原子性，管道不具有原子性； 管道一次性将多条命令发送到服务器，事务是一条一条的发，事务只有在接收到exec命令后才会执行，管道不会； 执行事务时会阻塞其他命令的执行，而执行管道中的命令时不会。 注意：pipeline缓冲的指令只是会依次执行，不保证原子性，如果执行中指令发生异常，将会继续执行后续的指令；使用pipeline组装的命令个数不能太多，不然数据量过大客户端阻塞的时间可能过久，同时服务端此时也被迫回复一个队列答复，占用很多内存。 Redis发布订阅是一种消息通信模式:发送者(PUBLISH)发送消息，订阅者(SUBSCRIBE)接收消息，可以实现进程间的消息传递。发布&#x2F;订阅其实是一个轻量的队列，只不过数据不会被持久化，一般用来处理实时性较高的异步消息。 常用命令： SUBSCRIBE channel 订阅给定的一个或多个频道的消息，每次可以收到一个包含3个参数的消息（消息种类，始发频道的名称，实际的消息内容） PUBLISH channel message 发布消息到指定的频道 PSUBSCRIBE pattern 按照模式批量订阅，订阅一个或多个符合给定模式（*，?）的频道 PUBSUB CHANNELS 返回由活跃频道组成的列表 PUBSUB NUMSUB channel 某个频道有几个订阅者 PUBSUB NUMPAT 只统计使用PSUBSCRIBE命令执行的，返回客户端订阅的唯一模式的数量 UNSUBSCRIBE channel 取消订阅 PUNSUBSCRIBE 退订所有给定模式的频道 缺点： 发布的消息在Redis系统中不能持久化，因此，必须先执行订阅，再等待消息发布。如果先发布了消息，那么该消息由于没有订阅者，消息将被直接丢弃； 消息只管发送对于发布者而言消息是即发即失的，不管接收，也没有ACK机制，无法保证消息的消费成功。 以上的缺点导致Redis的Pub&#x2F;sub模式就像个小玩具，在生产环境中几乎无用武之地，为此Redis5.0版本新增了Stream数据结构，不但支持多播，还支持数据持久化，相比Pub&#x2F;Sub更加的强大。 Redis复制主从复制，master以写为主，slave以读为主；当master数据变化的时候，自动将新的数据异步同步到其他slave数据库。作用：读写分离；容灾恢复；数据备份；水平扩容支撑高并发 配置细节： 配从（库）不配主（库）； master如果配置了requirepass参数，需要密码登录，那么slave就要配置masterauth来设置校验密码，否则的话master会拒绝slave的访问请求； 常用命令： info replication 可以查看复制节点的主从关系和配置信息 replicaof 主库IP 主库端口 （在redis.conf配置文件内配置） slaveof 主库IP 主库端口 每次与master断开之后，都需要重新连接，除非配置进redis.conf文件；在运行期间修改slave节点的信息，如果该数据库已经是某个主数据库的从数据库，那么会停止和原主数据库的同步关系，转而和新的主数据库同步 salveof no one 使当前数据库停止与其他数据库的同步，转为主数据库，自立为master，原来数据不丢失，除非清空数据库 常用案例： 一主二仆 从机不可以执行写的命令； 从机切入点问题：首次一锅端，后续跟随，master写，slave跟； 主机shutdown后，从机会上位吗？重启后主从关系还在吗？从机还能否顺利复制？答：从机不动，原地待命，从机数据可以正常使用，等待主机重启动归来；重启后主从关系依旧，复制依旧； 某台从机down后，master继续，从机重启后它能跟上大部队吗？答：不一定。看是配置还是命令，配置持久稳定，命令当次生效。 薪火相传 上一个slave可以是下一个slave的master，slave同样可以接收其他slaves的连接和同步请求，那么该slave作为了链条中下一个master，可以有效减轻主master的写压力； 中途变更转向：会清除之前的数据，重新建立拷贝最新的； slaveof 主库IP 新主库端口。 反客为主：slaveof no one 复制原理和工作流程： slave启动，同步初请： slave启动成功连接到master后会发送一个sync命令；slave首次全新连接master，一次完全同步(全量复制)将被自动执行，slave自身原有数据会被master数据覆盖清除； 首次连接，全量复制：master节点收到sync命令后会开始在后台保存快照(即RDB持久化，主从复制时会触发RDB)同时收集所有接收到的用于修改数据集命令缓存起来，master节点执行RDB持久化完后，master将rdb快照文件和所有缓存的命令发送到所有slave，以完成一次完全同步；而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中，从而完成复制初始化； 心跳持续，保持通信：master发出PING包的周期，默认是10秒；repl-ping-replica-period 10； 进入平稳，增量复制：Master继续将新的所有收集到的修改命令自动依次传给slave，完成同步； 从机下线，重连续传：master会检查backlog里面的offset，master和slave都会保存一个复制的offset还有一个masterId，Master只会把以及复制的offset后面的数据复制给Slave，类似断点续传。 复制的缺点： 复制延时，信号衰减：由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。 master挂了怎么办，默认情况下，不会在slave节点中自动重选一个master。无人值守安装变成刚需。 Redis哨兵（sentinel）无人值守运维，主要作用： 主从监控，监控主从redis库运行是否正常； 消息通知，哨兵可以将故障转移的结果发送给客户端； 故障转移，如Master异常，则会进行主从切换，将其中一个Slave作为新Master； 配置中心，客户端通过连接哨兵来获得当前Redis服务的主节点地址。 生产都是不同机房不同服务器，很少出现3个哨兵全挂掉的情况，可以同时监控多个master，一行一个。 sentinel.conf文件通用配置： 1234567891011bind 0.0.0.0daemonize yesprotected-mode noport 26379logfile &quot;/myredis/sentinel26379.log&quot;pidfile /var/run/redis-sentinel26379.piddir /myredissentinel monitor mymaster 192.168.111.169 6379 2 # 设置要监控的master服务器，quorum表示最少有几个哨兵认可客观下线，同意故障迁移的法定票数sentinel auth-pass mymaster 111111 # 连接master服务的密码 注意：6379后续可能会变成从机，需要设置访问新主机的密码， 请设置masterauth项访问密码为统一密码，不然后续可能报错master_link_status:down启动哨兵，完成监控：redis-sentinel sentinel26379.conf –sentinel 模拟原有的master挂了： 两台从机数据是否OK？ ok，可能会出现broken pipe（对端管道断开）或server closed the connection的错误，耐心等待一会即可。 是否会从剩下的2台机器上选出新的master？ 投票新选。 之前down机的master机器重启回来，谁会是新master，会不会双master冲突？ 原master重启后降级为slave。 对比配置文件。文件的内容，在运行期间会被sentinel动态进行更改；master-slave切换后，master_redis.conf、slave_redis.conf和sentinel.conf的内容都会发生改变，即master_redis.conf中会多一行slaveof的配置，sentinel.conf的监控目标会随之调换。 （重点）哨兵运行流程和选举原理：当一个主从配置中的master失效之后，sentinel可以选举出一个新的master用于自动接替原master的工作，主从配置中的其他redis服务器自动指向新的master同步数据般建议sentinel采取奇数台，防止某一台sentinel无法连接到master导致误切换。 SDown主观下线（Subjectively Down）：SDOWN（主观不可用）是单个sentinel自己主观上检测到的关于master的状态，从sentinel的角度来看，如果发送了PING心跳后，在一定时间内没有收到合法的回复，就达到了SDOWN的条件。sentinel配置文件中的down-after-milliseconds设置了判断主观下线的时间长度。 ODown客观下线（Objectively Down）：ODOWN需要一定数量的sentinel，多个哨兵达成一致意见才能认为一个master客观上已经宕掉。 选举出领导者哨兵（哨兵中选出兵王）：当主节点被判断客观下线以后，各个哨兵节点会进行协商先选举出一个 领导者哨兵节点（兵王） 并由该领导者节点也即被选举出的兵王进行failover（故障迁移）。Raft算法选兵王， 由兵王开始推动故障切换流程并选出一个新master： 某个Slave被选中成为新master规则 执行slaveof no one命令让选出来的从节点成为新的主节点，并通过slaveof命令让其他节点成为其从节点；Sentinel leader会对选举出的新master执行slaveofno one操作，将其提升为master节点；Sentinel leader向其它slave发送命令，让剩余的slave成为新的master节点的slave。 将之前已下线的老master设置为新选出的新master的从节点，当老master重新上线后，它会成为新master的从节点；Sentinel leader会让原来的master降级为slave并恢复正常工作。 哨兵使用建议： 哨兵节点的数量应为多个，哨兵本身应该集群，保证高可用； 哨兵节点的数量应该是奇数； 各个哨兵节点的配置应一致； 如果哨兵节点部署在Docker等容器里面，尤其要注意端口的正确映射； 哨兵集群+主从复制，并不能保证数据零丢失，写操作会被终止，承上启下引出 集群。 Redis集群（cluster）定义：由于数据量过大，单个Master复制集难以承担，因此需要对多个复制集进行集群，形成水平扩展每个复制集只负责存储整个数据集的一部分，这就是Redis的集群，其作用是提供在多个Redis节点间共享数据的程序集。Redis集群是一个提供在多个Redis节点间共享数据的程序集，可以支持多个Master。 作用： Redis集群支持多个Master，每个Master又可以挂载多个Slave； 由于Cluster自带Sentinel的故障转移机制，内置了高可用的支持，无需再去使用哨兵功能； 客户端与Redis的节点连接，不再需要连接集群中的所有节点，只需要任意连接集群中的一个可用节点即可； 槽位slot负责分配到各个物理服务节点，由对应的集群来负责维护节点、插槽和数据之间的关系。 集群算法-分片-槽位slot： 官网：集群的key空间被分成 16384个槽（slots），有效设置了16384个主节点的集群大小上线，但建议的最大节点大小为 1000个节点；集群中的每个节点处理16384个哈希槽的一个子集； 每个key通过CRC16校验后对16384取模来决定放置哪个槽 HASH_SLOT &#x3D; CRC16(key) mod 16394； 优势：方便扩容缩容和数据的分派查找，无论添加删除或改变某个节点的哈希槽的数量都不会造成集群不可用的状态； 槽位映射的解决方案 哈希取余分区：hash(key) % N个机器台数；优点：简单粗暴，直接有效，起到负载均衡+分而治之的作用；缺点：需要弹性扩容或故障停机的情况下，原来的取模公式就会发生变化，此时地址经过取余运算的结果将发生很大变化，根据公式获取的服务器也会变得不可控，由于台数数量变化，会导致hash取余全部数据重新洗牌； 一致性哈希算法分区：目的是当服务器个数发生变动时，尽量减少影响客户端到服务器的映射关系；构建一致性哈希环[0,2^32-1]、redis服务器IP节点对2^32取模映射到环上的某一个位置、落键规则为从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器 优点：容错性（宕机时受影响的数据仅仅是此服务器到其环空间中前一台服务器之间数据，其它不会受到影响）、扩展性（添加新节点时，不会导致hash取余全部数据重新洗牌）；缺点：数据倾斜问题（节点太少时，容易因为节点分布不均匀而造成数据倾斜，被缓存的对象大部分集中缓存在某一台服务器上的问题）； 哈希槽分区：HASH_SLOT &#x3D; CRC16(key) mod 16394；CRC16源码基于c实现 12345import io.lettuce.core.cluster.SlotHash; SlotHash.getSlot(&quot;A&quot;); 为什么redis集群的最大槽数是16384个？ (1) 如果槽位为65536，发送心跳信息的消息头达8k，发送的心跳包过于庞大。 在消息头中最占空间的是myslots[CLUSTER_SLOTS&#x2F;8]。 当槽位为65536时，这块的大小是: 65536÷8÷1024&#x3D;8kb 在消息头中最占空间的是myslots[CLUSTER_SLOTS&#x2F;8]。 当槽位为16384时，这块的大小是: 16384÷8÷1024&#x3D;2kb 因为每秒钟，redis节点需要发送一定数量的ping消息作为心跳包，如果槽位为65536，这个ping消息的消息头太大了，浪费带宽。 (2) redis的集群主节点数量基本不可能超过1000个。 集群节点越多，心跳包的消息体内携带的数据越多。如果节点过1000个，也会导致网络拥堵。因此redis作者不建议redis cluster节点数量超过1000个。 那么，对于节点数在1000以内的redis cluster集群，16384个槽位够用了。没有必要拓展到65536个。 (3) 槽位越小，节点少的情况下，压缩比高，容易传输 Redis主节点的配置信息中它所负责的哈希槽是通过一张bitmap的形式来保存的，在传输过程中会对bitmap进行压缩，但是如果bitmap的填充率slots &#x2F; N很高的话(N表示节点数)，bitmap的压缩率就很低。 如果节点数很少，而哈希槽数量很多的话，bitmap的压缩率就很低。 Redis集群不保证强一致性，这意味着在特定的条件下，Redis集群可能会丢掉一些被系统收到的写入请求命令。 集群环境案例步骤： 三主三从redis集群配置 123456789101112131415161718bind 0.0.0.0daemonize yesprotected-mode noport 6381logfile &quot;/myredis/cluster/cluster6381.log&quot;pidfile /myredis/cluster6381.piddir /myredis/clusterdbfilename dump6381.rdbappendonly yesappendfilename &quot;appendonly6381.aof&quot;requirepass 111111masterauth 111111cluster-enabled yescluster-config-file nodes-6381.confcluster-node-timeout 5000 构建主从关系命令 1234redis-cli -a 111111 --cluster create --cluster-replicas 1 192.168.111.175:6381 192.168.111.175:6382 192.168.111.172:6383 192.168.111.172:6384 192.168.111.174:6385 192.168.111.174:6386 //--cluster-replicas 1 表示为每个master创建一个slave节点 检验集群状态 12345info replication cluster info cluster nodes 三主三从redis集群读写 一定注意槽位的范围区间，需要路由到位； 防止路由失效加参数-c：redis-cli -a 11111 -p 6381 -c cluster keyslot 键名称 查看某个key该属于的对应槽位值 主从容错切换迁移 主机宕机，从机上位并正常使用 原主机重连，论为从机节点 手动故障转移or节点从属关系调整：在从节点上发起转移，使用cluster failover命令 主从扩容 加入原有集群：redis-cli -a 密码 –cluster add-node master新增节点 原来集群里的任意一个节点 检查集群情况：redis-cli -a 密码 –cluster check 真实IP地址:端口号 重新分派槽号slots：redis-cli -a 密码 –cluster reshard IP地址:端口号 重新分配成本太高，所以由原有的旧节点分别匀出相等数量个槽位给新节点，所以新节点的槽位可能不是连续的 分配从节点：redis-cli -a 密码 –cluster add-node ip:新slave端口 ip:新master端口 –cluster-slave –cluster-master-id 新主机节点ID 主从缩容 先删除从节点：redis-cli -a 密码 –cluster del-node ip:从机端口 从机节点ID 将待删除的主节点槽号清空，重新分配给其他主节点：redis-cli -a 密码 –cluster reshard IP地址:端口号 删除主节点：redis-cli -a 密码 –cluster del-node ip:端口 节点ID 不在同一个slot槽位下的多键操作支持不好，如mset、mget等多键操作，通识占位符登场，可以通过{}来定义同一个组的概念，使key中{}内相同内容的键值对放到一个slot槽位去，对照下图类似k1k2k3都映射为x，自然槽位一样 12345mset k1&#123;x&#125; v1 k2&#123;x&#125; v2 k3&#123;x&#125; v3 mget k1&#123;x&#125; k2&#123;x&#125; k3&#123;x&#125; 集群常用命令： 集群是否完整才能对外提供服务：cluster-require-full-coverage no&#x2F;yes； 默认值 yes , 即需要集群完整性，方可对外提供服务 通常情况，如果这3个小集群中，任何一个（1主1从）挂了，你这个集群对外可提供的数据只有2&#x2F;3了， 整个集群是不完整的， redis 默认在这种情况下，是不会对外提供服务的。 cluster countkeysinslot 槽位数字编号：该槽位被占用的key数量。 cluster keyslot 键名称：该键应该存在哪个槽位上。 SpringBoot集成RedisJedisJedis Client是Redis官网推荐的一个面向Java客户端，库文件实现了对各类API进行封装调用。 12345678&lt;!--jedis--&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;4.3.1&lt;/version&gt;&lt;/dependency&gt; 12345678910111213141516171819@Slf4jpublic class JedisDemo&#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis(&quot;192.168.111.185&quot;,6379); jedis.auth(&quot;111111&quot;); log.info(&quot;redis conn status:&#123;&#125;&quot;,&quot;连接成功&quot;); log.info(&quot;redis ping retvalue:&#123;&#125;&quot;,jedis.ping()); jedis.set(&quot;k1&quot;,&quot;jedis&quot;); log.info(&quot;k1 value:&#123;&#125;&quot;,jedis.get(&quot;k1&quot;)); &#125;&#125; LettuceLettuce是一个Redis的Java驱动包；Springboot2.0之后默认使用，Lettuce底层使用的是Netty。 12345678&lt;!--lettuce--&gt;&lt;dependency&gt; &lt;groupId&gt;io.lettuce&lt;/groupId&gt; &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt; &lt;version&gt;6.2.1.RELEASE&lt;/version&gt;&lt;/dependency&gt; 1234567891011121314151617181920212223//使用构建器 RedisURI.builderRedisURI uri = RedisURI.builder() .redis(&quot;192.168.111.181&quot;) .withPort(6379) .withAuthentication(&quot;default&quot;,&quot;111111&quot;) .build();//创建连接客户端RedisClient client = RedisClient.create(uri);StatefulRedisConnection conn = client.connect();//操作命令apiRedisCommands&lt;String,String&gt; commands = conn.sync();//keysList&lt;String&gt; list = commands.keys(&quot;*&quot;);for(String s : list) &#123; log.info(&quot;key:&#123;&#125;&quot;,s);&#125;//Stringcommands.set(&quot;k1&quot;,&quot;1111&quot;);String s1 = commands.get(&quot;k1&quot;);System.out.println(&quot;String s ===&quot;+s1) RedisTemplate(推荐使用) 单机版 1234567891011121314151617181920212223242526 &lt;!--SpringBoot与Redis整合依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;/dependency&gt;``` ```yaml# ========================redis单机=====================spring.redis.database=0# 修改为自己真实IPspring.redis.host=192.168.111.185spring.redis.port=6379spring.redis.password=111111spring.redis.lettuce.pool.max-active=8spring.redis.lettuce.pool.max-wait=-1msspring.redis.lettuce.pool.max-idle=8spring.redis.lettuce.pool.min-idle=0 1234567891011121314151617181920212223242526272829303132333435363738@Configurationpublic class RedisConfig&#123; /** * redis序列化的工具配置类，下面这个请一定开启配置 * 127.0.0.1:6379&gt; keys * * 1) &quot;ord:102&quot; 序列化过 * 2) &quot;\\xac\\xed\\x00\\x05t\\x00\\aord:102&quot; 野生，没有序列化过 * this.redisTemplate.opsForValue(); //提供了操作string类型的所有方法 * this.redisTemplate.opsForList(); // 提供了操作list类型的所有方法 * this.redisTemplate.opsForSet(); //提供了操作set的所有方法 * this.redisTemplate.opsForHash(); //提供了操作hash表的所有方法 * this.redisTemplate.opsForZSet(); //提供了操作zset的所有方法 * @param lettuceConnectionFactory * @return */ @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(LettuceConnectionFactory lettuceConnectionFactory) &#123; RedisTemplate&lt;String,Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); redisTemplate.setConnectionFactory(lettuceConnectionFactory); //设置key序列化方式string redisTemplate.setKeySerializer(new StringRedisSerializer()); //设置value的序列化方式json，使用GenericJackson2JsonRedisSerializer替换默认序列化 redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer()); redisTemplate.setHashKeySerializer(new StringRedisSerializer()); redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer()); redisTemplate.afterPropertiesSet(); return redisTemplate; &#125;&#125; 12345678910111213141516171819202122232425@Service@Slf4jpublic class OrderService&#123; public static final String ORDER_KEY = &quot;order:&quot;; @Resource private RedisTemplate redisTemplate; public void addOrder() &#123; int keyId = ThreadLocalRandom.current().nextInt(1000)+1; String orderNo = UUID.randomUUID().toString(); redisTemplate.opsForValue().set(ORDER_KEY+keyId,&quot;京东订单&quot;+ orderNo); log.info(&quot;=====&gt;编号&quot;+keyId+&quot;的订单流水生成:&#123;&#125;&quot;,orderNo); &#125; public String getOrderById(Integer id) &#123; return (String)redisTemplate.opsForValue().get(ORDER_KEY + id); &#125;&#125; 集群版 1234567891011# ========================redis集群=====================spring.redis.password=111111# 获取失败 最大重定向次数spring.redis.cluster.max-redirects=3spring.redis.lettuce.pool.max-active=8spring.redis.lettuce.pool.max-wait=-1msspring.redis.lettuce.pool.max-idle=8spring.redis.lettuce.pool.min-idle=0spring.redis.cluster.nodes=192.168.111.175:6381,192.168.111.175:6382,192.168.111.172:6383,192.168.111.172:6384,192.168.111.174:6385,192.168.111.174:6386 注意：SpringBoot客户端没有动态感知到RedisCluster的最新集群信息，所以当某一master机器意外宕机时，Redis集群能自动感知并自动完成主备切换，而springboot不行。原因是SpringBoot2.X版本，Redis默认的连接池采用Lettuce，默认不会刷新节点拓扑。 解决方案： 123456#支持集群拓扑动态感应刷新,自适应拓扑刷新是否使用所有可用的更新，默认false关闭spring.redis.lettuce.cluster.refresh.adaptive=true#定时刷新spring.redis.lettuce.cluster.refresh.period=2000","tags":[]},{"title":"offer-ES","date":"2024-06-17T01:35:04.000Z","path":"2024/06/17/offer-ES/","text":"概述Elasticsearch，简称ES，是一个开源的高扩展的分布式全文搜索引擎。 入门官网下载9300端口为Elasticsearch集群间组件的通信端口，9200端口为浏览器访问的http协议的RESTful端口。 倒排索引，强调关键字和文档的关联","tags":[]},{"title":"Java-gulimall","date":"2024-04-18T07:21:25.000Z","path":"2024/04/18/Java-gulimall/","text":"前置准备及环境配置我的配置：java version：1.8.0_152maven version：3.5.3node version：v16.18.1","tags":[]},{"title":"offer-JVM","date":"2024-03-11T02:32:11.000Z","path":"2024/03/11/offer-JVM/","text":"JVMJVM内存与垃圾回收1 JVM与Java体系结构 Java虚拟机是一台执行Java字节码的虚拟计算机；Java虚拟机就是二进制字节码的运行环境 特点：一次编译，到处运行；自动内存管理；自动垃圾回收功能 用户User ——&gt; 字节码文件 ——&gt; JVM ——&gt; 操作系统 ——&gt; 硬件 JVM的整体结构（HotSpot VM） JVM的架构模型：Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。前者指令集小，后者指令少。后者执行效率高，但依赖硬件。 JVM的生命周期： 虚拟机的启动：通过引导类加载器创建一个初始类来完成的，这个类是由虚拟机的具体实现指定的。 虚拟机的执行：执行一个所谓的Java程序的时候，真真正正执行的是一个叫Java虚拟机的进程。 虚拟机的退出：程序正常执行结束；异常或错误而导致终止；某线程调用Runtime类或System类的exit方法，Runtime类的halt方法。 2 类加载子系统类加载器和类的加载过程 类加载器子系统作用：负责从文件系统或网络中加载Class文件；ClassLoader只负责加载，至于是否可以运行，则有执行引擎决定。 类的加载过程：（加载 ——&gt; 链接（验证-&gt;准备-&gt;解析） ——&gt; 初始化） 加载：通过一个类的全限定名获取定义此类的二进制字节流；将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。 链接： 验证：目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。主要包括四种验证，文件格式验证、元数据验证、字节码验证、符号引用验证。 CAFE BABY 准备：为类变量分配内存并且设置该类变量的默认初始值，即零值。这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化。这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。 解析：将常量池内的符号引用转换为直接引用的过程。事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。 初始化：初始化阶段就是执行类构造器方法()的过程。此方法不需定义，式javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。构造器方法中指令按语句在源文件出现的顺序执行。()不同于类的构造器()。若该类具有父类，JVM会保证字类的()执行前，父类的()已经执行完毕。虚拟机必须保证一个类的()方法在多线程下被同步加锁. 1234567891011121314151617public class ClassInitTest &#123;private static int num = 1;static&#123; num = 2; number = 20; System.out.println(num); //System.out.println(number);//报错：非法的前向引用。&#125;private static int number = 10; //linking之prepare: number = 0 --&gt; initial: 20 --&gt; 10 public static void main(String[] args) &#123; System.out.println(ClassInitTest.num);//2 System.out.println(ClassInitTest.number);//10 &#125;&#125; 类加载器的分类JVM支持引导类加载器和用户自定义加载器两类。将派生于抽象类ClassLoader的类加载器都称为用户自定义加载器，如扩展类加载器、应用程序类加载器。 引导类加载器底层为非java语言（C&#x2F;C++）编写，Java的核心类库都是使用类加载器进行加载的，出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类。 扩展类加载器派生于ClassLoader，jre&#x2F;lib&#x2F;ext。 应用程序类加载器派生于ClassLoader，负责加载环境变量classpath或系统属性java.class.path指定路径下的类库，是程序中默认的类加载器。 ClassLoader，一个抽象类，loadClass(String name)或着findClass和defineClass组合使用，生成class实例，都不是抽象方法。 双亲委派机制（面试重点） 工作原理：1）如果一个类加载器收到了类加载器的请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；2）如果父类加载器还存在其父类加载器，则进一步向上委托，一次递归，请求最终将到达顶层的启动类加载器；3）如果父类加载器可以完成类加载器任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载。 优势：避免类的重复加载，保护程序安全，防止核心API被随意篡改。java.lang.wzh 沙箱安全机制，保证对java核心源代码的保护 其他内容 在JVM中表示两个class对象是否为同一类存在两个必要条件：1. 类的完整类名必须一致，包括包名。 2. 加载这个类的classLoader（指classLoader实例对象）必须相同。 如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。 类的主动使用和被动使用。主动使用分为七种情况：1）创建类的实例；2）访问某个类或接口的静态变量，或者对该静态变量赋值；3）调用类的静态方法；4）反射；5）初始化一个类的子类；6）java虚拟机启动时被标明为启动类的类；7）JDK 7 开始提供的动态语言支持。类的被动使用不会导致类的初始化。 3 运行时数据区概述及线程不同的JVM对于内存的划分方式和管理机制存在着部分差异。JVM允许一个应用有多个线程并行的执行；在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。 4 程序计数器（PC寄存器）介绍（Program Counter Register） JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟，程序钩子。 用来存储指向下一条指令的地址，由执行引擎读取下一条指令。内存空间小，运行速度最快的存储区域。 唯一一个没有规定任何OutofMemoryError的区域。 两个常见的问题 使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？答： 因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。 PC寄存器为甚会被设定为线程私有？答： 为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。 5 虚拟机栈虚拟机栈概述栈是运行时的单位，而堆是存储的单位。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧，对应着一次次的Java方法调用。是线程私有的。生命周期和线程一致。作用是主管Java程序的运行，它保存方法的局部变量（8种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。访问速度仅次于程序计数器，只有进栈出栈两个操作，对于栈来说不存在垃圾回收（GC）问题，但存在OOM问题。栈中可能出现的异常：1. StackOverflowError异常（线程请求分配的栈容量超过java虚拟机栈允许的最大容量）；2. OutOfMemoryError异常（没有足够的内存去扩展或创建）。 -Xss设置栈内存的大小 栈的存储单位栈帧（Stack Frame）；在这个线程上正在执行的每个方法都各自对应一个栈帧。栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种信息。当前栈帧——当前方法——当前类；栈帧结构：局部变量表（Local Variables）；操作数栈（Operand Stack）（或表达式栈）；动态链接（Dynamic Linking）（或指向允许时常量池的方法引用）；方法返回地址（Return Address）（或方法正常退出或者异常推出的定义）；一些附加信息。 局部变量表局部变量数组或本地变量表，定义一个数字数组，用于存储方法参数和定义在方法体内的局部变量，基本数据类型，对象引用，returnAddress类型。不存在数据安全问题，线程的私有数据；局部变量表所需的容量大小是在编译期确定下来的。只在当前方法调用中生效，随着栈帧的销毁而销毁。 局部变量表，最基本的存储单元是Slot（变量槽）；32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot；按照顺序被复制到每一个slot上； 如果当前帧是由构造方法或实例方法创建的，那么该对象引用this将会放在index为0的slot处，其余按顺序。 栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。 例：按照在类中声明的位置分–&gt; 1）成员变量，在使用前都经历过默认初始化赋值；类变量，linking的prepare阶段，默认赋值，initial阶段，显式赋值；实例变量，随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值。 2）局部变量，在使用前，必须进行显式赋值，否则编译不通过。 在栈帧中，与性能调优关系最为密切的部分是局部变量表，局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。 操作数栈栈可以使用数组或链表来实现。操作数栈是用数组实现，或叫表达式栈。根据字节码指令，入栈出栈。主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。编译期就定义好了栈深度。32bit一个栈单位深度，64bit两个。如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中。Java虚拟机的解释引擎是基于操作数栈的执行引擎。 代码追踪12345678910public void testAddOperation() &#123; //byte、short、char、boolean：都以int型来保存 byte i = 15; int j = 8; int k = i + j; // int m = 800;&#125; 如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中。 面试题重点：常见的i++和++i有什么区别？ 1234567891011121314151617181920212223242526public void add()&#123; //第1类问题： int i1 = 10; i1++; int i2 = 10; ++i2; //第2类问题： int i3 = 10; int i4 = i3++; int i5 = 10; int i6 = ++i5; //第3类问题： int i7 = 10; i7 = i7++; int i8 = 10; i8 = ++i8; //第4类问题： int i9 = 10; int i10 = i9++ + ++i9;&#125; 栈顶缓存技术Top-of-Stack Cashing：将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读&#x2F;写次数，提升执行引擎的执行效率。 动态链接每一个栈帧内部都包含一个指向运行时常量池中该栈帧的所属方法的引用。目的是将符号引用转换为调用方法的直接引用。 方法的调用：解析与分派静态链接：如果被调用的目标方法在编译器可知，且运行期保持不变（早期绑定）；动态链接：如果被调用的方法在编译器无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法（晚期绑定）。 绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。 如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。其他方法称为虚方法。 虚拟机中提供了以下几条方法调用指令: 普通调用指令： invokestatic：调用静态方法，解析阶段确定唯一方法版本； invokespecial：调用方法、私有及父类方法，解析阶段确定唯一方法版本； invokevirtual：调用所有虚方法； invokeinterface：调用接口方法。 动态调用指令： invokedynamic：动态解析出需要调用的方法，然后执行。如lambda表达式。 1，2调用的方法为非虚方法，其余（final修饰的除外）称为虚方法。 静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息。 123Java: String info = &quot;xxx&quot;;JS: var name = &quot;xxx&quot;;Python: info = 130.5 虚方法表：用索引表代替查找 方法返回地址 帧数据区（动态链接、方法返回地址、一些附加信息） 方法返回地址：存放调用该方法的pc寄存器的值。 一些附加信息及栈的相关面试题 一些附加信息：栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息。","tags":[]},{"title":"offer-SSM","date":"2023-08-29T05:25:35.000Z","path":"2023/08/29/offer-SSM/","text":"Maven版本：3.6.3 项目构建和依赖管理工具 Maven简介和快速入门介绍 Maven 是一款为 Java 项目构建管理、依赖管理的工具（软件），使用 Maven 可以自动化构建、测试、打包和发布项目，大大提高了开发效率和质量。 主要作用 依赖管理：Maven 可以管理项目的依赖，包括自动下载所需依赖库、自动下载依赖需要的依赖并且保证版本没有冲突、依赖版本管理等。通过 Maven，我们可以方便地维护项目所依赖的外部库，而我们仅仅需要编写配置即可。 构建管理：Maven 可以管理项目的编译、测试、打包、部署等构建过程。通过实现标准的构建生命周期，Maven 可以确保每一个构建过程都遵循同样的规则和最佳实践。同时，Maven 的插件机制也使得开发者可以对构建过程进行扩展和定制。主动触发构建，只需要简单的命令操作即可。 注：项目构建是指将源代码、配置文件、资源文件等转化为能够运行或部署的应用程序或库的过程！ 安装与配置修改maven&#x2F;conf&#x2F;settings.xml配置文件：1.依赖本地缓存位置（本地仓库位置） 2.maven下载镜像 3.maven选用编译项目的jdk版本 基于IDEA的Maven工程创建Maven工程的GAVP属性GAVP 是指 GroupId、ArtifactId、Version、Packaging 等四个属性的缩写，其中前三个是必要的，而 Packaging 属性为可选项。gav需要我们在创建项目的时指定，p有默认值，后期通过配置文件修改。GAV规则： GroupID 格式：com.{公司&#x2F;BU }.业务线.{子业务线}，最多 4 级。 ArtifactID 格式：产品线名-模块名。语义不重复不遗漏，先到仓库中心去查证一下。 Version版本号格式推荐：主版本号.次版本号.修订号 1.0.0Packaging定义规则： packaging 属性为 jar（默认值），代表普通的Java工程，打包以后是.jar结尾的文件。 packaging 属性为 war，代表Java的web工程，打包以后.war结尾的文件。 packaging 属性为 pom，代表不会打包，用来做继承的父工程。 Maven工程项目结构说明123456789101112131415161718192021222324|-- pom.xml # Maven 项目管理文件 |-- src |-- main # 项目主要代码 | |-- java # Java 源代码目录 | | `-- com/example/myapp # 开发者代码主目录 | | |-- controller # 存放 Controller 层代码的目录 | | |-- service # 存放 Service 层代码的目录 | | |-- dao # 存放 DAO 层代码的目录 | | `-- model # 存放数据模型的目录 | |-- resources # 资源目录，存放配置文件、静态资源等 | | |-- log4j.properties # 日志配置文件 | | |-- spring-mybatis.xml # Spring Mybatis 配置文件 | | `-- static # 存放静态资源的目录 | | |-- css # 存放 CSS 文件的目录 | | |-- js # 存放 JavaScript 文件的目录 | | `-- images # 存放图片资源的目录 | `-- webapp # 存放 WEB 相关配置和资源 | |-- WEB-INF # 存放 WEB 应用配置文件 | | |-- web.xml # Web 应用的部署描述文件 | | `-- classes # 存放编译后的 class 文件 | `-- index.html # Web 应用入口页面 `-- test # 项目测试代码 |-- java # 单元测试目录 `-- resources # 测试资源目录 pom.xml：Maven 项目管理文件，用于描述项目的依赖和构建配置等信息。 src&#x2F;main&#x2F;java：存放项目的 Java 源代码。 src&#x2F;main&#x2F;resources：存放项目的资源文件，如配置文件、静态资源等。 src&#x2F;main&#x2F;webapp&#x2F;WEB-INF：存放 Web 应用的配置文件。 src&#x2F;main&#x2F;webapp&#x2F;index.html：Web 应用的入口页面。 src&#x2F;test&#x2F;java：存放项目的测试代码。 src&#x2F;test&#x2F;resources：存放测试相关的资源文件，如测试配置文件等。 Maven核心功能依赖和构建管理依赖管理和配置Maven 依赖管理是 Maven 软件中最重要的功能之一。Maven 的依赖管理能够帮助开发人员自动解决软件包依赖问题，使得开发人员能够轻松地将其他开发人员开发的模块或第三方框架集成到自己的应用程序或模块中，避免出现版本冲突和依赖缺失等问题。 我们通过定义 POM 文件，Maven 能够自动解析项目的依赖关系，并通过 Maven **仓库自动**下载和管理依赖，从而避免了手动下载和管理依赖的繁琐工作和可能引发的版本冲突问题。 重点: 编写pom.xml文件! 123456789101112131415161718192021222324&lt;!-- 通过编写依赖jar包的gav必要属性，引入第三方依赖！ scope属性是可选的，可以指定依赖生效范围！ 依赖信息查询方式： 1. maven仓库信息官网 https://mvnrepository.com/ 2. mavensearch插件搜索 --&gt;&lt;dependencies&gt; &lt;!-- 引入具体的依赖包 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;!-- scope生效范围 - compile ：main目录 test目录 打包打包 [默认] - provided：main目录 test目录 Servlet - runtime： 打包运行 MySQL - test: test目录 junit --&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 依赖版本提取和维护: 1234567891011121314151617&lt;!--声明版本--&gt;&lt;properties&gt; &lt;!--命名随便,内部制定版本号即可！--&gt; &lt;junit.version&gt;4.11&lt;/junit.version&gt; &lt;!-- 也可以通过 maven规定的固定的key，配置maven的参数！如下配置编码格式！--&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;!--引用properties声明版本 --&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 依赖传递和冲突依赖传递指的是当一个模块或库 A 依赖于另一个模块或库 B，而 B 又依赖于模块或库 C，那么 A 会间接依赖于 C。这种依赖传递结构可以形成一个依赖树。当我们引入一个库或框架时，构建工具（如 Maven、Gradle）会自动解析和加载其所有的直接和间接依赖，确保这些依赖都可用。 依赖传递的作用是： 减少重复依赖：当多个项目依赖同一个库时，Maven 可以自动下载并且只下载一次该库。这样可以减少项目的构建时间和磁盘空间。 自动管理依赖: Maven 可以自动管理依赖项，使用依赖传递，简化了依赖项的管理，使项目构建更加可靠和一致。 确保依赖版本正确性：通过依赖传递的依赖，之间都不会存在版本兼容性问题，确实依赖的版本正确性！ 依赖冲突：发现已经存在依赖（重复依赖）会终止依赖传递，避免循环依赖和重复依赖的问题。 maven自动解决依赖冲突问题能力，会按照自己的原则，进行重复依赖选择。同时也提供了手动解决的冲突的方式，不过不推荐！ 解决依赖冲突（如何选择重复依赖）方式： - 短路优先原则（第一原则） A—&gt;B—&gt;C—&gt;D—&gt;E—&gt;X(version 0.0.1) A—&gt;F—&gt;X(version 0.0.2) 则A依赖于X(version 0.0.2)。 - 依赖路径长度相同情况下，则“先声明优先”（第二原则） A—&gt;E—&gt;X(version 0.0.1) A—&gt;F—&gt;X(version 0.0.2) 在&lt;depencies&gt;&lt;/depencies&gt;中，先声明的，路径相同，会优先选择！ 思考： 12345678910111213前提： A 1.1 -&gt; B 1.1 -&gt; C 1.1 F 2.2 -&gt; B 2.2 pom声明： F 2.2 A 1.1 B 2.2 结果： F 2.2 A 1.1 B 2.2 不会引入C 1.1，只要发生冲突了，后续的依赖传递全部终止 依赖导入失败场景和解决方案在使用 Maven 构建项目时，可能会发生依赖项下载错误的情况，主要原因有以下几种： 下载依赖时出现网络故障或仓库服务器宕机等原因，导致无法连接至 Maven 仓库，从而无法下载依赖。 依赖项的版本号或配置文件中的版本号错误，或者依赖项没有正确定义，导致 Maven 下载的依赖项与实际需要的不一致，从而引发错误。 本地 Maven 仓库或缓存被污染或损坏，导致 Maven 无法正确地使用现有的依赖项，并且也无法重新下载！ 解决方案： 检查网络连接和 Maven 仓库服务器状态。 确保依赖项的版本号与项目对应的版本号匹配，并检查 POM 文件中的依赖项是否正确。 清除本地 Maven 仓库缓存（lastUpdated 文件），因为只要存在lastupdated缓存文件，刷新也不会重新下载。本地仓库中，根据依赖的gav属性依次向下查找文件夹，最终删除内部的文件，刷新重新下载即可！ 例如： pom.xml依赖 扩展构建管理和插件配置构建概念: 项目构建是指将源代码、依赖库和资源文件等转换成可执行或可部署的应用程序的过程，在这个过程中包括编译源代码、链接依赖库、打包和部署等多个步骤。 清理→编译→测试→报告→打包→部署 主动触发场景： 重新编译 : 编译不充分, 部分文件没有被编译! 打包 : 独立部署到外部服务器软件,打包部署 部署本地或者私服仓库 : maven工程加入到本地或者私服仓库,供其他工程使用 命令方式构建: 语法: mvn 构建命令 构建命令….（1.命执行需要我们进入到项目的根路径，pom.xml平级；2.部署必须是jar包形式） 命令 描述 mvn clean 清理编译或打包后的项目结构,删除target文件夹 mvn compile 编译项目，生成target文件 mvn test 执行测试源码 (测试) mvn site 生成一个项目依赖信息的展示页面 mvn package 打包项目，生成war &#x2F; jar 文件 mvn install 打包后上传到maven本地仓库(本地部署) mvn deploy 只打包，上传到maven私服仓库(私服部署) 可视化方式构建: IDE中的Maven界面，lifestyle。 构建命令周期: 构建生命周期可以理解成是一组固定构建命令的有序集合，触发周期后的命令，会自动触发周期前的命令！也是一种简化构建的思路! 清理周期：主要是对项目编译生成文件进行清理 包含命令：clean 构建周期：定义了真正构件时所需要执行的所有步骤，它是生命周期中最核心的部分 包含命令：compile - test - package - install &#x2F; deploy 报告周期 包含命令：site 打包: mvn clean package 本地仓库: mvn clean install 最佳使用方案: 123打包: mvn clean package重新编译: mvn clean compile本地部署: mvn clean install 周期，命令和插件: 周期→包含若干命令→包含若干插件! 使用周期命令构建，简化构建过程！ 最终进行构建的是插件！ 插件配置: 12345678910&lt;build&gt;&lt;!-- jdk17 和 war包版本插件不匹配 --&gt;&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt;&lt;/plugins&gt;&lt;/build&gt; Maven继承和聚合特性Maven工程继承关系 继承概念 Maven 继承是指在 Maven 的项目中，让一个项目从另一个项目中继承配置信息的机制。继承可以让我们在多个项目中共享同一配置信息，简化项目的管理和维护工作。 继承作用 作用：在父工程中统一管理项目中的依赖信息,进行统一版本管理! 它的背景是： 对一个比较大型的项目进行了模块拆分。 一个 project 下面，创建了很多个 module。 每一个 module 都需要配置自己的依赖信息。 它背后的需求是： 多个模块要使用同一个框架，它们应该是同一个版本，所以整个项目中使用的框架版本需要统一管理。 使用框架时所需要的 jar 包组合（或者说依赖信息组合）需要经过长期摸索和反复调试，最终确定一个可用组合。这个耗费很大精力总结出来的方案不应该在新的项目中重新摸索。 通过在父工程中为整个项目维护依赖信息的组合既保证了整个项目使用规范、准确的 jar 包；又能够将以往的经验沉淀下来，节约时间和精力。 继承语法 父工程 123456789101112131415161718192021222324&lt;groupId&gt;com.wzh.maven&lt;/groupId&gt;&lt;artifactId&gt;pro03-maven-parent&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;!-- 当前工程作为父工程，它要去管理子工程，所以打包方式必须是 pom --&gt;&lt;packaging&gt;pom&lt;/packaging&gt;``` - 子工程```XML&lt;!-- 使用parent标签指定当前工程的父工程 --&gt;&lt;parent&gt; &lt;!-- 父工程的坐标 --&gt; &lt;groupId&gt;com.wzh.maven&lt;/groupId&gt; &lt;artifactId&gt;pro03-maven-parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/parent&gt;&lt;!-- 子工程的坐标 --&gt;&lt;!-- 如果子工程坐标中的groupId和version与父工程一致，那么可以省略 --&gt;&lt;!-- &lt;groupId&gt;com.wzh.maven&lt;/groupId&gt; --&gt;&lt;artifactId&gt;pro04-maven-module&lt;/artifactId&gt;&lt;!-- &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; --&gt; 父工程依赖统一管理 父工程声明版本 12345678910111213141516171819202122232425262728293031&lt;!-- 使用dependencyManagement标签配置对依赖的管理 --&gt;&lt;!-- 被管理的依赖并没有真正被引入到工程 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 子工程引用版本 12345678910111213141516171819202122232425&lt;!-- 子工程引用父工程中的依赖信息时，可以把版本号去掉。 --&gt;&lt;!-- 把版本号去掉就表示子工程中这个依赖的版本由父工程决定。 --&gt;&lt;!-- 具体来说是由父工程的dependencyManagement来决定。 --&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 4.2 Maven工程聚合关系 聚合概念 Maven 聚合是指将多个项目组织到一个父级项目中，通过触发父工程的构建,统一按顺序触发子工程构建的过程!! 聚合作用 统一管理子项目构建：通过聚合，可以将多个子项目组织在一起，方便管理和维护。 优化构建顺序：通过聚合，可以对多个项目进行顺序控制，避免出现构建依赖混乱导致构建失败的情况。 聚合语法 父项目中包含的子项目列表。 12345678910&lt;project&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;parent-project&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;modules&gt; &lt;module&gt;child-project1&lt;/module&gt; &lt;module&gt;child-project2&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; 聚合演示 通过触发父工程构建命令、引发所有子模块构建！产生反应堆！ Spring版本：6.0.6Ioc和AOP以及TX 技术体系结构总体技术体系 单一架构 一个项目，一个工程，导出为一个war包，在一个Tomcat上运行。也叫all in one。 单一架构，项目主要应用技术框架为：Spring , SpringMVC , Mybatis 分布式架构 一个项目（对应 IDEA 中的一个 project），拆分成很多个模块，每个模块是一个 IDEA 中的一个 module。每一个工程都是运行在自己的 Tomcat 上。模块之间可以互相调用。每一个模块内部可以看成是一个单一架构的应用。 分布式架构，项目主要应用技术框架：SpringBoot (SSM), SpringCloud , 中间件等 框架概念和理解框架( Framework )是一个集成了基本结构、规范、设计模式、编程语言和程序库等基础组件的软件系统，它可以用来构建更高级别的应用程序。框架的设计和实现旨在解决特定领域中的常见问题，帮助开发人员更高效、更稳定地实现软件开发目标。 优点：1）提高开发效率；2）降低开发成本；3）提高应用程序的稳定性；4）提供标准化的解决方案。 缺点：1）学习成本高；2）降低开发成本；3）版本变更和兼容性问题；4）架构风险。 站在文件结构的角度理解框架，可以将框架总结：框架 &#x3D; jar包+配置文件 SpringFramework介绍Spring和SpringFramework概念 广义的Spring：Spring技术栈（全家桶），以 Spring Framework 为基础 狭义的Spring：Spring Framework SpringFramework主要功能模块 SpringFramework框架结构图： 功能模块 功能介绍 Core Container 核心容器，在 Spring 环境下使用任何功能都必须基于 IOC 容器。 AOP&amp;Aspects 面向切面编程 TX 声明式事务管理。 Spring MVC 提供了面向Web应用程序的集成功能。 SpringFramework主要优势 丰富的生态系统：Spring 生态系统非常丰富，支持许多模块和库，如 Spring Boot、Spring Security、Spring Cloud 等等，可以帮助开发人员快速构建高可靠性的企业应用程序。 模块化的设计：框架组件之间的松散耦合和模块化设计使得 Spring Framework 具有良好的可重用性、可扩展性和可维护性。开发人员可以轻松地选择自己需要的模块，根据自己的需求进行开发。 简化 Java 开发：Spring Framework 简化了 Java 开发，提供了各种工具和 API，可以降低开发复杂度和学习成本。同时，Spring Framework 支持各种应用场景，包括 Web 应用程序、RESTful API、消息传递、批处理等等。 不断创新和发展：Spring Framework 开发团队一直在不断创新和发展，保持与最新技术的接轨，为开发人员提供更加先进和优秀的工具和框架。 Spring IoC容器和核心概念组件和组件管理概念 Spring充当组件管理角色（IoC） 组件可以完全交给Spring 框架进行管理，Spring框架替代了程序员原有的new对象和对象属性赋值动作等！ Spring具体的组件管理动作包含： 组件对象实例化 组件属性属性赋值 组件对象之间引用 组件对象存活周期管理 …… 我们只需要编写元数据（配置文件）告知Spring 管理哪些类组件和他们的关系即可！ 注意：组件是映射到应用程序中所有可重用组件的Java对象，应该是可复用的功能对象！ 组件一定是对象 对象不一定是组件 综上所述，Spring 充当一个组件容器，创建、管理、存储组件，减少了我们的编码压力，让我们更加专注进行业务编写！ 组件交给Spring管理优势! 降低了组件之间的耦合性：Spring IoC容器通过依赖注入机制，将组件之间的依赖关系削弱，减少了程序组件之间的耦合性，使得组件更加松散地耦合。 提高了代码的可重用性和可维护性：将组件的实例化过程、依赖关系的管理等功能交给Spring IoC容器处理，使得组件代码更加模块化、可重用、更易于维护。 方便了配置和管理：Spring IoC容器通过XML文件或者注解，轻松的对组件进行配置和管理，使得组件的切换、替换等操作更加的方便和快捷。 交给Spring管理的对象（组件），方可享受Spring框架的其他功能（AOP,声明事务管理）等 Spring IoC容器和容器实现 普通和复杂容器 普通容器 数组 集合：List 集合：Set 复杂容器 Servlet 容器能够管理 Servlet(init,service,destroy)、Filter、Listener 这样的组件的一生，所以它是一个复杂容器。 SpringIoC 容器也是一个复杂容器。它们不仅要负责创建组件的对象、存储组件的对象，还要负责调用组件的方法让它们工作，最终在特定情况下销毁组件。 总结：Spring管理组件的容器，就是一个复杂容器，不仅存储组件，也可以管理组件之间依赖关系，并且创建和销毁组件等！ SpringIoC容器介绍 Spring IoC 容器，负责实例化、配置和组装 bean（组件）。容器通过读取配置元数据来获取有关要实例化、配置和组装组件的指令。配置元数据以 XML、Java 注解或 Java 代码形式表现。它允许表达组成应用程序的组件以及这些组件之间丰富的相互依赖关系。 SpringIoC容器具体接口和实现类 SpringIoc容器接口： BeanFactory 接口提供了一种高级配置机制，能够管理任何类型的对象，它是SpringIoC容器标准化超接口！ ApplicationContext 是 BeanFactory 的子接口。它扩展了以下功能： 更容易与 Spring 的 AOP 功能集成 消息资源处理（用于国际化） 特定于应用程序给予此接口实现，例如Web 应用程序的 WebApplicationContext 简而言之， BeanFactory 提供了配置框架和基本功能，而 ApplicationContext 添加了更多特定于企业的功能。 ApplicationContext 是 BeanFactory 的完整超集！ ApplicationContext容器实现类： 类型名 简介 ClassPathXmlApplicationContext 通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象 FileSystemXmlApplicationContext 通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象 AnnotationConfigApplicationContext 通过读取Java配置类创建 IOC 容器对象 WebApplicationContext 专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。 SpringIoC容器管理配置方式 Spring IoC 容器使用多种形式的配置元数据。此配置元数据表示您作为应用程序开发人员如何告诉 Spring 容器实例化、配置和组装应用程序中的对象。 Spring框架提供了多种配置方式：XML配置方式、注解方式和Java配置类方式 XML配置方式：是Spring框架最早的配置方式之一，通过在XML文件中定义Bean及其依赖关系、Bean的作用域等信息，让Spring IoC容器来管理Bean之间的依赖关系。该方式从Spring框架的第一版开始提供支持。 注解方式：从Spring 2.5版本开始提供支持，可以通过在Bean类上使用注解来代替XML配置文件中的配置信息。通过在Bean类上加上相应的注解（如@Component, @Service, @Autowired等），将Bean注册到Spring IoC容器中，这样Spring IoC容器就可以管理这些Bean之间的依赖关系。 ** Java配置类**方式：从Spring 3.0版本开始提供支持，通过Java类来定义Bean、Bean之间的依赖关系和配置信息，从而代替XML配置文件的方式。Java配置类是一种使用Java编写配置信息的方式，通过@Configuration、@Bean等注解来实现Bean和依赖关系的配置。 为了迎合当下开发环境，我们将以配置类+注解方式为主进行讲解！ Spring IoC &#x2F; DI概念总结 IoC容器 Spring IoC 容器，负责实例化、配置和组装 bean（组件）核心容器。容器通过读取配置元数据来获取有关要实例化、配置和组装组件的指令。 IoC（Inversion of Control）控制反转 IoC 主要是针对对象的创建和调用控制而言的，也就是说，当应用程序需要使用一个对象时，不再是应用程序直接创建该对象，而是由 IoC 容器来创建和管理，即控制权由应用程序转移到 IoC 容器中，也就是“反转”了控制权。这种方式基本上是通过依赖查找的方式来实现的，即 IoC 容器维护着构成应用程序的对象，并负责创建这些对象。 DI (Dependency Injection) 依赖注入 DI 是指在组件之间传递依赖关系的过程中，将依赖关系在容器内部进行处理，这样就不必在应用程序代码中硬编码对象之间的依赖关系，实现了对象之间的解耦合。在 Spring 中，DI 是通过 XML 配置文件或注解的方式实现的。它提供了三种形式的依赖注入：构造函数注入、Setter 方法注入和接口注入。 Spring IoC实践和应用Spring IoC &#x2F; DI 实现步骤 我们总结下，组件交给Spring IoC容器管理，并且获取和使用的基本步骤！ 配置元数据（配置） 配置元数据，既是编写交给SpringIoC容器管理组件的信息，配置方式有三种。 基于 XML 的配置元数据的基本结构： &lt;bean id&#x3D;”…” [1] class&#x3D;”…” [2]&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- 此处要添加一些约束，配置文件的标签并不是随意命名 --&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;...&quot; [1] class=&quot;...&quot; [2]&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;!-- more bean definitions go here --&gt;&lt;/beans&gt; Spring IoC 容器管理一个或多个组件。这些 组件是使用你提供给容器的配置元数据（例如，以 XML `&lt;bean/&gt;` 定义的形式）创建的。 &lt;bean /&gt; 标签 == 组件信息声明 - `id` 属性是标识单个 Bean 定义的字符串。 - `class` 属性定义 Bean 的类型并使用完全限定的类名。 实例化IoC容器 提供给 ApplicationContext 构造函数的位置路径是资源字符串地址，允许容器从各种外部资源（如本地文件系统、Java CLASSPATH 等）加载配置元数据。 我们应该选择一个合适的容器实现类，进行IoC容器的实例化工作： 123//实例化ioc容器,读取外部配置文件,最终会在容器内进行ioc和di动作ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;); 获取Bean（组件） ApplicationContext 是一个高级工厂的接口，能够维护不同 bean 及其依赖项的注册表。通过使用方法 T getBean(String name, Class&lt;T&gt; requiredType) ，您可以检索 bean 的实例。 允许读取 Bean 定义并访问它们，如以下示例所示： 123456//创建ioc容器对象，指定配置文件，ioc也开始实例组件对象ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);//获取ioc容器的组件对象PetStoreService service = context.getBean(&quot;petStore&quot;, PetStoreService.class);//使用组件对象List&lt;String&gt; userList = service.getUsernameList(); 基于XML配置方式组件管理组件（Bean）信息声明配置（IoC） 基于无参数构造函数 当通过构造函数方法创建一个 bean（组件对象） 时，所有普通类都可以由 Spring 使用并与之兼容。也就是说，正在开发的类不需要实现任何特定的接口或以特定的方式进行编码。只需指定 Bean 类信息就足够了。但是，默认情况下，我们需要一个默认（空）构造函数。 12&lt;!-- 实验一 [重要]创建bean --&gt;&lt;bean id=&quot;happyComponent&quot; class=&quot;com.wzh.ioc.HappyComponent&quot;/&gt; - bean标签：通过配置bean标签告诉IOC容器需要创建对象的组件信息 - id属性：bean的唯一标识,方便后期获取Bean！ - class属性：组件类的全限定符！ - 注意：要求当前组件类必须包含无参数构造函数！ 基于静态工厂方法实例化 除了使用构造函数实例化对象，还有一类是通过工厂模式实例化对象。接下来我们讲解如何定义使用静态工厂方法创建Bean的配置 ！ 123456789public class ClientService &#123; private static ClientService clientService = new ClientService(); private ClientService() &#123;&#125; public static ClientService createInstance() &#123; return clientService; &#125;&#125; 123&lt;bean id=&quot;clientService&quot; class=&quot;examples.ClientService&quot; factory-method=&quot;createInstance&quot;/&gt; - class属性：指定工厂类的全限定符！ - factory-method: 指定静态工厂方法，注意，该方法必须是static方法。 基于实例工厂方法实例化 接下来我们讲解下如何定义使用实例工厂方法创建Bean的配置 ！ 12345678public class DefaultServiceLocator &#123; private static ClientServiceImplclientService = new ClientServiceImpl(); public ClientService createClientServiceInstance() &#123; return clientService; &#125;&#125; 12345678&lt;!-- 将工厂类进行ioc配置 --&gt;&lt;bean id=&quot;serviceLocator&quot; class=&quot;examples.DefaultServiceLocator&quot;&gt;&lt;/bean&gt;&lt;!-- 根据工厂对象的实例工厂方法进行实例化组件对象 --&gt;&lt;bean id=&quot;clientService&quot; factory-bean=&quot;serviceLocator&quot; factory-method=&quot;createClientServiceInstance&quot;/&gt; - factory-bean属性：指定当前容器中工厂Bean 的名称。 - factory-method: 指定实例工厂方法名。注意，实例方法必须是非static的！ 组件（Bean）依赖注入配置（DI） 通过配置文件,实现IoC容器中Bean之间的引用（依赖注入DI配置）。主要涉及注入场景：基于构造函数的依赖注入和基于 Setter 的依赖注入。 基于构造函数的依赖注入 12345678910111213public class UserDao &#123;&#125;public class UserService &#123; private UserDao userDao; public UserService(UserDao userDao) &#123; this.userDao = userDao; &#125;&#125; 123456789&lt;beans&gt; &lt;!-- 引用类bean声明 --&gt; &lt;bean id=&quot;userService&quot; class=&quot;x.y.UserService&quot;&gt; &lt;!-- 构造函数引用 --&gt; &lt;constructor-arg ref=&quot;userDao&quot;/&gt; &lt;/bean&gt; &lt;!-- 被引用类bean声明 --&gt; &lt;bean id=&quot;userDao&quot; class=&quot;x.y.UserDao&quot;/&gt;&lt;/beans&gt; - constructor-arg标签：可以引用构造参数 ref引用其他bean的标识。 基于构造函数的依赖注入（多构造参数解析） 123456789101112131415161718public class UserDao &#123;&#125;public class UserService &#123; private UserDao userDao; private int age; private String name; public UserService(int age , String name ,UserDao userDao) &#123; this.userDao = userDao; this.age = age; this.name = name; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!-- 场景1: 多参数，可以按照相应构造函数的顺序注入数据 --&gt;&lt;beans&gt; &lt;bean id=&quot;userService&quot; class=&quot;x.y.UserService&quot;&gt; &lt;!-- value直接注入基本类型值 --&gt; &lt;constructor-arg value=&quot;18&quot;/&gt; &lt;constructor-arg value=&quot;赵伟风&quot;/&gt; &lt;constructor-arg ref=&quot;userDao&quot;/&gt; &lt;/bean&gt; &lt;!-- 被引用类bean声明 --&gt; &lt;bean id=&quot;userDao&quot; class=&quot;x.y.UserDao&quot;/&gt;&lt;/beans&gt;&lt;!-- 场景2: 多参数，可以按照相应构造函数的名称注入数据 --&gt;&lt;beans&gt; &lt;bean id=&quot;userService&quot; class=&quot;x.y.UserService&quot;&gt; &lt;!-- value直接注入基本类型值 --&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;赵伟风&quot;/&gt; &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;/&gt; &lt;/bean&gt; &lt;!-- 被引用类bean声明 --&gt; &lt;bean id=&quot;userDao&quot; class=&quot;x.y.UserDao&quot;/&gt;&lt;/beans&gt;&lt;!-- 场景2: 多参数，可以按照相应构造函数的角标注入数据 index从0开始 构造函数(0,1,2....)--&gt;&lt;beans&gt; &lt;bean id=&quot;userService&quot; class=&quot;x.y.UserService&quot;&gt; &lt;!-- value直接注入基本类型值 --&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;赵伟风&quot;/&gt; &lt;constructor-arg index=&quot;2&quot; ref=&quot;userDao&quot;/&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;18&quot;/&gt; &lt;/bean&gt; &lt;!-- 被引用类bean声明 --&gt; &lt;bean id=&quot;userDao&quot; class=&quot;x.y.UserDao&quot;/&gt;&lt;/beans&gt; - constructor-arg标签：指定构造参数和对应的值 - constructor-arg标签：name属性指定参数名、index属性指定参数角标、value属性指定普通属性值 基于Setter方法依赖注入 1234567891011121314151617181920public Class MovieFinder&#123;&#125;public class SimpleMovieLister &#123; private MovieFinder movieFinder; private String movieName; public void setMovieFinder(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125; public void setMovieName(String movieName)&#123; this.movieName = movieName; &#125; // business logic that actually uses the injected MovieFinder is omitted...&#125; 1234567891011121314&lt;bean id=&quot;simpleMovieLister&quot; class=&quot;examples.SimpleMovieLister&quot;&gt; &lt;!-- setter方法，注入movieFinder对象的标识id name = 属性名 ref = 引用bean的id值 --&gt; &lt;property name=&quot;movieFinder&quot; ref=&quot;movieFinder&quot; /&gt; &lt;!-- setter方法，注入基本数据类型movieName name = 属性名 value= 基本类型值 --&gt; &lt;property name=&quot;movieName&quot; value=&quot;消失的她&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;movieFinder&quot; class=&quot;examples.MovieFinder&quot;/&gt; - property标签： 可以给setter方法对应的属性赋值 - property 标签： name属性代表**set方法标识**、ref代表引用bean的标识id、value属性代表基本属性值 IoC容器创建和使用 容器实例化 12345678910111213//方式1:实例化并且指定配置文件//参数：String...locations 传入一个或者多个配置文件ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;); //方式2:先实例化，再指定配置文件，最后刷新容器触发Bean实例化动作 [springmvc源码和contextLoadListener源码方式] ApplicationContext context = new ClassPathXmlApplicationContext(); //设置配置配置文件,方法参数为可变参数,可以设置一个或者多个配置iocContainer1.setConfigLocations(&quot;services.xml&quot;, &quot;daos.xml&quot;);//后配置的文件,需要调用refresh方法,触发刷新配置iocContainer1.refresh(); Bean对象读取 123456789101112131415161718//方式1: 根据id获取//没有指定类型,返回为Object,需要类型转化!HappyComponent happyComponent = (HappyComponent) iocContainer.getBean(&quot;bean的id标识&quot;); //使用组件对象 happyComponent.doWork();//方式2: 根据类型获取//根据类型获取,但是要求,同类型(当前类,或者之类,或者接口的实现类)只能有一个对象交给IoC容器管理//配置两个或者以上出现: org.springframework.beans.factory.NoUniqueBeanDefinitionException 问题HappyComponent happyComponent = iocContainer.getBean(HappyComponent.class);happyComponent.doWork();//方式3: 根据id和类型获取HappyComponent happyComponent = iocContainer.getBean(&quot;bean的id标识&quot;, HappyComponent.class);happyComponent.doWork(); 高级特性：组件（Bean）作用域和周期方法配置 组件周期方法配置我们可以在组件类中定义方法，然后当IoC容器实例化和销毁组件对象的时候进行调用！这两个方法我们成为生命周期方法！类似于Servlet的init&#x2F;destroy方法,我们可以在周期方法完成初始化和释放资源等工作。 1234567891011121314public class BeanOne &#123; //周期方法要求： 方法命名随意，但是要求方法必须是 public void 无形参列表 public void init() &#123; // 初始化逻辑 &#125;&#125;public class BeanTwo &#123; public void cleanup() &#123; // 释放资源逻辑 &#125;&#125; 周期方法配置 1234&lt;beans&gt; &lt;bean id=&quot;beanOne&quot; class=&quot;examples.BeanOne&quot; init-method=&quot;init&quot; /&gt; &lt;bean id=&quot;beanTwo&quot; class=&quot;examples.BeanTwo&quot; destroy-method=&quot;cleanup&quot; /&gt;&lt;/beans&gt; 组件作用域配置 Bean作用域概念 &lt;bean 标签声明Bean，只是将Bean的信息配置给SpringIoC容器！ 在IoC容器中，这些&lt;bean标签对应的信息转成Spring内部 BeanDefinition 对象，BeanDefinition 对象内，包含定义的信息（id,class,属性等等）！ 这意味着，BeanDefinition与类概念一样，SpringIoC容器可以可以根据BeanDefinition对象反射创建多个Bean对象实例。 具体创建多少个Bean的实例对象，由Bean的作用域Scope属性指定！ 作用域可选值 取值 含义 创建对象的时机 默认值 singleton 在 IOC 容器中，这个 bean 的对象始终为单实例 IOC 容器初始化时 是 prototype 这个 bean 在 IOC 容器中有多个实例 获取 bean 时 否 如果是在WebApplicationContext环境下还会有另外两个作用域（但不常用）： 取值 含义 创建对象的时机 默认值 request 请求范围内有效的实例 每次请求 否 session 会话范围内有效的实例 每次会话 否 作用域配置 123456789101112&lt;!--bean的作用域 准备两个引用关系的组件类即可！！--&gt;&lt;!-- scope属性：取值singleton（默认值），bean在IOC容器中只有一个实例，IOC容器初始化时创建对象 --&gt;&lt;!-- scope属性：取值prototype，bean在IOC容器中可以有多个实例，getBean()时创建对象 --&gt;&lt;bean id=&quot;happyMachine8&quot; scope=&quot;prototype&quot; class=&quot;com.wzh.ioc.HappyMachine&quot;&gt; &lt;property name=&quot;machineName&quot; value=&quot;happyMachine&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;happyComponent8&quot; scope=&quot;singleton&quot; class=&quot;com.wzh.ioc.HappyComponent&quot;&gt; &lt;property name=&quot;componentName&quot; value=&quot;happyComponent&quot;/&gt;&lt;/bean&gt; 高级特性：FactoryBean特性和使用 FactoryBean简介 FactoryBean 接口是Spring IoC容器实例化逻辑的可插拔性点。 用于配置复杂的Bean对象，可以将创建过程存储在FactoryBean 的getObject方法！ FactoryBean&lt;T&gt; 接口提供三种方法： T getObject(): 返回此工厂创建的对象的实例。该返回值会被存储到IoC容器！ boolean isSingleton(): 如果此 FactoryBean 返回单例，则返回 true ，否则返回 false 。此方法的默认实现返回 true （注意，lombok插件使用，可能影响效果）。 Class&lt;?&gt; getObjectType(): 返回 getObject() 方法返回的对象类型，如果事先不知道类型，则返回 null 。 FactoryBean使用场景 代理类的创建 第三方框架整合 复杂对象实例化等 Factorybean应用 准备FactoryBean实现类1234567891011121314151617181920212223242526272829303132// 实现FactoryBean接口时需要指定泛型// 泛型类型就是当前工厂要生产的对象的类型public class HappyFactoryBean implements FactoryBean&lt;HappyMachine&gt; &#123; private String machineName; public String getMachineName() &#123; return machineName; &#125; public void setMachineName(String machineName) &#123; this.machineName = machineName; &#125; @Override public HappyMachine getObject() throws Exception &#123; // 方法内部模拟创建、设置一个对象的复杂过程 HappyMachine happyMachine = new HappyMachine(); happyMachine.setMachineName(this.machineName); return happyMachine; &#125; @Override public Class&lt;?&gt; getObjectType() &#123; // 返回要生产的对象的类型 return HappyMachine.class; &#125;&#125; 配置FactoryBean实现类123456&lt;!-- FactoryBean机制 --&gt;&lt;!-- 这个bean标签中class属性指定的是HappyFactoryBean，但是将来从这里获取的bean是HappyMachine对象 --&gt;&lt;bean id=&quot;happyMachine7&quot; class=&quot;com.wzh.ioc.HappyFactoryBean&quot;&gt; &lt;!-- property标签仍然可以用来通过setXxx()方法给属性赋值 --&gt; &lt;property name=&quot;machineName&quot; value=&quot;iceCreamMachine&quot;/&gt;&lt;/bean&gt; 测试读取FactoryBean和FactoryBean.getObject对象12345678910111213@Testpublic void testExperiment07() &#123; ApplicationContext iocContainer = new ClassPathXmlApplicationContext(&quot;spring-bean-07.xml&quot;); //注意: 直接根据声明FactoryBean的id,获取的是getObject方法返回的对象 HappyMachine happyMachine = iocContainer.getBean(&quot;happyMachine7&quot;,HappyMachine.class); System.out.println(&quot;happyMachine = &quot; + happyMachine); //如果想要获取FactoryBean对象, 直接在id前添加&amp;符号即可! &amp;happyMachine7 这是一种固定的约束 Object bean = iocContainer.getBean(&quot;&amp;happyMachine7&quot;); System.out.println(&quot;bean = &quot; + bean);&#125; FactoryBean和BeanFactory区别 **FactoryBean **是 Spring 中一种特殊的 bean，可以在 getObject() 工厂方法自定义的逻辑创建Bean！是一种能够生产其他 Bean 的 Bean。FactoryBean 在容器启动时被创建，而在实际使用时则是通过调用 getObject() 方法来得到其所生产的 Bean。因此，FactoryBean 可以自定义任何所需的初始化逻辑，生产出一些定制化的 bean。 一般情况下，整合第三方框架，都是通过定义FactoryBean实现！！！ BeanFactory 是 Spring 框架的基础，其作为一个顶级接口定义了容器的基本行为，例如管理 bean 的生命周期、配置文件的加载和解析、bean 的装配和依赖注入等。BeanFactory 接口提供了访问 bean 的方式，例如 getBean() 方法获取指定的 bean 实例。它可以从不同的来源（例如 Mysql 数据库、XML 文件、Java 配置类等）获取 bean 定义，并将其转换为 bean 实例。同时，BeanFactory 还包含很多子类（例如，ApplicationContext 接口）提供了额外的强大功能。 总的来说，FactoryBean 和 BeanFactory 的区别主要在于前者是用于创建 bean 的接口，它提供了更加灵活的初始化定制功能，而后者是用于管理 bean 的框架基础接口，提供了基本的容器功能和 bean 生命周期管理。 基于XML方式整合三层架构组件 123456789101112131415161718192021222324252627282930313233343536373839 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 导入外部属性文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;wzh.url&#125;&quot;/&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;wzh.driver&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;wzh.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;wzh.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置 JdbcTemplate --&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;!-- 装配数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot;/&gt; &lt;/bean&gt; &lt;!-- dao 配置 di JdbcTemplate --&gt; &lt;bean id=&quot;studentDao&quot; class=&quot;com.wzh.dao.impl.StudentDaoImpl&quot;&gt; &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot; /&gt; &lt;/bean&gt; &lt;!-- service 配置 di dao --&gt; &lt;bean id=&quot;studentService&quot; class=&quot;com.wzh.service.impl.StudentServiceImpl&quot;&gt; &lt;property name=&quot;studentDao&quot; ref=&quot;studentDao&quot; /&gt; &lt;/bean&gt; &lt;!-- controller 配置 di service --&gt; &lt;bean id=&quot;studentController&quot; class=&quot;com.wzh.controller.StudentController&quot;&gt; &lt;property name=&quot;studentService&quot; ref=&quot;studentService&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; XMLIoC方式问题总结1. 注入的属性必须添加setter方法、代码结构乱！ 2. 配置文件和Java代码分离、编写不是很方便！ 3. XML配置文件解析效率低 基于注解方式管理BeanBean注解标记和扫描（IoC） 组件添加标记注解 Spring 提供了以下多个注解，这些注解可以直接标注在 Java 类上，将它们定义成 Spring Bean。 注解 说明 @Component 该注解用于描述 Spring 中的 Bean，它是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如 Service 层、Dao 层等。 使用时只需将该注解标注在相应类上即可。 @Repository 该注解用于将数据访问层（Dao 层）的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 @Service 该注解通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 @Controller 该注解通常作用在控制层（如SpringMVC 的 Controller），用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 通过查看源码我们得知，@Controller、@Service、@Repository这三个注解只是在@Component注解的基础上起了三个新的名字。 对于Spring使用IOC容器管理这些组件来说没有区别，也就是语法层面没有区别。所以@Controller、@Service、@Repository这三个注解只是给开发人员看的，让我们能够便于分辨组件的作用。 注意：虽然它们本质上一样，但是为了代码的可读性、程序结构严谨！我们肯定不能随便胡乱标记。 123456789/** * projectName: com.wzh.components * * description: 普通的组件 */@Componentpublic class CommonComponent &#123;&#125; 配置文件确定扫描范围 情况1：基本扫描配置 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 配置自动扫描的包 --&gt; &lt;!-- 1.包要精准,提高性能! 2.会扫描指定的包和子包内容 3.多个包可以使用,分割 例如: com.wzh.controller,com.wzh.service等 --&gt; &lt;context:component-scan base-package=&quot;com.wzh.components&quot;/&gt; &lt;/beans&gt; 情况2：指定排除组件 12345678&lt;!-- 指定不扫描的组件 --&gt;&lt;context:component-scan base-package=&quot;com.wzh.components&quot;&gt; &lt;!-- context:exclude-filter标签：指定排除规则 --&gt; &lt;!-- type属性：指定根据什么来进行排除，annotation取值表示根据注解来排除 --&gt; &lt;!-- expression属性：指定排除规则的表达式，对于注解来说指定全类名即可 --&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt; 情况3：指定扫描组件 12345678&lt;!-- 仅扫描指定的组件 --&gt;&lt;!-- 仅扫描 = 关闭默认规则 + 追加规则 --&gt;&lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则 --&gt;&lt;context:component-scan base-package=&quot;com.wzh.ioc.components&quot; use-default-filters=&quot;false&quot;&gt; &lt;!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 --&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt; 组件BeanName问题 在我们使用 XML 方式管理 bean 的时候，每个 bean 都有一个唯一标识——id 属性的值，便于在其他地方引用。现在使用注解后，每个组件仍然应该有一个唯一标识。 默认情况： 类名首字母小写就是 bean 的 id。例如：SoldierController 类对应的 bean 的 id 就是 soldierController。 使用value属性指定： 123@Controller(value = &quot;tianDog&quot;)public class SoldierController &#123;&#125; 当注解中只设置一个属性时，value属性的属性名可以省略： 123@Service(&quot;smallDog&quot;)public class SoldierService &#123;&#125; 总结 注解方式IoC只是标记哪些类要被Spring管理 最终，我们还需要XML方式或者后面讲解Java配置类方式指定注解生效的包 现阶段配置方式为 注解 （标记）+ XML（扫描） 组件（Bean）作用域和周期方法注解 组件周期方法配置 周期方法概念 我们可以在组件类中定义方法，然后当IoC容器实例化和销毁组件对象的时候进行调用！这两个方法我们成为生命周期方法！ 类似于Servlet的init&#x2F;destroy方法,我们可以在周期方法完成初始化和释放资源等工作。 周期方法声明 12345678910111213141516public class BeanOne &#123; //周期方法要求： 方法命名随意，但是要求方法必须是 public void 无形参列表 @PostConstruct //注解制指定初始化方法 public void init() &#123; // 初始化逻辑 &#125;&#125;public class BeanTwo &#123; @PreDestroy //注解指定销毁方法 public void cleanup() &#123; // 释放资源逻辑 &#125;&#125; 组件作用域配置 12345678910@Scope(scopeName = ConfigurableBeanFactory.SCOPE_SINGLETON) //单例,默认值@Scope(scopeName = ConfigurableBeanFactory.SCOPE_PROTOTYPE) //多例 二选一public class BeanOne &#123; //周期方法要求： 方法命名随意，但是要求方法必须是 public void 无形参列表 @PostConstruct //注解制指定初始化方法 public void init() &#123; // 初始化逻辑 &#125;&#125; Bean属性赋值：引用类型自动装配 (DI) 设定场景 SoldierController 需要 SoldierService SoldierService 需要 SoldierDao 同时在各个组件中声明要调用的方法。 SoldierController中声明方法 自动装配实现 前提 参与自动装配的组件（需要装配、被装配）全部都必须在IoC容器中。 注意：不区分IoC的方式！XML和注解都可以！ @Autowired注解 在成员变量上直接标记@Autowired注解即可，不需要提供setXxx()方法。以后我们在项目中的正式用法就是这样。 给Controller装配Service @Autowired注解细节 标记位置 成员变量 这是最主要的使用方式！ 与xml进行bean ref引用不同，他不需要有set方法！ 12345678910@Service(&quot;smallDog&quot;)public class SoldierService &#123; @Autowired private SoldierDao soldierDao; public void getMessage() &#123; soldierDao.getMessage(); &#125;&#125; 2. 构造器 3. setXxx()方法 2. 工作流程 - 首先根据所需要的组件类型到 IOC 容器中查找 - 能够找到唯一的 bean：直接执行装配 - 如果完全找不到匹配这个类型的 bean：装配失败 - 和所需类型匹配的 bean 不止一个 - 没有 @Qualifier 注解：根据 @Autowired 标记位置成员变量的变量名作为 bean 的 id 进行匹配 - 能够找到：执行装配 - 找不到：装配失败 - 使用 @Qualifier 注解：根据 @Qualifier 注解中指定的名称作为 bean 的id进行匹配 - 能够找到：执行装配 - 找不到：装配失败 1234567@Controller(value = &quot;tianDog&quot;)public class SoldierController &#123; @Autowired @Qualifier(value = &quot;maomiService222&quot;) // 根据面向接口编程思想，使用接口类型引入Service组件 private ISoldierService soldierService; 佛系装配 给 @Autowired 注解设置 required &#x3D; false 属性表示：能装就装，装不上就不装。但是实际开发时，基本上所有需要装配组件的地方都是必须装配的，用不上这个属性 123456@Controller(value = &quot;tianDog&quot;)public class SoldierController &#123; // 给@Autowired注解设置required = false属性表示：能装就装，装不上就不装 @Autowired(required = false) private ISoldierService soldierService; 扩展JSR-250注解@Resource 理解JSR系列注解 JSR（Java Specification Requests）是Java平台标准化进程中的一种技术规范，而JSR注解是其中一部分重要的内容。按照JSR的分类以及注解语义的不同，可以将JSR注解分为不同的系列，主要有以下几个系列： JSR-175: 这个JSR是Java SE 5引入的，是Java注解最早的规范化版本，Java SE 5后的版本中都包含该JSR中定义的注解。主要包括以下几种标准注解： @Deprecated: 标识一个程序元素（如类、方法或字段）已过时，并且在将来的版本中可能会被删除。 @Override: 标识一个方法重写了父类中的方法。 @SuppressWarnings: 抑制编译时产生的警告消息。 @SafeVarargs: 标识一个有安全性警告的可变参数方法。 @FunctionalInterface: 标识一个接口只有一个抽象方法，可以作为lambda表达式的目标。 JSR-250: 这个JSR主要用于在Java EE 5中定义一些支持注解。该JSR主要定义了一些用于进行对象管理的注解，包括： @Resource: 标识一个需要注入的资源，是实现Java EE组件之间依赖关系的一种方式。 @PostConstruct: 标识一个方法作为初始化方法。 @PreDestroy: 标识一个方法作为销毁方法。 @Resource.AuthenticationType: 标识注入的资源的身份验证类型。 @Resource.AuthenticationType: 标识注入的资源的默认名称。 JSR-269: 这个JSR主要是Java SE 6中引入的一种支持编译时元数据处理的框架，即使用注解来处理Java源文件。该JSR定义了一些可以用注解标记的注解处理器，用于生成一些元数据，常用的注解有： @SupportedAnnotationTypes: 标识注解处理器所处理的注解类型。 @SupportedSourceVersion: 标识注解处理器支持的Java源码版本。 JSR-330: 该JSR主要为Java应用程序定义了一个依赖注入的标准，即Java依赖注入标准（javax.inject）。在此规范中定义了多种注解，包括： @Named: 标识一个被依赖注入的组件的名称。 @Inject: 标识一个需要被注入的依赖组件。 @Singleton: 标识一个组件的生命周期只有一个唯一的实例。 JSR-250: 这个JSR主要是Java EE 5中定义一些支持注解。该JSR包含了一些支持注解，可以用于对Java EE组件进行管理，包括： @RolesAllowed: 标识授权角色 @PermitAll: 标识一个活动无需进行身份验证。 @DenyAll: 标识不提供针对该方法的访问控制。 @DeclareRoles: 声明安全角色。 但是你要理解JSR是Java提供的技术规范，也就是说，他只是规定了注解和注解的含义，JSR并不是直接提供特定的实现，而是提供标准和指导方针，由第三方框架（Spring）和库来实现和提供对应的功能。 JSR-250 @Resource注解 @Resource注解也可以完成属性注入。那它和@Autowired注解有什么区别？ @Resource注解是JDK扩展包中的，也就是说属于JDK的一部分。所以该注解是标准注解，更加具有通用性。(JSR-250标准中制定的注解类型。JSR是Java规范提案。) @Autowired注解是Spring框架自己的。 @Resource注解默认根据Bean名称装配，未指定name时，使用属性名作为name。通过name找不到的话会自动启动通过类型装配。 @Autowired注解默认根据类型装配，如果想根据名称装配，需要配合@Qualifier注解一起用。 @Resource注解用在属性上、setter方法上。 @Autowired注解用在属性上、setter方法上、构造方法上、构造方法参数上。 @Resource注解属于JDK扩展包，所以不在JDK当中，需要额外引入以下依赖：【高于JDK11或低于JDK8需要引入以下依赖】 12345&lt;dependency&gt; &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt; &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt; - @Resource使用 123456789101112131415161718@Controllerpublic class XxxController &#123; /** * 1. 如果没有指定name,先根据属性名查找IoC中组件xxxService * 2. 如果没有指定name,并且属性名没有对应的组件,会根据属性类型查找 * 3. 可以指定name名称查找! @Resource(name=&#x27;test&#x27;) == @Autowired + @Qualifier(value=&#x27;test&#x27;) */ @Resource private XxxService xxxService; //@Resource(name = &quot;指定beanName&quot;) //private XxxService xxxService; public void show()&#123; System.out.println(&quot;XxxController.show&quot;); xxxService.show(); &#125;&#125; Bean属性赋值：基本类型属性赋值 (DI) @Value 通常用于注入外部化属性 声明外部配置 application.properties 1catalog.name=MovieCatalog xml引入外部配置 12&lt;!-- 引入外部配置文件--&gt;&lt;context:property-placeholder location=&quot;application.properties&quot; /&gt; @Value注解读取配置 12345678910111213141516171819@Componentpublic class CommonComponent &#123; /** * 情况1: $&#123;key&#125; 取外部配置key对应的值! * 情况2: $&#123;key:defaultValue&#125; 没有key,可以给与默认值 */ @Value(&quot;$&#123;catalog:hahaha&#125;&quot;) private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 基于配置类方式管理 Bean完全注解开发理解 Spring 完全注解配置（Fully Annotation-based Configuration）是指通过 Java配置类 代码来配置 Spring 应用程序，使用注解来替代原本在 XML 配置文件中的配置。相对于 XML 配置，完全注解配置具有更强的类型安全性和更好的可读性。 两种方式思维转化： 配置类和扫描注解123456789//标注当前类是配置类，替代application.xml @Configuration//使用注解读取外部配置，替代 &lt;context:property-placeholder标签@PropertySource(&quot;classpath:application.properties&quot;)//使用@ComponentScan注解,可以配置扫描包,替代&lt;context:component-scan标签@ComponentScan(value = &#123;&quot;com.wzh.components&quot;&#125;)public class MyConfiguration &#123; &#125; 测试创建IoC容器 123// AnnotationConfigApplicationContext 根据配置类创建 IOC 容器对象ApplicationContext iocContainerAnnotation = new AnnotationConfigApplicationContext(MyConfiguration.class); 可以使用 no-arg 构造函数实例化 `AnnotationConfigApplicationContext` ，然后使用 `register()` 方法对其进行配置。此方法在以编程方式生成 `AnnotationConfigApplicationContext` 时特别有用。以下示例演示如何执行此操作： 12345678// AnnotationConfigApplicationContext-IOC容器对象ApplicationContext iocContainerAnnotation = new AnnotationConfigApplicationContext();//外部设置配置类iocContainerAnnotation.register(MyConfiguration.class);//刷新后方可生效！！iocContainerAnnotation.refresh(); 总结： @Configuration指定一个类为配置类，可以添加配置注解，替代配置xml文件 @ComponentScan(basePackages = &#123;&quot;包&quot;,&quot;包&quot;&#125;) 替代&lt;context:component-scan标签实现注解扫描 @PropertySource(&quot;classpath:配置文件地址&quot;) 替代 &lt;context:property-placeholder标签 配合IoC/DI注解，可以进行完整注解开发！ @Bean定义组件 场景需求：将Druid连接池对象存储到IoC容器 需求分析：第三方jar包的类，添加到ioc容器，无法使用@Component等相关注解！因为源码jar包内容为只读模式！ xml方式实现： 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 引入外部属性文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!-- 实验六 [重要]给bean的属性赋值：引入外部属性文件 --&gt; &lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.user&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; **配置类方式实现**： `@Bean` 注释用于指示方法实例化、配置和初始化要由 Spring IoC 容器管理的新对象。对于那些熟悉 Spring 的 `&lt;beans/&gt;` XML 配置的人来说， `@Bean` 注释与 `&lt;bean/&gt;` 元素起着相同的作用。 12345678910111213141516171819202122232425//标注当前类是配置类，替代application.xml @Configuration//引入jdbc.properties文件@PropertySource(&#123;&quot;classpath:application.properties&quot;,&quot;classpath:jdbc.properties&quot;&#125;)@ComponentScan(basePackages = &#123;&quot;com.wzh.components&quot;&#125;)public class MyConfiguration &#123; //如果第三方类进行IoC管理,无法直接使用@Component相关注解 //解决方案: xml方式可以使用&lt;bean标签 //解决方案: 配置类方式,可以使用方法返回值+@Bean注解 @Bean public DataSource createDataSource(@Value(&quot;$&#123;jdbc.user&#125;&quot;) String username, @Value(&quot;$&#123;jdbc.password&#125;&quot;)String password, @Value(&quot;$&#123;jdbc.url&#125;&quot;)String url, @Value(&quot;$&#123;jdbc.driver&#125;&quot;)String driverClassName)&#123; //使用Java代码实例化 DruidDataSource dataSource = new DruidDataSource(); dataSource.setUsername(username); dataSource.setPassword(password); dataSource.setUrl(url); dataSource.setDriverClassName(driverClassName); //返回结果即可 return dataSource; &#125;&#125; 高级特性：@Bean注解细节 @Bean生成BeanName问题 @Bean注解源码： 123456789101112131415161718public @interface Bean &#123; //前两个注解可以指定Bean的标识 @AliasFor(&quot;name&quot;) String[] value() default &#123;&#125;; @AliasFor(&quot;value&quot;) String[] name() default &#123;&#125;; //autowireCandidate 属性来指示该 Bean 是否候选用于自动装配。 //autowireCandidate 属性默认值为 true，表示该 Bean 是一个默认的装配目标， //可被候选用于自动装配。如果将 autowireCandidate 属性设置为 false，则说明该 Bean 不是默认的装配目标，不会被候选用于自动装配。 boolean autowireCandidate() default true; //指定初始化方法 String initMethod() default &quot;&quot;; //指定销毁方法 String destroyMethod() default &quot;(inferred)&quot;;&#125; 指定@Bean的名称： 12345678@Configurationpublic class AppConfig &#123; @Bean(&quot;myThing&quot;) //指定名称 public Thing thing() &#123; return new Thing(); &#125;&#125; `@Bean` 注释注释方法。使用此方法在指定为方法返回值的类型的 `ApplicationContext` 中注册 Bean 定义。缺省情况下，Bean 名称与方法名称相同。下面的示例演示 `@Bean` 方法声明： 12345678@Configurationpublic class AppConfig &#123; @Bean public TransferServiceImpl transferService() &#123; return new TransferServiceImpl(); &#125;&#125; 前面的配置完全等同于下面的Spring XML： 123&lt;beans&gt; &lt;bean id=&quot;transferService&quot; class=&quot;com.acme.TransferServiceImpl&quot;/&gt;&lt;/beans&gt; @Bean 初始化和销毁方法指定 @Bean 注解支持指定任意初始化和销毁回调方法，非常类似于 Spring XML 在 bean 元素上的 init-method 和 destroy-method 属性，如以下示例所示： 123456789101112131415161718192021222324252627public class BeanOne &#123; public void init() &#123; // initialization logic &#125;&#125;public class BeanTwo &#123; public void cleanup() &#123; // destruction logic &#125;&#125;@Configurationpublic class AppConfig &#123; @Bean(initMethod = &quot;init&quot;) public BeanOne beanOne() &#123; return new BeanOne(); &#125; @Bean(destroyMethod = &quot;cleanup&quot;) public BeanTwo beanTwo() &#123; return new BeanTwo(); &#125;&#125; @Bean Scope作用域 可以指定使用 @Bean 注释定义的 bean 应具有特定范围。您可以使用在 Bean 作用域部分中指定的任何标准作用域。 默认作用域为 singleton ，但您可以使用 @Scope 注释覆盖此范围，如以下示例所示： 123456789@Configurationpublic class MyConfiguration &#123; @Bean @Scope(&quot;prototype&quot;) public Encryptor encryptor() &#123; // ... &#125;&#125; @Bean方法之间依赖 准备组件 123456789101112public class HappyMachine &#123; private String machineName; public String getMachineName() &#123; return machineName; &#125; public void setMachineName(String machineName) &#123; this.machineName = machineName; &#125;&#125; 1234567891011121314151617public class HappyComponent &#123; //引用新组件 private HappyMachine happyMachine; public HappyMachine getHappyMachine() &#123; return happyMachine; &#125; public void setHappyMachine(HappyMachine happyMachine) &#123; this.happyMachine = happyMachine; &#125; public void doWork() &#123; System.out.println(&quot;HappyComponent.doWork&quot;); &#125;&#125; Java配置类实现： 方案1： 直接调用方法返回 Bean 实例：在一个 @Bean 方法中直接调用其他 @Bean 方法来获取 Bean 实例，虽然是方法调用，也是通过IoC容器获取对应的Bean，例如： 1234567891011121314151617@Configurationpublic class JavaConfig &#123; @Bean public HappyMachine happyMachine()&#123; return new HappyMachine(); &#125; @Bean public HappyComponent happyComponent()&#123; HappyComponent happyComponent = new HappyComponent(); //直接调用方法即可! happyComponent.setHappyMachine(happyMachine()); return happyComponent; &#125;&#125; 方案2： 参数引用法：通过方法参数传递 Bean 实例的引用来解决 Bean 实例之间的依赖关系，例如： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.wzh.config;import com.wzh.ioc.HappyComponent;import com.wzh.ioc.HappyMachine;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * projectName: com.wzh.config * description: 配置HappyComponent和HappyMachine关系 */@Configurationpublic class JavaConfig &#123; @Bean public HappyMachine happyMachine()&#123; return new HappyMachine(); &#125; /** * 可以直接在形参列表接收IoC容器中的Bean! * 情况1: 直接指定类型即可 * 情况2: 如果有多个bean,(HappyMachine 名称 ) 形参名称等于要指定的bean名称! * 例如: * @Bean * public Foo foo1()&#123; * return new Foo(); * &#125; * @Bean * public Foo foo2()&#123; * return new Foo() * &#125; * @Bean * public Component component(Foo foo1 / foo2 通过此处指定引入的bean) */ @Bean public HappyComponent happyComponent(HappyMachine happyMachine)&#123; HappyComponent happyComponent = new HappyComponent(); //赋值 happyComponent.setHappyMachine(happyMachine); return happyComponent; &#125;&#125; 高级特性：@Import扩展 @Import 注释允许从另一个配置类加载 @Bean 定义，如以下示例所示： 123456789101112131415161718@Configurationpublic class ConfigA &#123; @Bean public A a() &#123; return new A(); &#125;&#125;@Configuration@Import(ConfigA.class)public class ConfigB &#123; @Bean public B b() &#123; return new B(); &#125;&#125; 现在，在实例化上下文时不需要同时指定 ConfigA.class 和 ConfigB.class ，只需显式提供 ConfigB ，如以下示例所示： 1234567public static void main(String[] args) &#123; ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class); // now both beans A and B will be available... A a = ctx.getBean(A.class); B b = ctx.getBean(B.class);&#125; 此方法简化了容器实例化，因为只需要处理一个类，而不是要求您在构造期间记住可能大量的 @Configuration 类。 Spring AOP面向切面编程场景设定和问题复现 声明接口 1234567891011121314/** * + - * / 运算的标准接口! */public interface Calculator &#123; int add(int i, int j); int sub(int i, int j); int mul(int i, int j); int div(int i, int j); &#125; 接口实现 12345678910111213141516171819202122232425262728293031323334353637383940package com.wzh.proxy;/** * 实现计算接口,单纯添加 + - * / 实现! 掺杂其他功能! */public class CalculatorPureImpl implements Calculator &#123; @Override public int add(int i, int j) &#123; int result = i + j; return result; &#125; @Override public int sub(int i, int j) &#123; int result = i - j; return result; &#125; @Override public int mul(int i, int j) &#123; int result = i * j; return result; &#125; @Override public int div(int i, int j) &#123; int result = i / j; return result; &#125;&#125; 声明带日志接口实现 新需求： 需要在每个方法中，添加控制台输出，输出参数和输出计算后的返回值！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.wzh.proxy;/** * 在每个方法中,输出传入的参数和计算后的返回结果! */public class CalculatorLogImpl implements Calculator &#123; @Override public int add(int i, int j) &#123; System.out.println(&quot;参数是：&quot; + i + &quot;,&quot; + j); int result = i + j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int sub(int i, int j) &#123; System.out.println(&quot;参数是：&quot; + i + &quot;,&quot; + j); int result = i - j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int mul(int i, int j) &#123; System.out.println(&quot;参数是：&quot; + i + &quot;,&quot; + j); int result = i * j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int div(int i, int j) &#123; System.out.println(&quot;参数是：&quot; + i + &quot;,&quot; + j); int result = i / j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125;&#125; 代码问题分析 代码缺陷 对核心业务功能有干扰，导致程序员在开发核心业务功能时分散了精力 附加功能代码重复，分散在各个业务功能方法中！冗余，且不方便统一维护！ 解决思路 核心就是：解耦。我们需要把附加功能从业务功能代码中抽取出来。 将重复的代码统一提取，并且[[动态插入]]到每个业务方法！ 技术困难 解决问题的困难：提取重复附加功能代码到一个类中，可以实现 但是如何将代码插入到各个方法中，我们不会，我们需要引用新技术！！！ 解决技术代理模式 代理模式 二十三种设计模式中的一种，属于结构型模式。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类间接调用。让不属于目标方法核心逻辑的代码从目标方法中剥离出来——解耦。调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰，同时让附加功能能够集中在一起也有利于统一维护。 相关术语： 代理：将非核心逻辑剥离出来以后，封装这些非核心逻辑的类、对象、方法。(中介) 动词：指做代理这个动作，或这项工作 名词：扮演代理这个角色的类、对象、方法 目标：被代理“套用”了核心逻辑代码的类、对象、方法。(房东) 代理在开发中实现的方式具体有两种：静态代理，[动态代理技术] 静态代理 主动创建代理类： 1234567891011121314151617181920212223public class CalculatorStaticProxy implements Calculator &#123; // 将被代理的目标对象声明为成员变量 private Calculator target; public CalculatorStaticProxy(Calculator target) &#123; this.target = target; &#125; @Override public int add(int i, int j) &#123; // 附加功能由代理类中的代理方法来实现 System.out.println(&quot;参数是：&quot; + i + &quot;,&quot; + j); // 通过目标对象来实现核心业务逻辑 int addResult = target.add(i, j); System.out.println(&quot;方法内部 result = &quot; + result); return addResult; &#125; …… 静态代理确实实现了解耦，但是由于代码都写死了，完全不具备任何的灵活性。就拿日志功能来说，将来其他地方也需要附加日志，那还得再声明更多个静态代理类，那就产生了大量重复的代码，日志功能还是分散的，没有统一管理。 提出进一步的需求：将日志功能集中到一个代理类中，将来有任何日志需求，都通过这一个代理类来实现。这就需要使用动态代理技术了。 动态代理 动态代理技术分类 JDK动态代理：JDK原生的实现方式，需要被代理的目标类必须实现接口！他会根据目标类的接口动态生成一个代理对象！代理对象和目标对象有相同的接口！（拜把子） cglib：通过继承被代理的目标类实现代理，所以不需要目标类实现接口！（认干爹） JDK动态代理技术实现（了解） 代理工程：基于jdk代理技术，生成代理对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ProxyFactory &#123; private Object target; public ProxyFactory(Object target) &#123; this.target = target; &#125; public Object getProxy()&#123; /** * newProxyInstance()：创建一个代理实例 * 其中有三个参数： * 1、classLoader：加载动态生成的代理类的类加载器 * 2、interfaces：目标对象实现的所有接口的class对象所组成的数组 * 3、invocationHandler：设置代理对象实现目标对象方法的过程，即代理类中如何重写接口中的抽象方法 */ ClassLoader classLoader = target.getClass().getClassLoader(); Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces(); InvocationHandler invocationHandler = new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; /** * proxy：代理对象 * method：代理对象需要实现的方法，即其中需要重写的方法 * args：method所对应方法的参数 */ Object result = null; try &#123; System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，参数：&quot;+ Arrays.toString(args)); result = method.invoke(target, args); System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，结果：&quot;+ result); &#125; catch (Exception e) &#123; e.printStackTrace(); System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，异常：&quot;+e.getMessage()); &#125; finally &#123; System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，方法执行完毕&quot;); &#125; return result; &#125; &#125;; return Proxy.newProxyInstance(classLoader, interfaces, invocationHandler); &#125;&#125; 测试代码： 1234567@Testpublic void testDynamicProxy()&#123; ProxyFactory factory = new ProxyFactory(new CalculatorLogImpl()); Calculator proxy = (Calculator) factory.getProxy(); proxy.div(1,0); //proxy.div(1,1);&#125; 代理总结 代理方式可以解决附加功能代码干扰核心代码和不方便统一维护的问题！ 他主要是将附加功能代码提取到代理中执行，不干扰目标核心代码！ 但是我们也发现，无论使用静态代理和动态代理(jdk,cglib)，程序员的工作都比较繁琐！ 需要自己编写代理工厂等！ 但是，我们在实际开发中，不需要编写代理代码，我们可以使用[Spring AOP]框架， 他会简化动态代理的实现！！！ 面向切面编程思维（AOP） 面向切面编程思想AOP AOP：Aspect Oriented Programming面向切面编程 AOP可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。 AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。 使用AOP，可以在不修改原来代码的基础上添加新功能。 AOP思想主要的应用场景 AOP（面向切面编程）是一种编程范式，它通过将通用的横切关注点（如日志、事务、权限控制等）与业务逻辑分离，使得代码更加清晰、简洁、易于维护。AOP可以应用于各种场景，以下是一些常见的AOP应用场景： 日志记录：在系统中记录日志是非常重要的，可以使用AOP来实现日志记录的功能，可以在方法执行前、执行后或异常抛出时记录日志。 事务处理：在数据库操作中使用事务可以保证数据的一致性，可以使用AOP来实现事务处理的功能，可以在方法开始前开启事务，在方法执行完毕后提交或回滚事务。 安全控制：在系统中包含某些需要安全控制的操作，如登录、修改密码、授权等，可以使用AOP来实现安全控制的功能。可以在方法执行前进行权限判断，如果用户没有权限，则抛出异常或转向到错误页面，以防止未经授权的访问。 性能监控：在系统运行过程中，有时需要对某些方法的性能进行监控，以找到系统的瓶颈并进行优化。可以使用AOP来实现性能监控的功能，可以在方法执行前记录时间戳，在方法执行完毕后计算方法执行时间并输出到日志中。 异常处理：系统中可能出现各种异常情况，如空指针异常、数据库连接异常等，可以使用AOP来实现异常处理的功能，在方法执行过程中，如果出现异常，则进行异常处理（如记录日志、发送邮件等）。 缓存控制：在系统中有些数据可以缓存起来以提高访问速度，可以使用AOP来实现缓存控制的功能，可以在方法执行前查询缓存中是否有数据，如果有则返回，否则执行方法并将方法返回值存入缓存中。 动态代理：AOP的实现方式之一是通过动态代理，可以代理某个类的所有方法，用于实现各种功能。 综上所述，AOP可以应用于各种场景，它的作用是将通用的横切关注点与业务逻辑分离，使得代码更加清晰、简洁、易于维护。 AOP术语名词介绍 1-横切关注点 从每个方法中抽取出来的同一类非核心业务。在同一个项目中，我们可以使用多个横切关注点对相关方法进行多个不同方面的增强。 这个概念不是语法层面天然存在的，而是根据附加功能的逻辑上的需要：有十个附加功能，就有十个横切关注点。 AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事务、异常等。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。 2-通知(增强) 每一个横切关注点上要做的事情都需要写一个方法来实现，这样的方法就叫通知方法。 前置通知：在被代理的目标方法前执行 返回通知：在被代理的目标方法成功结束后执行（寿终正寝） 异常通知：在被代理的目标方法异常结束后执行（死于非命） 后置通知：在被代理的目标方法最终结束后执行（盖棺定论） 环绕通知：使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置 3-连接点 joinpoint 这也是一个纯逻辑概念，不是语法定义的。 指那些被拦截到的点。在 Spring 中，可以被动态代理拦截目标类的方法 4-切入点 pointcut 定位连接点的方式，或者可以理解成被选中的连接点！ 是一个表达式，比如execution(* com.spring.service.impl..(..))。符合条件的每个方法都是一个具体的连接点。 5-切面 aspect 切入点和通知的结合。是一个类。 6-目标 target 被代理的目标对象。 7-代理 proxy 向目标对象应用通知之后创建的代理对象。 8-织入 weave 指把通知应用到目标上，生成代理对象的过程。可以在编译期织入，也可以在运行期织入，Spring采用后者。 Spring AOP框架介绍和关系梳理 AOP一种区别于OOP的编程思维，用来完善和解决OOP的非核心代码冗余和不方便统一维护问题！ 代理技术（动态代理|静态代理）是实现AOP思维编程的具体技术，但是自己使用动态代理实现代码比较繁琐！ Spring AOP框架，基于AOP编程思维，封装动态代理技术，简化动态代理技术实现的框架！SpringAOP内部帮助我们实现动态代理，我们只需写少量的配置，指定生效范围即可,即可完成面向切面思维编程的实现！ Spring AOP基于注解方式实现和细节Spring AOP底层技术组成 动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求代理对象和目标对象实现同样的接口（兄弟两个拜把子模式）。 cglib：通过继承被代理的目标类（认干爹模式）实现代理，所以不需要目标类实现接口。 AspectJ：早期的AOP实现的框架，SpringAOP借用了AspectJ中的AOP注解。 初步实现 加入依赖 123456789101112&lt;!-- spring-aspects会帮我们传递过来aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt;&lt;/dependency&gt; 准备接口 1234567891011public interface Calculator &#123; int add(int i, int j); int sub(int i, int j); int mul(int i, int j); int div(int i, int j); &#125; 纯净实现类 1234567891011121314151617181920212223242526272829303132333435363738394041package com.wzh.proxy;/*** 实现计算接口,单纯添加 + - * / 实现! 掺杂其他功能!*/@Componentpublic class CalculatorPureImpl implements Calculator &#123; @Override public int add(int i, int j) &#123; int result = i + j; return result; &#125; @Override public int sub(int i, int j) &#123; int result = i - j; return result; &#125; @Override public int mul(int i, int j) &#123; int result = i * j; return result; &#125; @Override public int div(int i, int j) &#123; int result = i / j; return result; &#125;&#125; 声明切面类 12345678910111213141516171819202122232425262728293031323334package com.wzh.advice;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;// @Aspect表示这个类是一个切面类@Aspect// @Component注解保证这个切面类能够放入IOC容器@Componentpublic class LogAspect &#123; // @Before注解：声明当前方法是前置通知方法 // value属性：指定切入点表达式，由切入点表达式控制当前通知方法要作用在哪一个目标方法上 @Before(value = &quot;execution(public int com.wzh.proxy.CalculatorPureImpl.add(int,int))&quot;) public void printLogBeforeCore() &#123; System.out.println(&quot;[AOP前置通知] 方法开始了&quot;); &#125; @AfterReturning(value = &quot;execution(public int com.wzh.proxy.CalculatorPureImpl.add(int,int))&quot;) public void printLogAfterSuccess() &#123; System.out.println(&quot;[AOP返回通知] 方法成功返回了&quot;); &#125; @AfterThrowing(value = &quot;execution(public int com.wzh.proxy.CalculatorPureImpl.add(int,int))&quot;) public void printLogAfterException() &#123; System.out.println(&quot;[AOP异常通知] 方法抛异常了&quot;); &#125; @After(value = &quot;execution(public int com.wzh.proxy.CalculatorPureImpl.add(int,int))&quot;) public void printLogFinallyEnd() &#123; System.out.println(&quot;[AOP后置通知] 方法最终结束了&quot;); &#125; &#125; 开启aspectj注解支持 xml方式 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans&gt; &lt;!-- 进行包扫描--&gt; &lt;context:component-scan base-package=&quot;com.wzh&quot; /&gt; &lt;!-- 开启aspectj框架注解支持--&gt; &lt;aop:aspectj-autoproxy /&gt;&lt;/beans&gt;``` 2. 配置类方式```Java@Configuration@ComponentScan(basePackages = &quot;com.wzh&quot;)//作用等于 &lt;aop:aspectj-autoproxy /&gt; 配置类上开启 Aspectj注解支持!@EnableAspectJAutoProxypublic class MyConfig &#123;&#125; 测试效果 12345678910111213//@SpringJUnitConfig(locations = &quot;classpath:spring-aop.xml&quot;)@SpringJUnitConfig(value = &#123;MyConfig.class&#125;)public class AopTest &#123; @Autowired private Calculator calculator; @Test public void testCalculator()&#123; calculator.add(1,1); &#125;&#125; 获取通知细节信息 JointPoint接口 需要获取方法签名、传入的实参等信息时，可以在通知方法声明JoinPoint类型的形参。 要点1：JoinPoint 接口通过 getSignature() 方法获取目标方法的签名（方法声明时的完整信息） 要点2：通过目标方法签名对象获取方法名 要点3：通过 JoinPoint 对象获取外界调用目标方法时传入的实参列表组成的数组 1234567891011121314151617181920212223242526272829// @Before注解标记前置通知方法// value属性：切入点表达式，告诉Spring当前通知方法要套用到哪个目标方法上// 在前置通知方法形参位置声明一个JoinPoint类型的参数，Spring就会将这个对象传入// 根据JoinPoint对象就可以获取目标方法名称、实际参数列表@Before(value = &quot;execution(public int com.wzh.aop.api.Calculator.add(int,int))&quot;)public void printLogBeforeCore(JoinPoint joinPoint) &#123; // 1.通过JoinPoint对象获取目标方法签名对象 // 方法的签名：一个方法的全部声明信息 Signature signature = joinPoint.getSignature(); // 2.通过方法的签名对象获取目标方法的详细信息 String methodName = signature.getName(); System.out.println(&quot;methodName = &quot; + methodName); int modifiers = signature.getModifiers(); System.out.println(&quot;modifiers = &quot; + modifiers); String declaringTypeName = signature.getDeclaringTypeName(); System.out.println(&quot;declaringTypeName = &quot; + declaringTypeName); // 3.通过JoinPoint对象获取外界调用目标方法时传入的实参列表 Object[] args = joinPoint.getArgs(); // 4.由于数组直接打印看不到具体数据，所以转换为List集合 List&lt;Object&gt; argList = Arrays.asList(args); System.out.println(&quot;[AOP前置通知] &quot; + methodName + &quot;方法开始了，参数列表：&quot; + argList);&#125; 方法返回值 在返回通知中，通过**@AfterReturning**注解的returning属性获取目标方法的返回值！ 1234567891011121314// @AfterReturning注解标记返回通知方法// 在返回通知中获取目标方法返回值分两步：// 第一步：在@AfterReturning注解中通过returning属性设置一个名称// 第二步：使用returning属性设置的名称在通知方法中声明一个对应的形参@AfterReturning( value = &quot;execution(public int com.wzh.aop.api.Calculator.add(int,int))&quot;, returning = &quot;targetMethodReturnValue&quot;)public void printLogAfterCoreSuccess(JoinPoint joinPoint, Object targetMethodReturnValue) &#123; String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;[AOP返回通知] &quot;+methodName+&quot;方法成功结束了，返回值是：&quot; + targetMethodReturnValue);&#125; 异常对象捕捉 在异常通知中，通过@AfterThrowing注解的throwing属性获取目标方法抛出的异常对象 1234567891011121314// @AfterThrowing注解标记异常通知方法// 在异常通知中获取目标方法抛出的异常分两步：// 第一步：在@AfterThrowing注解中声明一个throwing属性设定形参名称// 第二步：使用throwing属性指定的名称在通知方法声明形参，Spring会将目标方法抛出的异常对象从这里传给我们@AfterThrowing( value = &quot;execution(public int com.wzh.aop.api.Calculator.add(int,int))&quot;, throwing = &quot;targetMethodException&quot;)public void printLogAfterCoreException(JoinPoint joinPoint, Throwable targetMethodException) &#123; String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;[AOP异常通知] &quot;+methodName+&quot;方法抛异常了，异常类型是：&quot; + targetMethodException.getClass().getName());&#125; 切点表达式语法 切点表达式作用 AOP切点表达式（Pointcut Expression）是一种用于指定切点的语言，它可以通过定义匹配规则，来选择需要被切入的目标对象。 切点表达式语法 切点表达式总结 语法细节 第一位：execution( ) 固定开头 第二位：方法访问修饰符 1public private 直接描述对应修饰符即可 第三位：方法返回值 12int String void 直接描述返回值类型 注意： 特殊情况 不考虑 访问修饰符和返回值 execution(* * ) 这是错误语法 execution(*) == 你只要考虑返回值 或者 不考虑访问修饰符 相当于全部不考虑了 第四位：指定包的地址 12345固定的包: com.wzh.api | service | dao单层的任意命名: com.wzh.* = com.wzh.api com.wzh.dao * = 任意一层的任意命名任意层任意命名: com.. = com.wzh.api.erdaye com.a.a.a.a.a.a.a ..任意层,任意命名 用在包上!注意: ..不能用作包开头 public int .. 错误语法 com..找到任何包下: *.. 第五位：指定类名称 12345固定名称: UserService任意类名: *部分任意: com..service.impl.*Impl任意包任意类: *..* - 第六位：指定方法名称 12语法和类名一致任意访问修饰符,任意类的任意方法: * *..*.* 第七位：方法参数 123456789第七位: 方法的参数描述 具体值: (String,int) != (int,String) 没有参数 () 模糊值: 任意参数 有 或者 没有 (..) ..任意参数的意识 部分具体和模糊: 第一个参数是字符串的方法 (String..) 最后一个参数是字符串 (..String) 字符串开头,int结尾 (String..int) 包含int类型(..int..) 重用（提取）切点表达式 重用切点表达式优点 123456789101112131415161718192021// @Before注解：声明当前方法是前置通知方法// value属性：指定切入点表达式，由切入点表达式控制当前通知方法要作用在哪一个目标方法上@Before(value = &quot;execution(public int com.wzh.proxy.CalculatorPureImpl.add(int,int))&quot;)public void printLogBeforeCore() &#123; System.out.println(&quot;[AOP前置通知] 方法开始了&quot;);&#125;@AfterReturning(value = &quot;execution(public int com.wzh.proxy.CalculatorPureImpl.add(int,int))&quot;)public void printLogAfterSuccess() &#123; System.out.println(&quot;[AOP返回通知] 方法成功返回了&quot;);&#125;@AfterThrowing(value = &quot;execution(public int com.wzh.proxy.CalculatorPureImpl.add(int,int))&quot;)public void printLogAfterException() &#123; System.out.println(&quot;[AOP异常通知] 方法抛异常了&quot;);&#125;@After(value = &quot;execution(public int com.wzh.proxy.CalculatorPureImpl.add(int,int))&quot;)public void printLogFinallyEnd() &#123; System.out.println(&quot;[AOP后置通知] 方法最终结束了&quot;);&#125; 上面案例，是我们之前编写切点表达式的方式，发现， 所有增强方法的切点表达式相同！ 出现了冗余，如果需要切换也不方便统一维护！ 我们可以将切点提取，在增强上进行引用即可！ 同一类内部引用 提取 123// 切入点表达式重用@Pointcut(&quot;execution(public int com.wzh.aop.api.Calculator.add(int,int)))&quot;)public void declarPointCut() &#123;&#125; 注意：提取切点注解使用@Pointcut(切点表达式) ， 需要添加到一个无参数无返回值方法上即可！ 引用 12@Before(value = &quot;declarPointCut()&quot;)public void printLogBeforeCoreOperation(JoinPoint joinPoint) &#123; 不同类中引用 不同类在引用切点，只需要添加类的全限定符+方法名即可！ 12@Before(value = &quot;com.wzh.spring.aop.aspect.LogAspect.declarPointCut()&quot;)public Object roundAdvice(ProceedingJoinPoint joinPoint) &#123; 切点统一管理 建议：将切点表达式统一存储到一个类中进行集中管理和维护！ 123456789101112@Componentpublic class wzhPointCut &#123; @Pointcut(value = &quot;execution(public int *..Calculator.sub(int,int))&quot;) public void wzhGlobalPointCut()&#123;&#125; @Pointcut(value = &quot;execution(public int *..Calculator.add(int,int))&quot;) public void wzhSecondPointCut()&#123;&#125; @Pointcut(value = &quot;execution(* *..*Service.*(..))&quot;) public void transactionPointCut()&#123;&#125;&#125; 环绕通知 环绕通知对应整个 try…catch…finally 结构，包括前面四种通知的所有功能。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 使用@Around注解标明环绕通知方法@Around(value = &quot;com.wzh.aop.aspect.wzhPointCut.transactionPointCut()&quot;)public Object manageTransaction( // 通过在通知方法形参位置声明ProceedingJoinPoint类型的形参， // Spring会将这个类型的对象传给我们 ProceedingJoinPoint joinPoint) &#123; // 通过ProceedingJoinPoint对象获取外界调用目标方法时传入的实参数组 Object[] args = joinPoint.getArgs(); // 通过ProceedingJoinPoint对象获取目标方法的签名对象 Signature signature = joinPoint.getSignature(); // 通过签名对象获取目标方法的方法名 String methodName = signature.getName(); // 声明变量用来存储目标方法的返回值 Object targetMethodReturnValue = null; try &#123; // 在目标方法执行前：开启事务（模拟） log.debug(&quot;[AOP 环绕通知] 开启事务，方法名：&quot; + methodName + &quot;，参数列表：&quot; + Arrays.asList(args)); // 过ProceedingJoinPoint对象调用目标方法 // 目标方法的返回值一定要返回给外界调用者 targetMethodReturnValue = joinPoint.proceed(args); // 在目标方法成功返回后：提交事务（模拟） log.debug(&quot;[AOP 环绕通知] 提交事务，方法名：&quot; + methodName + &quot;，方法返回值：&quot; + targetMethodReturnValue); &#125;catch (Throwable e)&#123; // 在目标方法抛异常后：回滚事务（模拟） log.debug(&quot;[AOP 环绕通知] 回滚事务，方法名：&quot; + methodName + &quot;，异常：&quot; + e.getClass().getName()); &#125;finally &#123; // 在目标方法最终结束后：释放数据库连接 log.debug(&quot;[AOP 环绕通知] 释放数据库连接，方法名：&quot; + methodName); &#125; return targetMethodReturnValue;&#125; 切面优先级设置 相同目标方法上同时存在多个切面时，切面的优先级控制切面的内外嵌套顺序。 优先级高的切面：外面 优先级低的切面：里面 使用 @Order 注解可以控制切面的优先级： @Order(较小的数)：优先级高 @Order(较大的数)：优先级低 实际意义 实际开发时，如果有多个切面嵌套的情况，要慎重考虑。例如：如果事务切面优先级高，那么在缓存中命中数据的情况下，事务切面的操作都浪费了。 此时应该将缓存切面的优先级提高，在事务操作之前先检查缓存中是否存在目标数据。 CGLib动态代理生效 在目标类没有实现任何接口的情况下，Spring会自动使用cglib技术实现代理。为了证明这一点，我们做下面的测试： 1234567@Servicepublic class EmployeeService &#123; public void getEmpList() &#123; System.out.print(&quot;方法内部 com.wzh.aop.imp.EmployeeService.getEmpList&quot;); &#125;&#125; 测试： 1234567@Autowiredprivate EmployeeService employeeService;@Testpublic void testNoInterfaceProxy() &#123; employeeService.getEmpList();&#125; 使用总结： a. 如果目标类有接口,选择使用jdk动态代理 b. 如果目标类没有接口,选择cglib动态代理 c. 如果有接口,接口接值 d. 如果没有接口,类进行接值 Spring AOP基于XML方式实现(了解)12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!-- 配置目标类的bean --&gt;&lt;bean id=&quot;calculatorPure&quot; class=&quot;com.wzh.aop.imp.CalculatorPureImpl&quot;/&gt; &lt;!-- 配置切面类的bean --&gt;&lt;bean id=&quot;logAspect&quot; class=&quot;com.wzh.aop.aspect.LogAspect&quot;/&gt; &lt;!-- 配置AOP --&gt;&lt;aop:config&gt; &lt;!-- 配置切入点表达式 --&gt; &lt;aop:pointcut id=&quot;logPointCut&quot; expression=&quot;execution(* *..*.*(..))&quot;/&gt; &lt;!-- aop:aspect标签：配置切面 --&gt; &lt;!-- ref属性：关联切面类的bean --&gt; &lt;aop:aspect ref=&quot;logAspect&quot;&gt; &lt;!-- aop:before标签：配置前置通知 --&gt; &lt;!-- method属性：指定前置通知的方法名 --&gt; &lt;!-- pointcut-ref属性：引用切入点表达式 --&gt; &lt;aop:before method=&quot;printLogBeforeCore&quot; pointcut-ref=&quot;logPointCut&quot;/&gt; &lt;!-- aop:after-returning标签：配置返回通知 --&gt; &lt;!-- returning属性：指定通知方法中用来接收目标方法返回值的参数名 --&gt; &lt;aop:after-returning method=&quot;printLogAfterCoreSuccess&quot; pointcut-ref=&quot;logPointCut&quot; returning=&quot;targetMethodReturnValue&quot;/&gt; &lt;!-- aop:after-throwing标签：配置异常通知 --&gt; &lt;!-- throwing属性：指定通知方法中用来接收目标方法抛出异常的异常对象的参数名 --&gt; &lt;aop:after-throwing method=&quot;printLogAfterCoreException&quot; pointcut-ref=&quot;logPointCut&quot; throwing=&quot;targetMethodException&quot;/&gt; &lt;!-- aop:after标签：配置后置通知 --&gt; &lt;aop:after method=&quot;printLogCoreFinallyEnd&quot; pointcut-ref=&quot;logPointCut&quot;/&gt; &lt;!-- aop:around标签：配置环绕通知 --&gt; &lt;!--&lt;aop:around method=&quot;……&quot; pointcut-ref=&quot;logPointCut&quot;/&gt;--&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; Spring AOP对获取Bean的影响理解 对实现了接口的类应用切面 对没实现接口的类应用切面new 如果使用AOP技术，目标类有接口，必须使用接口类型接收IoC容器中代理组件！ Spring 声明式事务声明式事务概念编程式事务 编程式事务是指手动编写程序来管理事务，即通过编写代码的方式直接控制事务的提交和回滚。在 Java 中，通常使用事务管理器(如 Spring 中的 PlatformTransactionManager)来实现编程式事务。 编程式事务的主要优点是灵活性高，可以按照自己的需求来控制事务的粒度、模式等等。但是，编写大量的事务控制代码容易出现问题，对代码的可读性和可维护性有一定影响。 123456789101112131415161718192021Connection conn = ...; try &#123; // 开启事务：关闭事务的自动提交 conn.setAutoCommit(false); // 核心操作 // 业务代码 // 提交事务 conn.commit(); &#125;catch(Exception e)&#123; // 回滚事务 conn.rollBack(); &#125;finally&#123; // 释放数据库连接 conn.close(); &#125; 编程式的实现方式存在缺陷： 细节没有被屏蔽：具体操作过程中，所有细节都需要程序员自己来完成，比较繁琐。 代码复用性不高：如果没有有效抽取出来，每次实现功能都需要自己编写代码，代码就没有得到复用。 声明式事务 声明式事务是指使用注解或 XML 配置的方式来控制事务的提交和回滚。 开发者只需要添加配置即可， 具体事务的实现由第三方框架实现，避免我们直接进行事务操作！ 使用声明式事务可以将事务的控制和业务逻辑分离开来，提高代码的可读性和可维护性。 区别： 编程式事务需要手动编写代码来管理事务 而声明式事务可以通过配置文件或注解来控制事务。 Spring事务管理器 Spring声明式事务对应依赖 spring-tx: 包含声明式事务实现的基本规范（事务管理器规范接口和事务增强等等） spring-jdbc: 包含DataSource方式事务管理器实现类DataSourceTransactionManager spring-orm: 包含其他持久层框架的事务管理器实现类例如：Hibernate&#x2F;Jpa等 Spring声明式事务对应事务管理器接口 我们现在要使用的事务管理器是org.springframework.jdbc.datasource.DataSourceTransactionManager，将来整合 JDBC方式、JdbcTemplate方式、Mybatis方式的事务实现！ DataSourceTransactionManager类中的主要方法： doBegin()：开启事务 doSuspend()：挂起事务 doResume()：恢复挂起的事务 doCommit()：提交事务 doRollback()：回滚事务 基于注解的声明式事务准备工作 准备项目,导入相关依赖 外部配置文件 jdbc.properties spring配置文件 1234567891011121314151617181920212223242526272829303132333435363738@Configuration@ComponentScan(&quot;com.atguigu&quot;)@PropertySource(&quot;classpath:jdbc.properties&quot;)public class JavaConfig &#123; @Value(&quot;$&#123;atguigu.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;atguigu.url&#125;&quot;) private String url; @Value(&quot;$&#123;atguigu.username&#125;&quot;) private String username; @Value(&quot;$&#123;atguigu.password&#125;&quot;) private String password; //druid连接池 @Bean public DataSource dataSource()&#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125; @Bean //jdbcTemplate public JdbcTemplate jdbcTemplate(DataSource dataSource)&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(); jdbcTemplate.setDataSource(dataSource); return jdbcTemplate; &#125;&#125; 准备dao&#x2F;service层 dao 1234567891011121314151617@Repositorypublic class StudentDao &#123; @Autowired private JdbcTemplate jdbcTemplate; public void updateNameById(String name,Integer id)&#123; String sql = &quot;update students set name = ? where id = ? ;&quot;; int rows = jdbcTemplate.update(sql, name, id); &#125; public void updateAgeById(Integer age,Integer id)&#123; String sql = &quot;update students set age = ? where id = ? ;&quot;; jdbcTemplate.update(sql,age,id); &#125;&#125; service 12345678910111213@Servicepublic class StudentService &#123; @Autowired private StudentDao studentDao; public void changeInfo()&#123; studentDao.updateAgeById(100,1); System.out.println(&quot;-----------&quot;); studentDao.updateNameById(&quot;test1&quot;,1); &#125;&#125; 测试环境搭建 1234567891011121314151617/** * projectName: com.atguigu.test * * description: */@SpringJUnitConfig(JavaConfig.class)public class TxTest &#123; @Autowired private StudentService studentService; @Test public void testTx()&#123; studentService.changeInfo(); &#125;&#125; 基本事务控制 配置事务管理器 数据库相关的配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * projectName: com.atguigu.config * * description: 数据库和连接池配置类 */@Configuration@ComponenScan(&quot;com.atguigu&quot;)@PropertySource(value = &quot;classpath:jdbc.properties&quot;)@EnableTransactionManagementpublic class DataSourceConfig &#123; /** * 实例化dataSource加入到ioc容器 * @param url * @param driver * @param username * @param password * @return */ @Bean public DataSource dataSource(@Value(&quot;$&#123;atguigu.url&#125;&quot;)String url, @Value(&quot;$&#123;atguigu.driver&#125;&quot;)String driver, @Value(&quot;$&#123;atguigu.username&#125;&quot;)String username, @Value(&quot;$&#123;atguigu.password&#125;&quot;)String password)&#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125; /** * 实例化JdbcTemplate对象,需要使用ioc中的DataSource * @param dataSource * @return */ @Bean public JdbcTemplate jdbcTemplate(DataSource dataSource)&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(); jdbcTemplate.setDataSource(dataSource); return jdbcTemplate; &#125; /** * 装配事务管理实现对象 * @param dataSource * @return */ @Bean public TransactionManager transactionManager(DataSource dataSource)&#123; return new DataSourceTransactionManager(dataSource); &#125;&#125; 使用声明事务注解@Transactional 12345678910111213141516171819/** * projectName: com.atguigu.service * */@Servicepublic class StudentService &#123; @Autowired private StudentDao studentDao; @Transactional public void changeInfo()&#123; studentDao.updateAgeById(100,1); System.out.println(&quot;-----------&quot;); int i = 1/0; studentDao.updateNameById(&quot;test1&quot;,1); &#125;&#125; 测试事务效果 123456789101112131415161718/** * projectName: com.atguigu.test * * description: *///@SpringJUnitConfig(locations = &quot;classpath:application.xml&quot;)@SpringJUnitConfig(classes = DataSourceConfig.class)public class TxTest &#123; @Autowired private StudentService studentService; @Test public void testTx()&#123; studentService.changeInfo(); &#125;&#125; 事务属性：只读 只读介绍 对一个查询操作来说，如果我们把它设置成只读，就能够明确告诉数据库，这个操作不涉及写操作。这样数据库就能够针对查询操作来进行优化。 设置方式 12// readOnly = true把当前事务设置为只读 默认是false!@Transactional(readOnly = true) 针对DML动作设置只读模式 会抛出下面异常： Caused by: java.sql.SQLException: Connection is read-only. Queries leading to data modification are not allowed @Transactional注解放在类上 生效原则 如果一个类中每一个方法上都使用了 @Transactional 注解，那么就可以将 @Transactional 注解提取到类上。反过来说：@Transactional 注解在类级别标记，会影响到类中的每一个方法。同时，类级别标记的 @Transactional 注解中设置的事务属性也会延续影响到方法执行时的事务属性。除非在方法上又设置了 @Transactional 注解。 对一个方法来说，离它最近的 @Transactional 注解中的事务属性设置生效。 用法举例 在类级别@Transactional注解中设置只读，这样类中所有的查询方法都不需要设置@Transactional注解了。因为对查询操作来说，其他属性通常不需要设置，所以使用公共设置即可。 然后在这个基础上，对增删改方法设置@Transactional注解 readOnly 属性为 false。 1234567891011121314151617@Service@Transactional(readOnly = true)public class EmpService &#123; // 为了便于核对数据库操作结果，不要修改同一条记录 @Transactional(readOnly = false) public void updateTwice(……) &#123; …… &#125; // readOnly = true把当前事务设置为只读 // @Transactional(readOnly = true) public String getEmpName(Integer empId) &#123; …… &#125; &#125; 事务属性：超时时间 需求 事务在执行过程中，有可能因为遇到某些问题，导致程序卡住，从而长时间占用数据库资源。而长时间占用资源，大概率是因为程序运行出现了问题（可能是Java程序或MySQL数据库或网络连接等等）。 此时这个很可能出问题的程序应该被回滚，撤销它已做的操作，事务结束，把资源让出来，让其他正常程序可以执行。 概括来说就是一句话：超时回滚，释放资源。 设置超时时间 12345678910111213141516171819202122@Servicepublic class StudentService &#123; @Autowired private StudentDao studentDao; /** * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间! */ @Transactional(readOnly = false,timeout = 3) public void changeInfo()&#123; studentDao.updateAgeById(100,1); //休眠4秒,等待方法超时! try &#123; Thread.sleep(4000); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; studentDao.updateNameById(&quot;test1&quot;,1); &#125;&#125; 测试超时效果 执行抛出事务超时异常 事务属性：事务异常 默认情况 默认只针对运行时异常回滚，编译时异常不回滚。情景模拟代码如下： 12345678910111213141516171819@Servicepublic class StudentService &#123; @Autowired private StudentDao studentDao; /** * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间! * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚! * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内! */ @Transactional(readOnly = false,timeout = 3) public void changeInfo() throws FileNotFoundException &#123; studentDao.updateAgeById(100,1); //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内! new FileInputStream(&quot;xxxx&quot;); studentDao.updateNameById(&quot;test1&quot;,1); &#125;&#125; 设置回滚异常 rollbackFor属性：指定哪些异常类才会回滚,默认是 RuntimeException and Error 异常方可回滚! 123456789101112/** * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间! * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚! * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内! */@Transactional(readOnly = false,timeout = 3,rollbackFor = Exception.class)public void changeInfo() throws FileNotFoundException &#123; studentDao.updateAgeById(100,1); //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内! new FileInputStream(&quot;xxxx&quot;); studentDao.updateNameById(&quot;test1&quot;,1);&#125; 设置不回滚的异常 在默认设置和已有设置的基础上，再指定一个异常类型，碰到它不回滚。 noRollbackFor属性：指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内! 1234567891011121314151617181920@Servicepublic class StudentService &#123; @Autowired private StudentDao studentDao; /** * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间! * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚! * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内! */ @Transactional(readOnly = false,timeout = 3,rollbackFor = Exception.class,noRollbackFor = FileNotFoundException.class) public void changeInfo() throws FileNotFoundException &#123; studentDao.updateAgeById(100,1); //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内! new FileInputStream(&quot;xxxx&quot;); studentDao.updateNameById(&quot;test1&quot;,1); &#125;&#125; 事务属性：事务隔离级别 事务隔离级别 数据库事务的隔离级别是指在多个事务并发执行时，数据库系统为了保证数据一致性所遵循的规定。常见的隔离级别包括： 读未提交（Read Uncommitted）：事务可以读取未被提交的数据，容易产生脏读、不可重复读和幻读等问题。实现简单但不太安全，一般不用。 读已提交（Read Committed）：事务只能读取已经提交的数据，可以避免脏读问题，但可能引发不可重复读和幻读。 可重复读（Repeatable Read）：在一个事务中，相同的查询将返回相同的结果集，不管其他事务对数据做了什么修改。可以避免脏读和不可重复读，但仍有幻读的问题。 串行化（Serializable）：最高的隔离级别，完全禁止了并发，只允许一个事务执行完毕之后才能执行另一个事务。可以避免以上所有问题，但效率较低，不适用于高并发场景。 不同的隔离级别适用于不同的场景，需要根据实际业务需求进行选择和调整。 事务隔离级别设置 12345678910111213141516171819202122232425@Servicepublic class StudentService &#123; @Autowired private StudentDao studentDao; /** * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间! * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚! * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内! * isolation = 设置事务的隔离级别,mysql默认是repeatable read! */ @Transactional(readOnly = false, timeout = 3, rollbackFor = Exception.class, noRollbackFor = FileNotFoundException.class, isolation = Isolation.REPEATABLE_READ) public void changeInfo() throws FileNotFoundException &#123; studentDao.updateAgeById(100,1); //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内! new FileInputStream(&quot;xxxx&quot;); studentDao.updateNameById(&quot;test1&quot;,1); &#125;&#125; 事务属性：事务传播行为 事务传播行为要研究的问题 举例代码： 12345678910111213@Transactionalpublic void MethodA()&#123; // ... MethodB(); // ...&#125;//在被调用的子方法中设置传播行为，代表如何处理调用的事务！ 是加入，还是新事务等！@Transactional(propagation = Propagation.REQUIRES_NEW)public void MethodB()&#123; // ...&#125; propagation属性 @Transactional 注解通过 propagation 属性设置事务的传播行为。它的默认值是： 12Propagation propagation() default Propagation.REQUIRED; propagation 属性的可选值由 org.springframework.transaction.annotation.Propagation 枚举类提供： 名称 含义 REQUIRED 默认值 如果父方法有事务，就加入，如果没有就新建自己独立！ REQUIRES_NEW 不管父方法是否有事务，我都新建事务，都是独立的！ **注意：** 在同一个类中，对于@Transactional注解的方法调用，事务传播行为不会生效。这是因为Spring框架中使用代理模式实现了事务机制，在同一个类中的方法调用并不经过代理，而是通过对象的方法调用，因此@Transactional注解的设置不会被代理捕获，也就不会产生任何事务传播行为的效果。 其他传播行为值（了解） Propagation.REQUIRED：如果当前存在事务，则加入当前事务，否则创建一个新事务。 Propagation.REQUIRES_NEW：创建一个新事务，并在新事务中执行。如果当前存在事务，则挂起当前事务，即使新事务抛出异常，也不会影响当前事务。 Propagation.NESTED：如果当前存在事务，则在该事务中嵌套一个新事务，如果没有事务，则与Propagation.REQUIRED一样。 Propagation.SUPPORTS：如果当前存在事务，则加入该事务，否则以非事务方式执行。 Propagation.NOT_SUPPORTED：以非事务方式执行，如果当前存在事务，挂起该事务。 Propagation.MANDATORY：必须在一个已有的事务中执行，否则抛出异常。 Propagation.NEVER：必须在没有事务的情况下执行，否则抛出异常。 Spring核心掌握总结 核心点 掌握目标 spring框架理解 spring家族和spring framework框架 spring核心功能 ioc&#x2F;di , aop , tx spring ioc &#x2F; di 组件管理、ioc容器、ioc&#x2F;di , 三种配置方式 spring aop aop和aop框架和代理技术、基于注解的aop配置 spring tx 声明式和编程式事务、动态事务管理器、事务注解、属性 MyBatis版本：3.5.11提高持久层开发效率 Mybatis简介简介 MyBatis最初是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation迁移到了Google Code。随着开发团队转投Google Code旗下， iBatis3.x正式更名为MyBatis。代码于2013年11月迁移到Github。 MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 持久层框架对比 JDBC SQL 夹杂在Java代码中耦合度高，导致硬编码内伤 维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见 代码冗长，开发效率低 Hibernate 和 JPA 操作简便，开发效率高 程序中的长难复杂 SQL 需要绕过框架 内部自动生成的 SQL，不容易做特殊优化 基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难。 反射操作太多，导致数据库性能下降 MyBatis 轻量级，性能出色 SQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据 开发效率稍逊于 Hibernate，但是完全能够接收 开发效率：Hibernate&gt;Mybatis&gt;JDBC 运行效率：JDBC&gt;Mybatis&gt;Hibernate 快速入门（基于Mybatis3方式） 准备数据模型（数据库） 项目搭建和依赖导入 12345678910&lt;dependencies&gt; &lt;!-- mybatis依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.11&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 mybatis底层依赖jdbc驱动实现,本次不需要导入连接池,mybatis自带! --&gt;&lt;/dependencies&gt; 实体类准备 12345678910public class Employee &#123; private Integer empId; private String empName; private Double empSalary; //getter | setter&#125; 准备Mapper接口和MapperXML文件 MyBatis 框架下，SQL语句编写位置发生改变，从原来的Java类，改成XML或者注解定义！ 推荐在XML文件中编写SQL语句，让用户能更专注于 SQL 代码，不用关注其他的JDBC代码。 如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码！！ 一般编写SQL语句的文件命名：XxxMapper.xml Xxx一般取表名！！ Mybatis 中的 Mapper 接口相当于以前的 Dao。但是区别在于，Mapper 仅仅只是建接口即可，我们不需要提供实现类，具体的SQL写到对应的Mapper文件，该用法的思路如下图所示： 定义mapper接口 123456789101112131415/** * t_emp表对应数据库SQL语句映射接口! * 接口只规定方法,参数和返回值! * mapper.xml中编写具体SQL语句! */public interface EmployeeMapper &#123; /** * 根据员工id查询员工数据方法 * @param empId 员工id * @return 员工实体对象 */ Employee selectEmployee(Integer empId); &#125; 2. 定义mapper.xml 位置： resources/mappers/EmployeeMapper.xml 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace等于mapper接口类的全限定名,这样实现对应 --&gt;&lt;mapper namespace=&quot;com.wzh.mapper.EmployeeMapper&quot;&gt; &lt;!-- 查询使用 select标签 id = 方法名 resultType = 返回值类型 标签内编写SQL语句 --&gt; &lt;select id=&quot;selectEmployee&quot; resultType=&quot;com.atguigu.pojo.Employee&quot;&gt; &lt;!-- #&#123;empId&#125;代表动态传入的参数,并且进行赋值!后面详细讲解 --&gt; select emp_id empId,emp_name empName, emp_salary empSalary from t_emp where emp_id = #&#123;empId&#125; &lt;/select&gt;&lt;/mapper&gt; 注意： - 方法名和SQL的id一致 - 方法返回值和resultType一致 - 方法的参数和SQL的参数一致 - 接口的全类名和映射配置文件的名称空间一致 准备MyBatis配置文件 mybatis框架配置文件： 数据库连接信息，性能配置，mapper.xml配置等！ 习惯上命名为 mybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。将来整合 Spring 之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- environments表示配置Mybatis的开发环境，可以配置多个环境，在众多具体环境中，使用default属性指定实际运行时使用的环境。default属性的取值是environment标签的id属性的值。 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;!-- environment表示配置Mybatis的一个具体的环境 --&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- Mybatis的内置的事务管理器 --&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!-- 配置数据源 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- 建立数据库连接的具体信息 --&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis-example&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!-- Mapper注册：指定Mybatis映射文件的具体位置 --&gt; &lt;!-- mapper标签：配置一个具体的Mapper映射文件 --&gt; &lt;!-- resource属性：指定Mapper映射文件的实际存储位置，这里需要使用一个以类路径根目录为基准的相对路径 --&gt; &lt;!-- 对Maven工程的目录结构来说，resources目录下的内容会直接放入类路径，所以这里我们可以以resources目录为基准 --&gt; &lt;mapper resource=&quot;mappers/EmployeeMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 运行和测试 12345678910111213141516171819202122232425262728293031323334353637/** * projectName: com.atguigu.test * * description: 测试类 */public class MyBatisTest &#123; @Test public void testSelectEmployee() throws IOException &#123; // 1.创建SqlSessionFactory对象 // ①声明Mybatis全局配置文件的路径 String mybatisConfigFilePath = &quot;mybatis-config.xml&quot;; // ②以输入流的形式加载Mybatis配置文件 InputStream inputStream = Resources.getResourceAsStream(mybatisConfigFilePath); // ③基于读取Mybatis配置文件的输入流创建SqlSessionFactory对象 SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 2.使用SqlSessionFactory对象开启一个会话 SqlSession session = sessionFactory.openSession(); // 3.根据EmployeeMapper接口的Class对象获取Mapper接口类型的对象(动态代理技术) EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class); // 4. 调用代理类方法既可以触发对应的SQL语句 Employee employee = employeeMapper.selectEmployee(1); System.out.println(&quot;employee = &quot; + employee); // 4.关闭SqlSession session.commit(); //提交事务 [DQL不需要,其他需要] session.close(); //关闭会话 &#125;&#125; 说明： SqlSession：代表Java程序和数据库之间的会话。（HttpSession是Java程序和浏览器之间的会话） SqlSessionFactory：是“生产”SqlSession的“工厂”。 工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象。 SqlSession和HttpSession区别 HttpSession：工作在Web服务器上，属于表述层。 代表浏览器和Web服务器之间的会话。 SqlSession：不依赖Web服务器，属于持久化层。 代表Java程序和数据库之间的会话。 MyBatis基本使用向SQL语句传参mybatis日志输出配置 mybatis配置文件设计标签和顶层结构如下： configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） 我们可以在mybatis的配置文件使用settings标签设置，输出运过程SQL日志！ 通过查看日志，我们可以判定#{} 和 ${}的输出效果！ 日志配置： 1234&lt;settings&gt;&lt;!-- SLF4J 选择slf4j输出！ --&gt;&lt;setting name=&quot;logImpl&quot; value=&quot;SLF4J&quot;/&gt;&lt;/settings&gt; #{}形式 Mybatis会将SQL语句中的#{}转换为问号占位符。 ${}形式 ${}形式传参，底层Mybatis做的是字符串拼接操作。 通常不会采用${}的方式传值。一个特定的适用场景是：通过Java程序动态生成数据库表，表名部分需要Java程序通过参数传入；而JDBC对于表名部分是不能使用问号占位符的，此时只能使用 结论：实际开发中，能用#{}实现的，肯定不用${}。 特殊情况： 动态的不是值，是列名或者关键字，需要使用${}拼接 1234//注解方式传入参数！！@Select(&quot;select * from user where $&#123;column&#125; = #&#123;value&#125;&quot;)User findByColumn(@Param(&quot;column&quot;) String column, @Param(&quot;value&quot;) String value); 数据输入概念说明这里数据输入具体是指上层方法（例如Service方法）调用Mapper接口时，数据传入的形式。 简单类型：只包含一个值的数据类型 基本数据类型：int、byte、short、double、…… 基本数据类型的包装类型：Integer、Character、Double、…… 字符串类型：String 复杂类型：包含多个值的数据类型 实体类类型：Employee、Department、…… 集合类型：List、Set、Map、…… 数组类型：int[]、String[]、…… 复合类型：List、实体类中包含集合…… 单个简单类型参数 Mapper接口中抽象方法的声明 1Employee selectEmployee(Integer empId); SQL语句 123&lt;select id=&quot;selectEmployee&quot; resultType=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt;select emp_id empId,emp_name empName,emp_salary empSalary from t_emp where emp_id=#&#123;empId&#125;&lt;/select&gt; 单个简单类型参数，在#{}中可以随意命名，但是没有必要。通常还是使用和接口方法参数同名。 实体类类型参数 Mapper接口中抽象方法的声明 1int insertEmployee(Employee employee); SQL语句 123&lt;insert id=&quot;insertEmployee&quot;&gt;insert into t_emp(emp_name,emp_salary) values(#&#123;empName&#125;,#&#123;empSalary&#125;)&lt;/insert&gt; Mybatis会根据#{}中传入的数据，加工成getXxx()方法，通过反射在实体类对象中调用这个方法，从而获取到对应的数据。填充到#{}解析后的问号占位符这个位置。 零散的简单类型数据 零散的多个简单类型参数，如果没有特殊处理，那么Mybatis无法识别自定义名称： Mapper接口中抽象方法的声明 1int updateEmployee(@Param(&quot;empId&quot;) Integer empId,@Param(&quot;empSalary&quot;) Double empSalary); SQL语句 123&lt;update id=&quot;updateEmployee&quot;&gt;update t_emp set emp_salary=#&#123;empSalary&#125; where emp_id=#&#123;empId&#125;&lt;/update&gt; Map类型参数 Mapper接口中抽象方法的声明 1int updateEmployeeByMap(Map&lt;String, Object&gt; paramMap); SQL语句 12345&lt;update id=&quot;updateEmployeeByMap&quot;&gt;update t_emp set emp_salary=#&#123;empSalaryKey&#125; where emp_id=#&#123;empIdKey&#125;&lt;/update&gt; junit测试 123456789101112131415161718192021222324252627private SqlSession session;//junit5会在每一个@Test方法前执行@BeforeEach方法@BeforeEachpublic void init() throws IOException &#123; session = new SqlSessionFactoryBuilder() .build( Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;)) .openSession();&#125;@Testpublic void testUpdateEmpNameByMap() &#123;EmployeeMapper mapper = session.getMapper(EmployeeMapper.class);Map&lt;String, Object&gt; paramMap = new HashMap&lt;&gt;();paramMap.put(&quot;empSalaryKey&quot;, 999.99);paramMap.put(&quot;empIdKey&quot;, 5);int result = mapper.updateEmployeeByMap(paramMap);log.info(&quot;result = &quot; + result);&#125;//junit5会在每一个@Test方法后执行@@AfterEach方法@AfterEachpublic void clear() &#123; session.commit(); session.close();&#125; 对应关系 #{}中写Map中的key 使用场景 有很多零散的参数需要传递，但是没有对应的实体类类型可以使用。使用@Param注解一个一个传入又太麻烦了。所以都封装到Map中。 数据输出输出概述 数据输出总体上有两种形式： 增删改操作返回的受影响行数：直接使用 int 或 long 类型接收即可 查询操作的查询结果 我们需要做的是，指定查询的输出数据类型即可！ 并且插入场景下，实现主键数据回显示！ 单个简单类型 Mapper接口中的抽象方法 1int selectEmpCount(); SQL语句 123&lt;select id=&quot;selectEmpCount&quot; resultType=&quot;int&quot;&gt;select count(*) from t_emp&lt;/select&gt; Mybatis 内部给常用的数据类型设定了很多别名。 以 int 类型为例，可以写的名称有：int、integer、Integer、java.lang.Integer、Int、INT、INTEGER 等等。 细节解释： select标签，通过resultType指定查询返回值类型！ resultType = &quot;全限定符 ｜ 别名 ｜ 如果是返回集合类型，写范型类型即可&quot; 别名问题： [https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases](https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases) 类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。例如： 1234&lt;typeAliases&gt;&lt;typeAlias alias=&quot;Author&quot; type=&quot;domain.blog.Author&quot;/&gt;&lt;typeAlias alias=&quot;Blog&quot; type=&quot;domain.blog.Blog&quot;/&gt;&lt;/typeAliases&gt; 当这样配置时，`Blog` 可以用在任何使用 `domain.blog.Blog` 的地方。 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如： 1&lt;typeAliases&gt; &lt;package name=&quot;domain.blog&quot;/&gt; &lt;/typeAliases&gt; 每一个在包 `domain.blog` 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 `domain.blog.Author` 的别名为 `author`；若有注解，则别名为其注解值。见下面的例子： 1234@Alias(&quot;author&quot;)public class Author &#123;...&#125; 下面是Mybatis为常见的 Java 类型内建的类型别名。它们都是不区分大小写的，注意，为了应对原始类型的命名重复，采取了特殊的命名风格。 别名 映射的类型 _byte byte _char (since 3.5.10) char _character (since 3.5.10) char _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte char (since 3.5.10) Character character (since 3.5.10) Character long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date decimal BigDecimal bigdecimal BigDecimal biginteger BigInteger object Object object[] Object[] map Map hashmap HashMap list List arraylist ArrayList collection Collection 返回实体类对象 Mapper接口的抽象方法 12Employee selectEmployee(Integer empId); SQL语句 123456789&lt;!-- 编写具体的SQL语句，使用id属性唯一的标记一条SQL语句 --&gt;&lt;!-- resultType属性：指定封装查询结果的Java实体类的全类名 --&gt;&lt;select id=&quot;selectEmployee&quot; resultType=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt;&lt;!-- Mybatis负责把SQL语句中的#&#123;&#125;部分替换成“?”占位符 --&gt;&lt;!-- 给每一个字段设置一个别名，让别名和Java实体类中属性名一致 --&gt;select emp_id empId,emp_name empName,emp_salary empSalary from t_emp where emp_id=#&#123;maomi&#125;&lt;/select&gt; 通过给数据库表字段加别名，让查询结果的每一列都和Java实体类中属性对应起来。 增加全局配置自动识别对应关系 在 Mybatis 全局配置文件中，做了下面的配置，select语句中可以不给字段设置别名 1234567891011&lt;!-- 在全局范围内对Mybatis进行配置 --&gt;&lt;settings&gt;&lt;!-- 具体配置 --&gt;&lt;!-- 从org.apache.ibatis.session.Configuration类中可以查看能使用的配置项 --&gt;&lt;!-- 将mapUnderscoreToCamelCase属性配置为true，表示开启自动映射驼峰式命名规则 --&gt;&lt;!-- 规则要求数据库表字段命名方式：单词_单词 --&gt;&lt;!-- 规则要求Java实体类属性名命名方式：首字母小写的驼峰式命名 --&gt;&lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; 返回Map类型 适用于SQL查询返回的各个字段综合起来并不和任何一个现有的实体类对应，没法封装到实体类对象中。能够封装成实体类类型的，就不使用Map类型。 Mapper接口的抽象方法 1Map&lt;String,Object&gt; selectEmpNameAndMaxSalary(); SQL语句 1234567891011&lt;!-- Map&lt;String,Object&gt; selectEmpNameAndMaxSalary(); --&gt;&lt;!-- 返回工资最高的员工的姓名和他的工资 --&gt;&lt;select id=&quot;selectEmpNameAndMaxSalary&quot; resultType=&quot;map&quot;&gt;SELECTemp_name 员工姓名,emp_salary 员工工资,(SELECT AVG(emp_salary) FROM t_emp) 部门平均工资FROM t_emp WHERE emp_salary=(SELECT MAX(emp_salary) FROM t_emp)&lt;/select&gt; 返回List类型 查询结果返回多个实体类对象，希望把多个实体类对象放在List集合中返回。此时不需要任何特殊处理，在resultType属性中还是设置实体类类型即可。 Mapper接口中抽象方法 1List&lt;Employee&gt; selectAll(); SQL语句 12345&lt;!-- List&lt;Employee&gt; selectAll(); --&gt;&lt;select id=&quot;selectAll&quot; resultType=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt;select emp_id empId,emp_name empName,emp_salary empSalaryfrom t_emp&lt;/select&gt; 返回主键值 自增长类型主键 Mapper接口中的抽象方法 1int insertEmployee(Employee employee); SQL语句 1234567&lt;!-- int insertEmployee(Employee employee); --&gt;&lt;!-- useGeneratedKeys属性字面意思就是“使用生成的主键” --&gt;&lt;!-- keyProperty属性可以指定主键在实体类对象中对应的属性名，Mybatis会将拿到的主键值存入这个属性 --&gt;&lt;insert id=&quot;insertEmployee&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;empId&quot;&gt;insert into t_emp(emp_name,emp_salary)values(#&#123;empName&#125;,#&#123;empSalary&#125;)&lt;/insert&gt; 注意: Mybatis是将自增主键的值设置到实体类对象中，而不是以Mapper接口方法返回值的形式返回。2. 非自增长类型主键 而对于不支持自增型主键的数据库（例如 Oracle）或者字符串类型主键，则可以使用 selectKey 子元素：selectKey 元素将会首先运行，id 会被设置，然后插入语句会被调用！ 使用 selectKey 帮助插入UUID作为字符串类型主键示例： 12345678910111213&lt;insert id=&quot;insertUser&quot; parameterType=&quot;User&quot;&gt;&lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;java.lang.String&quot; order=&quot;BEFORE&quot;&gt; SELECT UUID() as id&lt;/selectKey&gt;INSERT INTO user (id, username, password) VALUES ( #&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125;)&lt;/insert&gt; 在上例中，我们定义了一个 insertUser 的插入语句来将 User 对象插入到 user 表中。我们使用 selectKey 来查询 UUID 并设置到 id 字段中。 通过 keyProperty 属性来指定查询到的 UUID 赋值给对象中的 id 属性，而 resultType 属性指定了 UUID 的类型为 java.lang.String。 需要注意的是，我们将 selectKey 放在了插入语句的前面，这是因为 MySQL 在 insert 语句中只支持一个 select 子句，而 selectKey 中查询 UUID 的语句就是一个 select 子句，因此我们需要将其放在前面。 最后，在将 User 对象插入到 user 表中时，我们直接使用对象中的 id 属性来插入主键值。 使用这种方式，我们可以方便地插入 UUID 作为字符串类型主键。当然，还有其他插入方式可以使用，如使用Java代码生成UUID并在类中显式设置值等。需要根据具体应用场景和需求选择合适的插入方式。 实体类属性和数据库字段对应关系 别名对应 将字段的别名设置成和实体类属性一致。 123456789&lt;!-- 编写具体的SQL语句，使用id属性唯一的标记一条SQL语句 --&gt;&lt;!-- resultType属性：指定封装查询结果的Java实体类的全类名 --&gt;&lt;select id=&quot;selectEmployee&quot; resultType=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt;&lt;!-- Mybatis负责把SQL语句中的#&#123;&#125;部分替换成“?”占位符 --&gt;&lt;!-- 给每一个字段设置一个别名，让别名和Java实体类中属性名一致 --&gt;select emp_id empId,emp_name empName,emp_salary empSalary from t_emp where emp_id=#&#123;maomi&#125;&lt;/select&gt; 关于实体类属性的约定：getXxx()方法、setXxx()方法把方法名中的get或set去掉，首字母小写。2. 全局配置自动识别驼峰式命名规则 在Mybatis全局配置文件加入如下配置： 1234567&lt;!-- 使用settings对Mybatis全局进行设置 --&gt;&lt;settings&gt;&lt;!-- 将xxx_xxx这样的列名自动映射到xxXxx这样驼峰式命名的属性名 --&gt;&lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; SQL语句中可以不使用别名 123456&lt;!-- Employee selectEmployee(Integer empId); --&gt;&lt;select id=&quot;selectEmployee&quot; resultType=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt;select emp_id,emp_name,emp_salary from t_emp where emp_id=#&#123;empId&#125;&lt;/select&gt; 使用resultMap 使用resultMap标签定义对应关系，再在后面的SQL语句中引用这个对应关系 1234567891011121314151617181920&lt;!-- 专门声明一个resultMap设定column到property之间的对应关系 --&gt;&lt;resultMap id=&quot;selectEmployeeByRMResultMap&quot; type=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt;&lt;!-- 使用id标签设置主键列和主键属性之间的对应关系 --&gt;&lt;!-- column属性用于指定字段名；property属性用于指定Java实体类属性名 --&gt;&lt;id column=&quot;emp_id&quot; property=&quot;empId&quot;/&gt;&lt;!-- 使用result标签设置普通字段和Java实体类属性之间的关系 --&gt;&lt;result column=&quot;emp_name&quot; property=&quot;empName&quot;/&gt;&lt;result column=&quot;emp_salary&quot; property=&quot;empSalary&quot;/&gt;&lt;/resultMap&gt;&lt;!-- Employee selectEmployeeByRM(Integer empId); --&gt;&lt;select id=&quot;selectEmployeeByRM&quot; resultMap=&quot;selectEmployeeByRMResultMap&quot;&gt;select emp_id,emp_name,emp_salary from t_emp where emp_id=#&#123;empId&#125;&lt;/select&gt; mapperXML标签总结 MyBatis 的真正强大在于它的语句映射，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 致力于减少使用成本，让用户能更专注于 SQL 代码。 SQL 映射文件只有很少的几个顶级元素（按照应被定义的顺序列出）： insert – 映射插入语句。 update – 映射更新语句。 delete – 映射删除语句。 select – 映射查询语句。 select标签： MyBatis 在查询和结果映射做了相当多的改进。一个简单查询的 select 元素是非常简单： 12&lt;select id=&quot;selectPerson&quot; resultType=&quot;hashmap&quot; resultMap=&quot;自定义结构&quot;&gt; SELECT * FROM PERSON WHERE ID = #&#123;id&#125; &lt;/select&gt; 这个语句名为 selectPerson，接受一个 int（或 Integer）类型的参数，并返回一个 HashMap 类型的对象，其中的键是列名，值便是结果行中的对应值。 注意参数符号：#&#123;id&#125; $&#123;key&#125; MyBatis 创建一个预处理语句（PreparedStatement）参数，在 JDBC 中，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中，就像这样： 1234// 近似的 JDBC 代码，非 MyBatis 代码...String selectPerson = &quot;SELECT * FROM PERSON WHERE ID=?&quot;;PreparedStatement ps = conn.prepareStatement(selectPerson);ps.setInt(1,id); select 元素允许你配置很多属性来配置每条语句的行为细节： 属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句。 resultType 期望从这条语句中返回结果的类全限定名或别名。 注意，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。 resultType 和 resultMap 之间只能同时使用一个。 resultMap 对外部 resultMap 的命名引用。结果映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。 resultType 和 resultMap 之间只能同时使用一个。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。 statementType 可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 insert, update 和 delete标签： 数据变更语句 insert，update 和 delete 的实现非常接近： 1234567891011121314151617&lt;insertid=&quot;insertAuthor&quot;statementType=&quot;PREPARED&quot;keyProperty=&quot;&quot;keyColumn=&quot;&quot;useGeneratedKeys=&quot;&quot;timeout=&quot;20&quot;&gt;&lt;updateid=&quot;updateAuthor&quot;statementType=&quot;PREPARED&quot;timeout=&quot;20&quot;&gt;&lt;deleteid=&quot;deleteAuthor&quot;statementType=&quot;PREPARED&quot;timeout=&quot;20&quot;&gt; 属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。 statementType 可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 useGeneratedKeys （仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。 keyProperty （仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis 会使用 getGeneratedKeys 的返回值或 insert 语句的 selectKey 子元素设置它的值，默认值：未设置（unset）。如果生成列不止一个，可以用逗号分隔多个属性名称。 keyColumn （仅适用于 insert 和 update）设置生成键值在表中的列名，在某些数据库（像 PostgreSQL）中，当主键列不是表中的第一列的时候，是必须设置的。如果生成列不止一个，可以用逗号分隔多个属性名称。 MyBatis多表映射多表映射概念 多表查询结果映射思路 开发中更多的是多表查询需求，这种情况我们如何让进行处理？ MyBatis 思想是：数据库不可能永远是你所想或所需的那个样子。 我们希望每个数据库都具备良好的第三范式或 BCNF 范式，可惜它们并不都是那样。 如果能有一种数据库映射模式，完美适配所有的应用程序查询需求，那就太好了，而 ResultMap 就是 MyBatis 就是完美答案。 实体类设计方案 多表关系回顾：（双向查看） 一对一 一对多| 多对一 多对多 实体类设计关系(查询)：（单向查看） 对一 : 实体类设计：对一关系下，类中只要包含单个对方对象类型属性即可！ 123456789101112131415public class Customer &#123;private Integer customerId;private String customerName;&#125;public class Order &#123;private Integer orderId;private String orderName;private Customer customer;// 体现的是对一的关系&#125; - 对多: 实体类设计：对多关系下，类中只要包含对方类型集合属性即可！ 1234567891011121314public class Customer &#123;private Integer customerId;private String customerName;private List&lt;Order&gt; orderList;// 体现的是对多的关系&#125;public class Order &#123;private Integer orderId;private String orderName;private Customer customer;// 体现的是对一的关系&#125; 多表结果实体类设计小技巧： 对一，属性中包含对方对象 对多，属性中包含对方对象集合 只有真实发生多表查询时，才需要设计和修改实体类，否则不提前设计和修改实体类！ 无论多少张表联查，实体类设计都是两两考虑! 在查询映射的时候，只需要关注本次查询相关的属性！例如：查询订单和对应的客户，就不要关注客户中的订单集合！ 多表映射案例准备 数据库： 实际开发时，一般在开发过程中，不给数据库表设置外键约束。原因是避免调试不方便。一般是功能开发完成，再加外键约束检查是否有bug。 对一映射 需求说明 根据ID查询订单，以及订单关联的用户的信息！ OrderMapper接口 123public interface OrderMapper &#123;Order selectOrderWithCustomer(Integer orderId);&#125; OrderMapper.xml配置文件 123456789101112131415161718192021222324252627282930313233&lt;!-- 创建resultMap实现“对一”关联关系映射 --&gt;&lt;!-- id属性：通常设置为这个resultMap所服务的那条SQL语句的id加上“ResultMap” --&gt;&lt;!-- type属性：要设置为这个resultMap所服务的那条SQL语句最终要返回的类型 --&gt;&lt;resultMap id=&quot;selectOrderWithCustomerResultMap&quot; type=&quot;order&quot;&gt;&lt;!-- 先设置Order自身属性和字段的对应关系 --&gt;&lt;id column=&quot;order_id&quot; property=&quot;orderId&quot;/&gt;&lt;result column=&quot;order_name&quot; property=&quot;orderName&quot;/&gt;&lt;!-- 使用association标签配置“对一”关联关系 --&gt;&lt;!-- property属性：在Order类中对一的一端进行引用时使用的属性名 --&gt;&lt;!-- javaType属性：一的一端类的全类名 --&gt;&lt;association property=&quot;customer&quot; javaType=&quot;customer&quot;&gt; &lt;!-- 配置Customer类的属性和字段名之间的对应关系 --&gt; &lt;id column=&quot;customer_id&quot; property=&quot;customerId&quot;/&gt; &lt;result column=&quot;customer_name&quot; property=&quot;customerName&quot;/&gt;&lt;/association&gt;&lt;/resultMap&gt;&lt;!-- Order selectOrderWithCustomer(Integer orderId); --&gt;&lt;select id=&quot;selectOrderWithCustomer&quot; resultMap=&quot;selectOrderWithCustomerResultMap&quot;&gt;SELECT order_id,order_name,c.customer_id,customer_nameFROM t_order oLEFT JOIN t_customer cON o.customer_id=c.customer_idWHERE o.order_id=#&#123;orderId&#125;&lt;/select&gt; Mybatis全局注册Mapper文件 1234567&lt;!-- 注册Mapper配置文件：告诉Mybatis我们的Mapper配置文件的位置 --&gt;&lt;mappers&gt;&lt;!-- 在mapper标签的resource属性中指定Mapper配置文件以“类路径根目录”为基准的相对路径 --&gt;&lt;mapper resource=&quot;mappers/OrderMapper.xml&quot;/&gt;&lt;/mappers&gt; junit测试程序 关键词 在“对一”关联关系中，我们的配置比较多，但是关键词就只有：association和javaType 对多映射 需求说明 查询客户和客户关联的订单信息！ CustomerMapper接口 12345public interface CustomerMapper &#123;Customer selectCustomerWithOrderList(Integer customerId);&#125; CustomerMapper.xml文件 1234567891011121314151617181920212223242526272829303132&lt;!-- 配置resultMap实现从Customer到OrderList的“对多”关联关系 --&gt;&lt;resultMap id=&quot;selectCustomerWithOrderListResultMap&quot;type=&quot;customer&quot;&gt;&lt;!-- 映射Customer本身的属性 --&gt;&lt;id column=&quot;customer_id&quot; property=&quot;customerId&quot;/&gt;&lt;result column=&quot;customer_name&quot; property=&quot;customerName&quot;/&gt;&lt;!-- collection标签：映射“对多”的关联关系 --&gt;&lt;!-- property属性：在Customer类中，关联“多”的一端的属性名 --&gt;&lt;!-- ofType属性：集合属性中元素的类型 --&gt;&lt;collection property=&quot;orderList&quot; ofType=&quot;order&quot;&gt; &lt;!-- 映射Order的属性 --&gt; &lt;id column=&quot;order_id&quot; property=&quot;orderId&quot;/&gt; &lt;result column=&quot;order_name&quot; property=&quot;orderName&quot;/&gt;&lt;/collection&gt;&lt;/resultMap&gt;&lt;!-- Customer selectCustomerWithOrderList(Integer customerId); --&gt;&lt;select id=&quot;selectCustomerWithOrderList&quot; resultMap=&quot;selectCustomerWithOrderListResultMap&quot;&gt;SELECT c.customer_id,c.customer_name,o.order_id,o.order_nameFROM t_customer cLEFT JOIN t_order oON c.customer_id=o.customer_idWHERE c.customer_id=#&#123;customerId&#125;&lt;/select&gt; Mybatis全局注册Mapper文件 junit测试程序 关键词 在“对多”关联关系中，同样有很多配置，但是提炼出来最关键的就是：“collection”和“ofType” 多表映射总结多表映射优化 setting属性 属性含义 可选值 默认值 autoMappingBehavior 指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示关闭自动映射；PARTIAL 只会自动映射没有定义嵌套结果映射的字段。 FULL 会自动映射任何复杂的结果集（无论是否嵌套）。 NONE, PARTIAL, FULL PARTIAL 我们可以将autoMappingBehavior设置为full,进行多表resultMap映射的时候，可以省略符合列和属性命名映射规则（列名&#x3D;属性名，或者开启驼峰映射也可以自定映射）的result标签！ 修改mybatis-config.xml: 12&lt;!--开启resultMap自动映射 --&gt;&lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;FULL&quot;/&gt; 修改teacherMapper.xml 123456789&lt;resultMap id=&quot;teacherMap&quot; type=&quot;teacher&quot;&gt; &lt;id property=&quot;tId&quot; column=&quot;t_id&quot; /&gt; &lt;!-- 开启自动映射,并且开启驼峰式支持!可以省略 result!--&gt;&lt;!-- &lt;result property=&quot;tName&quot; column=&quot;t_name&quot; /&gt;--&gt; &lt;collection property=&quot;students&quot; ofType=&quot;student&quot; &gt; &lt;id property=&quot;sId&quot; column=&quot;s_id&quot; /&gt;&lt;!-- &lt;result property=&quot;sName&quot; column=&quot;s_name&quot; /&gt;--&gt; &lt;/collection&gt;&lt;/resultMap&gt; 多表映射总结 关联关系 配置项关键词 所在配置文件和具体位置 对一 association标签&#x2F;javaType属性&#x2F;property属性 Mapper配置文件中的resultMap标签内 对多 collection标签&#x2F;ofType属性&#x2F;property属性 Mapper配置文件中的resultMap标签内 MyBatis动态语句动态语句需求和简介 经常遇到很多按照很多查询条件进行查询的情况，比如智联招聘的职位搜索等。其中经常出现很多条件不取值的情况，在后台应该如何完成最终的SQL语句呢？ 动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。 使用动态 SQL 并非一件易事，但借助可用于任何 SQL 映射语句中的强大的动态 SQL 语言，MyBatis 显著地提升了这一特性的易用性。 如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。 if和where标签 使用动态 SQL 最常见情景是根据条件包含 where &#x2F; if 子句的一部分。比如： 123456789101112131415161718192021&lt;!-- List&lt;Employee&gt; selectEmployeeByCondition(Employee employee); --&gt;&lt;select id=&quot;selectEmployeeByCondition&quot; resultType=&quot;employee&quot;&gt; select emp_id,emp_name,emp_salary from t_emp &lt;!-- where标签会自动去掉“标签体内前面多余的and/or” --&gt; &lt;where&gt; &lt;!-- 使用if标签，让我们可以有选择的加入SQL语句的片段。这个SQL语句片段是否要加入整个SQL语句，就看if标签判断的结果是否为true --&gt; &lt;!-- 在if标签的test属性中，可以访问实体类的属性，不可以访问数据库表的字段 --&gt; &lt;if test=&quot;empName != null&quot;&gt; &lt;!-- 在if标签内部，需要访问接口的参数时还是正常写#&#123;&#125; --&gt; or emp_name=#&#123;empName&#125; &lt;/if&gt; &lt;if test=&quot;empSalary &amp;gt; 2000&quot;&gt; or emp_salary&gt;#&#123;empSalary&#125; &lt;/if&gt; &lt;!-- 第一种情况：所有条件都满足 WHERE emp_name=? or emp_salary&gt;? 第二种情况：部分条件满足 WHERE emp_salary&gt;? 第三种情况：所有条件都不满足 没有where子句 --&gt; &lt;/where&gt;&lt;/select&gt; set标签123456789101112131415161718192021&lt;!-- void updateEmployeeDynamic(Employee employee) --&gt;&lt;update id=&quot;updateEmployeeDynamic&quot;&gt; update t_emp &lt;!-- set emp_name=#&#123;empName&#125;,emp_salary=#&#123;empSalary&#125; --&gt; &lt;!-- 使用set标签动态管理set子句，并且动态去掉两端多余的逗号 --&gt; &lt;set&gt; &lt;if test=&quot;empName != null&quot;&gt; emp_name=#&#123;empName&#125;, &lt;/if&gt; &lt;if test=&quot;empSalary &amp;lt; 3000&quot;&gt; emp_salary=#&#123;empSalary&#125;, &lt;/if&gt; &lt;/set&gt; where emp_id=#&#123;empId&#125; &lt;!-- 第一种情况：所有条件都满足 SET emp_name=?, emp_salary=? 第二种情况：部分条件满足 SET emp_salary=? 第三种情况：所有条件都不满足 update t_emp where emp_id=? 没有set子句的update语句会导致SQL语法错误 --&gt;&lt;/update&gt; trim标签(了解) 使用trim标签控制条件部分两端是否包含某些字符 prefix属性：指定要动态添加的前缀 suffix属性：指定要动态添加的后缀 prefixOverrides属性：指定要动态去掉的前缀，使用“|”分隔有可能的多个值 suffixOverrides属性：指定要动态去掉的后缀，使用“|”分隔有可能的多个值 12345678910111213141516171819202122232425&lt;!-- List&lt;Employee&gt; selectEmployeeByConditionByTrim(Employee employee) --&gt;&lt;select id=&quot;selectEmployeeByConditionByTrim&quot; resultType=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt; select emp_id,emp_name,emp_age,emp_salary,emp_gender from t_emp &lt;!-- prefix属性指定要动态添加的前缀 --&gt; &lt;!-- suffix属性指定要动态添加的后缀 --&gt; &lt;!-- prefixOverrides属性指定要动态去掉的前缀，使用“|”分隔有可能的多个值 --&gt; &lt;!-- suffixOverrides属性指定要动态去掉的后缀，使用“|”分隔有可能的多个值 --&gt; &lt;!-- 当前例子用where标签实现更简洁，但是trim标签更灵活，可以用在任何有需要的地方 --&gt; &lt;trim prefix=&quot;where&quot; suffixOverrides=&quot;and|or&quot;&gt; &lt;if test=&quot;empName != null&quot;&gt; emp_name=#&#123;empName&#125; and &lt;/if&gt; &lt;if test=&quot;empSalary &amp;gt; 3000&quot;&gt; emp_salary&gt;#&#123;empSalary&#125; and &lt;/if&gt; &lt;if test=&quot;empAge &amp;lt;= 20&quot;&gt; emp_age=#&#123;empAge&#125; or &lt;/if&gt; &lt;if test=&quot;empGender==&#x27;male&#x27;&quot;&gt; emp_gender=#&#123;empGender&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; choose&#x2F;when&#x2F;otherwise标签 在多个分支条件中，仅执行一个。 从上到下依次执行条件判断 遇到的第一个满足条件的分支会被采纳 被采纳分支后面的分支都将不被考虑 如果所有的when分支都不满足，那么就执行otherwise分支 12345678910111213141516&lt;!-- List&lt;Employee&gt; selectEmployeeByConditionByChoose(Employee employee) --&gt;&lt;select id=&quot;selectEmployeeByConditionByChoose&quot; resultType=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt; select emp_id,emp_name,emp_salary from t_emp where &lt;choose&gt; &lt;when test=&quot;empName != null&quot;&gt;emp_name=#&#123;empName&#125;&lt;/when&gt; &lt;when test=&quot;empSalary &amp;lt; 3000&quot;&gt;emp_salary &amp;lt; 3000&lt;/when&gt; &lt;otherwise&gt;1=1&lt;/otherwise&gt; &lt;/choose&gt; &lt;!-- 第一种情况：第一个when满足条件 where emp_name=? 第二种情况：第二个when满足条件 where emp_salary &lt; 3000 第三种情况：两个when都不满足 where 1=1 执行了otherwise --&gt;&lt;/select&gt; foreach标签 基本用法 用批量插入举例 1234567891011121314&lt;!-- collection属性：要遍历的集合 item属性：遍历集合的过程中能得到每一个具体对象，在item属性中设置一个名字，将来通过这个名字引用遍历出来的对象 separator属性：指定当foreach标签的标签体重复拼接字符串时，各个标签体字符串之间的分隔符 open属性：指定整个循环把字符串拼好后，字符串整体的前面要添加的字符串 close属性：指定整个循环把字符串拼好后，字符串整体的后面要添加的字符串 index属性：这里起一个名字，便于后面引用 遍历List集合，这里能够得到List集合的索引值 遍历Map集合，这里能够得到Map集合的key--&gt;&lt;foreach collection=&quot;empList&quot; item=&quot;emp&quot; separator=&quot;,&quot; open=&quot;values&quot; index=&quot;myIndex&quot;&gt; &lt;!-- 在foreach标签内部如果需要引用遍历得到的具体的一个对象，需要使用item属性声明的名称 --&gt; (#&#123;emp.empName&#125;,#&#123;myIndex&#125;,#&#123;emp.empSalary&#125;,#&#123;emp.empGender&#125;)&lt;/foreach&gt; 批量更新时需要注意 上面批量插入的例子本质上是一条SQL语句，而实现批量更新则需要多条SQL语句拼起来，用分号分开。也就是一次性发送多条SQL语句让数据库执行。此时需要在数据库连接信息的URL地址中设置： 1atguigu.dev.url=jdbc:mysql:///mybatis-example?allowMultiQueries=true 对应的foreach标签如下： 123456&lt;!-- int updateEmployeeBatch(@Param(&quot;empList&quot;) List&lt;Employee&gt; empList) --&gt;&lt;update id=&quot;updateEmployeeBatch&quot;&gt; &lt;foreach collection=&quot;empList&quot; item=&quot;emp&quot; separator=&quot;;&quot;&gt; update t_emp set emp_name=#&#123;emp.empName&#125; where emp_id=#&#123;emp.empId&#125; &lt;/foreach&gt;&lt;/update&gt; 关于foreach标签的collection属性 如果没有给接口中List类型的参数使用@Param注解指定一个具体的名字，那么在collection属性中默认可以使用collection或list来引用这个list集合。这一点可以通过异常信息看出来： 1Parameter &#x27;empList&#x27; not found. Available parameters are [arg0, collection, list] 在实际开发中，为了避免隐晦的表达造成一定的误会，建议使用@Param注解明确声明变量的名称，然后在foreach标签的collection属性中按照@Param注解指定的名称来引用传入的参数。 sql片段 抽取重复的SQL片段 1234&lt;!-- 使用sql标签抽取重复出现的SQL片段 --&gt;&lt;sql id=&quot;mySelectSql&quot;&gt; select emp_id,emp_name,emp_age,emp_salary,emp_gender from t_emp&lt;/sql&gt; 引用已抽取的SQL片段 12&lt;!-- 使用include标签引用声明的SQL片段 --&gt;&lt;include refid=&quot;mySelectSql&quot;/&gt; MyBatis高级扩展Mapper批量映射优化 需求 Mapper 配置文件很多时，在全局配置文件中一个一个注册太麻烦，希望有一个办法能够一劳永逸。 配置方式 Mybatis 允许在指定 Mapper 映射文件时，只指定其所在的包： 123&lt;mappers&gt; &lt;package name=&quot;com.atguigu.mapper&quot;/&gt;&lt;/mappers&gt; 此时这个包下的所有 Mapper 配置文件将被自动加载、注册，比较方便。 资源创建要求 Mapper 接口和 Mapper 配置文件名称一致 Mapper 接口：EmployeeMapper.java Mapper 配置文件：EmployeeMapper.xml Mapper 配置文件放在 Mapper 接口所在的包内 可以将mapperxml文件放在mapper接口所在的包！ 可以在sources下创建mapper接口包一致的文件夹结构存放mapperxml文件 插件和分页插件PageHelper插件机制和PageHelper插件介绍 MyBatis 对插件进行了标准化的设计，并提供了一套可扩展的插件机制。插件可以在用于语句执行过程中进行拦截，并允许通过自定义处理程序来拦截和修改 SQL 语句、映射语句的结果等。 具体来说，MyBatis 的插件机制包括以下三个组件： Interceptor（拦截器）：定义一个拦截方法 intercept，该方法在执行 SQL 语句、执行查询、查询结果的映射时会被调用。 Invocation（调用）：实际上是对被拦截的方法的封装，封装了 Object target、Method method 和 Object[] args 这三个字段。 InterceptorChain（拦截器链）：对所有的拦截器进行管理，包括将所有的 Interceptor 链接成一条链，并在执行 SQL 语句时按顺序调用。 插件的开发非常简单，只需要实现 Interceptor 接口，并使用注解 @Intercepts 来标注需要拦截的对象和方法，然后在 MyBatis 的配置文件中添加插件即可。 PageHelper 是 MyBatis 中比较著名的分页插件，它提供了多种分页方式（例如 MySQL 和 Oracle 分页方式），支持多种数据库，并且使用非常简单。下面就介绍一下 PageHelper 的使用方式。 PageHelper插件使用 pom.xml引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.11&lt;/version&gt;&lt;/dependency&gt; mybatis-config.xml配置分页插件 在 MyBatis 的配置文件中添加 PageHelper 的插件： 123456&lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;property name=&quot;helperDialect&quot; value=&quot;mysql&quot;/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 其中，com.github.pagehelper.PageInterceptor 是 PageHelper 插件的名称，dialect 属性用于指定数据库类型（支持多种数据库） 页插件使用 在查询方法中使用分页： 12345678910111213141516171819202122232425@Testpublic void testTeacherRelationshipToMulti() &#123; TeacherMapper teacherMapper = session.getMapper(TeacherMapper.class); PageHelper.startPage(1,2); // 查询Customer对象同时将关联的Order集合查询出来 List&lt;Teacher&gt; allTeachers = teacherMapper.findAllTeachers();// PageInfo&lt;Teacher&gt; pageInfo = new PageInfo&lt;&gt;(allTeachers); System.out.println(&quot;pageInfo = &quot; + pageInfo); long total = pageInfo.getTotal(); // 获取总记录数 System.out.println(&quot;total = &quot; + total); int pages = pageInfo.getPages(); // 获取总页数 System.out.println(&quot;pages = &quot; + pages); int pageNum = pageInfo.getPageNum(); // 获取当前页码 System.out.println(&quot;pageNum = &quot; + pageNum); int pageSize = pageInfo.getPageSize(); // 获取每页显示记录数 System.out.println(&quot;pageSize = &quot; + pageSize); List&lt;Teacher&gt; teachers = pageInfo.getList(); //获取查询页的数据集合 System.out.println(&quot;teachers = &quot; + teachers); teachers.forEach(System.out::println);&#125; 逆向工程和MybatisX插件ORM思维介绍 ORM（Object-Relational Mapping，对象-关系映射）是一种将数据库和面向对象编程语言中的对象之间进行转换的技术。它将对象和关系数据库的概念进行映射，最后我们就可以通过方法调用进行数据库操作!! 最终: 让我们可以使用面向对象思维进行数据库操作！！！ ORM 框架通常有半自动和全自动两种方式。 半自动 ORM 通常需要程序员手动编写 SQL 语句或者配置文件，将实体类和数据表进行映射，还需要手动将查询的结果集转换成实体对象。 全自动 ORM 则是将实体类和数据表进行自动映射，使用 API 进行数据库操作时，ORM 框架会自动执行 SQL 语句并将查询结果转换成实体对象，程序员无需再手动编写 SQL 语句和转换代码。 下面是半自动和全自动 ORM 框架的区别： 映射方式：半自动 ORM 框架需要程序员手动指定实体类和数据表之间的映射关系，通常使用 XML 文件或注解方式来指定；全自动 ORM 框架则可以自动进行实体类和数据表的映射，无需手动干预。 查询方式：半自动 ORM 框架通常需要程序员手动编写 SQL 语句并将查询结果集转换成实体对象；全自动 ORM 框架可以自动组装 SQL 语句、执行查询操作，并将查询结果转换成实体对象。 性能：由于半自动 ORM 框架需要手动编写 SQL 语句，因此程序员必须对 SQL 语句和数据库的底层知识有一定的了解，才能编写高效的 SQL 语句；而全自动 ORM 框架通过自动优化生成的 SQL 语句来提高性能，程序员无需进行优化。 学习成本：半自动 ORM 框架需要程序员手动编写 SQL 语句和映射配置，要求程序员具备较高的数据库和 SQL 知识；全自动 ORM 框架可以自动生成 SQL 语句和映射配置，程序员无需了解过多的数据库和 SQL 知识。 常见的半自动 ORM 框架包括 MyBatis 等；常见的全自动 ORM 框架包括 Hibernate、Spring Data JPA、MyBatis-Plus 等。 逆向工程 MyBatis 的逆向工程是一种自动化生成持久层代码和映射文件的工具，它可以根据数据库表结构和设置的参数生成对应的实体类、Mapper.xml 文件、Mapper 接口等代码文件，简化了开发者手动生成的过程。逆向工程使开发者可以快速地构建起 DAO 层，并快速上手进行业务开发。 MyBatis 的逆向工程有两种方式：通过 MyBatis Generator 插件实现和通过 Maven 插件实现。无论是哪种方式，逆向工程一般需要指定一些配置参数，例如数据库连接 URL、用户名、密码、要生成的表名、生成的文件路径等等。 总的来说，MyBatis 的逆向工程为程序员提供了一种方便快捷的方式，能够快速地生成持久层代码和映射文件，是半自动 ORM 思维像全自动发展的过程，提高程序员的开发效率。 **注意：逆向工程只能生成单表crud的操作，多表查询依然需要我们自己编写！** 逆向工程插件MyBatisX使用 MyBatisX 是一个 MyBatis 的代码生成插件，可以通过简单的配置和操作快速生成 MyBatis Mapper、pojo 类和 Mapper.xml 文件。下面是使用 MyBatisX 插件实现逆向工程的步骤： 安装插件： 使用 IntelliJ IDEA连接数据库 连接数据库 填写信息 展示库表 逆向工程使用 查看生成结果 逆向工程案例使用 1234567891011121314151617181920/*** @description 针对表【user】的数据库操作Mapper* @Entity com.atguigu.pojo.User*/public interface UserMapper &#123; int deleteByPrimaryKey(Long id); int insert(User record); int insertSelective(User record); User selectByPrimaryKey(Long id); int updateByPrimaryKeySelective(User record); int updateByPrimaryKey(User record);&#125; MyBatis总结 核心点 掌握目标 mybatis基础 使用流程, 参数输入,#{} ${},参数输出 mybatis多表 实体类设计,resultMap多表结果映射 mybatis动态语句 Mybatis动态语句概念, where , if , foreach标签 mybatis扩展 Mapper批量处理,分页插件,逆向工程 SpringMVC版本：6.0.6简化表述层开发框架 SpringMVC简介和体验介绍 https://docs.spring.io/spring-framework/reference/web/webmvc.html Spring Web MVC是基于Servlet API构建的原始Web框架，从一开始就包含在Spring Framework中。正式名称“Spring Web MVC”来自其源模块的名称（ spring-webmvc ），但它通常被称为“Spring MVC”。 在控制层框架历经Strust、WebWork、Strust2等诸多产品的历代更迭之后，目前业界普遍选择了SpringMVC作为Java EE项目表述层开发的首选方案。之所以能做到这一点，是因为SpringMVC具备如下显著优势： Spring 家族原生产品，与IOC容器等基础设施无缝对接 表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案 代码清新简洁，大幅度提升开发效率 内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可 性能卓著，尤其适合现代大型、超大型互联网项目要求 原生Servlet API开发代码片段 123456protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String userName = request.getParameter(&quot;userName&quot;); System.out.println(&quot;userName=&quot;+userName);&#125; 基于SpringMVC开发代码片段 12345678@RequestMapping(&quot;/user/login&quot;)public String login(@RequestParam(&quot;userName&quot;) String userName,Sting password)&#123; log.debug(&quot;userName=&quot;+userName); //调用业务即可 return &quot;result&quot;;&#125; 主要作用 SSM框架构建起单体项目的技术栈需求！其中的SpringMVC负责表述层（控制层）实现简化！ SpringMVC的作用主要覆盖的是表述层，例如： - 请求映射 - 数据输入 - 视图界面 - 请求分发 - 表单回显 - 会话控制 - 过滤拦截 - 异步交互 - 文件上传 - 文件下载 - 数据校验 - 类型转换 - 等等等 最终总结： 1. 简化前端参数接收( 形参列表 ) 2. 简化后端数据响应(返回值) 3. 以及其他…… 核心组件和调用流程理解 Spring MVC与许多其他Web框架一样，是围绕前端控制器模式设计的，其中中央 Servlet DispatcherServlet 做整体请求处理调度！ 除了DispatcherServletSpringMVC还会提供其他特殊的组件协作完成请求处理和响应呈现。 SpringMVC涉及组件理解： 1. DispatcherServlet : SpringMVC提供，我们需要使用web.xml配置使其生效，它是整个流程处理的核心，所有请求都经过它的处理和分发！[ CEO ] 2. HandlerMapping : SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它内部缓存handler(controller方法)和handler访问路径数据，被DispatcherServlet调用，用于查找路径对应的handler！[秘书] 3. HandlerAdapter : SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它可以处理请求参数和处理响应数据数据，每次DispatcherServlet都是通过handlerAdapter间接调用handler，他是handler和DispatcherServlet之间的适配器！[经理] 4. Handler : handler又称处理器，他是Controller类内部的方法简称，是由我们自己定义，用来接收参数，向后调用业务，最终返回响应结果！[打工人] 5. ViewResovler : SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效！视图解析器主要作用简化模版视图页面查找的，但是需要注意，前后端分离项目，后端只返回JSON数据，不返回页面，那就不需要视图解析器！所以，视图解析器，相对其他的组件不是必须的！[财务] 快速体验 体验场景需求 配置分析 DispatcherServlet，设置处理所有请求！ HandlerMapping,HandlerAdapter,Handler需要加入到IoC容器，供DS调用！ Handler自己声明（Controller）需要配置到HandlerMapping中供DS查找！ 准备项目 创建项目 springmvc-base-quick 注意：需要转成maven&#x2F;web程序！！ 导入依赖 123456789101112131415161718192021222324252627282930313233343536373839&lt;properties&gt; &lt;spring.version&gt;6.0.6&lt;/spring.version&gt; &lt;servlet.api&gt;9.1.0&lt;/servlet.api&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!-- springioc相关依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- web相关依赖 --&gt; &lt;!-- 在 pom.xml 中引入 Jakarta EE Web API 的依赖 --&gt; &lt;!-- 在 Spring Web MVC 6 中，Servlet API 迁移到了 Jakarta EE API，因此在配置 DispatcherServlet 时需要使用 Jakarta EE 提供的相应类库和命名空间。错误信息 “‘org.springframework.web.servlet.DispatcherServlet’ is not assignable to ‘javax.servlet.Servlet,jakarta.servlet.Servlet’” 表明你使用了旧版本的 Servlet API，没有更新到 Jakarta EE 规范。 --&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.platform&lt;/groupId&gt; &lt;artifactId&gt;jakarta.jakartaee-web-api&lt;/artifactId&gt; &lt;version&gt;$&#123;servlet.api&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- springwebmvc相关依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Controller声明 123456789101112131415161718@Controllerpublic class HelloController &#123; //handlers /** * handler就是controller内部的具体方法 * @RequestMapping(&quot;/springmvc/hello&quot;) 就是用来向handlerMapping中注册的方法注解! * @ResponseBody 代表向浏览器直接返回数据! */ @RequestMapping(&quot;/springmvc/hello&quot;) @ResponseBody public String hello()&#123; System.out.println(&quot;HelloController.hello&quot;); return &quot;hello springmvc!!&quot;; &#125;&#125; Spring MVC核心组件配置类 声明springmvc涉及组件信息的配置类 123456789101112131415161718192021222324//TODO: SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]//TODO: 导入handlerMapping和handlerAdapter的三种方式//1.自动导入handlerMapping和handlerAdapter [推荐]//2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载//3.使用@Bean方式配置handlerMapper和handlerAdapter@EnableWebMvc @Configuration@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;) //TODO: 进行controller扫//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer &#123; @Bean public HandlerMapping handlerMapping()&#123; return new RequestMappingHandlerMapping(); &#125; @Bean public HandlerAdapter handlerAdapter()&#123; return new RequestMappingHandlerAdapter(); &#125; &#125; SpringMVC环境搭建 对于使用基于 Java 的 Spring 配置的应用程序，建议这样做，如以下示例所示： 12345678910111213141516171819202122232425262728293031//TODO: SpringMVC提供的接口,是替代web.xml的方案,更方便实现完全注解方式ssm处理!//TODO: Springmvc框架会自动检查当前类的实现类,会自动加载 getRootConfigClasses / getServletConfigClasses 提供的配置类//TODO: getServletMappings 返回的地址 设置DispatherServlet对应处理的地址public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123;/** * 指定service / mapper层的配置类 */@Overrideprotected Class&lt;?&gt;[] getRootConfigClasses() &#123; return null;&#125;/** * 指定springmvc的配置类 * @return */@Overrideprotected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class&lt;?&gt;[] &#123; SpringMvcConfig.class &#125;;&#125;/** * 设置dispatcherServlet的处理路径! * 一般情况下为 / 代表处理所有请求! */@Overrideprotected String[] getServletMappings() &#123; return new String[] &#123; &quot;/&quot; &#125;;&#125;&#125; 启动测试 注意： tomcat应该是10+版本！方可支持 Jakarta EE API! SpringMVC接收数据访问路径设置 @RequestMapping注解的作用就是将请求的 URL 地址和处理请求的方式（handler方法）关联起来，建立映射关系。 SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的方法来处理这个请求。 精准路径匹配 在@RequestMapping注解指定 URL 地址时，不使用任何通配符，按照请求地址进行精确匹配。 1234567891011121314@Controllerpublic class UserController &#123; /** * 精准设置访问地址 /user/login */ @RequestMapping(value = &#123;&quot;/user/login&quot;&#125;) @ResponseBody public String login()&#123; System.out.println(&quot;UserController.login&quot;); return &quot;login success!!&quot;; &#125;&#125; 模糊路径匹配 在@RequestMapping注解指定 URL 地址时，通过使用通配符，匹配多个类似的地址。 12345678910111213141516171819@Controllerpublic class ProductController &#123; /** * 路径设置为 /product/* * /* 为单层任意字符串 /product/a /product/aaa 可以访问此handler * /product/a/a 不可以 * 路径设置为 /product/** * /** 为任意层任意字符串 /product/a /product/aaa 可以访问此handler * /product/a/a 也可以访问 */ @RequestMapping(&quot;/product/*&quot;) @ResponseBody public String show()&#123; System.out.println(&quot;ProductController.show&quot;); return &quot;product show!&quot;; &#125;&#125; 12345单层匹配和多层匹配：/*：只能匹配URL地址中的一层，如果想准确匹配两层，那么就写“/*/*”以此类推。/**：可以匹配URL地址中的多层。其中所谓的一层或多层是指一个URL地址字符串被“/”划分出来的各个层次这个知识点虽然对于@RequestMapping注解来说实用性不大，但是将来配置拦截器的时候也遵循这个规则。 类和方法级别区别 @RequestMapping 注解可以用于类级别和方法级别，它们之间的区别如下： 设置到类级别：@RequestMapping 注解可以设置在控制器类上，用于映射整个控制器的通用请求路径。这样，如果控制器中的多个方法都需要映射同一请求路径，就不需要在每个方法上都添加映射路径。 设置到方法级别：@RequestMapping 注解也可以单独设置在控制器方法上，用于更细粒度地映射请求路径和处理方法。当多个方法处理同一个路径的不同操作时，可以使用方法级别的 @RequestMapping 注解进行更精细的映射。 附带请求方式限制 HTTP 协议定义了八种请求方式，在 SpringMVC 中封装到了下面这个枚举类： 123public enum RequestMethod &#123;GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE&#125; 默认情况下：@RequestMapping(“&#x2F;logout”) 任何请求方式都可以访问！ 如果需要特定指定： 123456789101112131415@Controllerpublic class UserController &#123; /** * 精准设置访问地址 /user/login * method = RequestMethod.POST 可以指定单个或者多个请求方式! * 注意:违背请求方式会出现405异常! */ @RequestMapping(value = &#123;&quot;/user/login&quot;&#125; , method = RequestMethod.POST) @ResponseBody public String login()&#123; System.out.println(&quot;UserController.login&quot;); return &quot;login success!!&quot;; &#125;&#125; 进阶注解 还有 @RequestMapping 的 HTTP 方法特定快捷方式变体： @GetMapping @PostMapping @PutMapping @DeleteMapping @PatchMapping 123@RequestMapping(value=&quot;/login&quot;,method=RequestMethod.GET)||@GetMapping(value=&quot;/login&quot;) 注意：进阶注解只能添加到handler方法上，无法添加到类上！ 常见配置问题 出现原因：多个 handler 方法映射了同一个地址，导致 SpringMVC 在接收到这个地址的请求时该找哪个 handler 方法处理。 There is already ‘demo03MappingMethodHandler’ bean method com.atguigu.mvc.handler.Demo03MappingMethodHandler#empGet() mapped. 接收参数（重点）param 和 json参数比较 在 HTTP 请求中，我们可以选择不同的参数类型，如 param 类型和 JSON 类型。下面对这两种参数类型进行区别和对比： 参数编码： param 类型的参数会被编码为 ASCII 码。例如，假设 name=john doe，则会被编码为 name=john%20doe。而 JSON 类型的参数会被编码为 UTF-8。 参数顺序： param 类型的参数没有顺序限制。但是，JSON 类型的参数是有序的。JSON 采用键值对的形式进行传递，其中键值对是有序排列的。 数据类型： param 类型的参数仅支持字符串类型、数值类型和布尔类型等简单数据类型。而 JSON 类型的参数则支持更复杂的数据类型，如数组、对象等。 嵌套性： param 类型的参数不支持嵌套。但是，JSON 类型的参数支持嵌套，可以传递更为复杂的数据结构。 可读性： param 类型的参数格式比 JSON 类型的参数更加简单、易读。但是，JSON 格式在传递嵌套数据结构时更加清晰易懂。 总的来说，param 类型的参数适用于单一的数据传递，而 JSON 类型的参数则更适用于更复杂的数据结构传递。根据具体的业务需求，需要选择合适的参数类型。在实际开发中，常见的做法是：在 GET 请求中采用 param 类型的参数，而在 POST 请求中采用 JSON 类型的参数传递。 param参数接收 直接接值 客户端请求 handler接收参数 只要形参数名和类型与传递参数相同，即可自动接收! 1234567891011121314151617181920@Controller@RequestMapping(&quot;param&quot;)public class ParamController &#123; /** * 前端请求: http://localhost:8080/param/value?name=xx&amp;age=18 * * 可以利用形参列表,直接接收前端传递的param参数! * 要求: 参数名 = 形参名 * 类型相同 * 出现乱码正常，json接收具体解决！！ * @return 返回前端数据 */ @GetMapping(value=&quot;/value&quot;) @ResponseBody public String setupForm(String name,int age)&#123; System.out.println(&quot;name = &quot; + name + &quot;, age = &quot; + age); return name + age; &#125;&#125; @RequestParam注解 可以使用 `@RequestParam` 注释将 Servlet 请求参数（即查询参数或表单数据）绑定到控制器中的方法参数。 `@RequestParam`使用场景： - 指定绑定的请求参数名 - 要求请求参数必须传递 - 为请求参数提供默认值 基本用法： 12345678910111213/*** 前端请求: http://localhost:8080/param/data?name=xx&amp;stuAge=18* * 使用@RequestParam注解标记handler方法的形参* 指定形参对应的请求参数@RequestParam(请求参数名称)*/@GetMapping(value=&quot;/data&quot;)@ResponseBodypublic Object paramForm(@RequestParam(&quot;name&quot;) String name, @RequestParam(&quot;stuAge&quot;) int age)&#123; System.out.println(&quot;name = &quot; + name + &quot;, age = &quot; + age); return name+age;&#125; 默认情况下，使用此批注的方法参数是必需的，但您可以通过将 `@RequestParam` 批注的 `required` 标志设置为 `false`！ 如果没有没有设置非必须，也没有传递参数会报错 将参数设置非必须，并且设置默认值： 12345678@GetMapping(value=&quot;/data&quot;)@ResponseBodypublic Object paramForm(@RequestParam(&quot;name&quot;) String name, @RequestParam(value = &quot;stuAge&quot;,required = false,defaultValue = &quot;18&quot;) int age)&#123;System.out.println(&quot;name = &quot; + name + &quot;, age = &quot; + age);return name+age;&#125; 特殊场景接值 一名多值 多选框，提交的数据的时候一个key对应多个值，我们可以使用集合进行接收！ 1234567891011/*** 前端请求: http://localhost:8080/param/mul?hbs=吃&amp;hbs=喝** 一名多值,可以使用集合接收即可!但是需要使用@RequestParam注解指定*/@GetMapping(value=&quot;/mul&quot;)@ResponseBodypublic Object mulForm(@RequestParam List&lt;String&gt; hbs)&#123; System.out.println(&quot;hbs = &quot; + hbs); return hbs;&#125; 2. 实体接收 Spring MVC 是 Spring 框架提供的 Web 框架，它允许开发者使用实体对象来接收 HTTP 请求中的参数。通过这种方式，可以在方法内部直接使用对象的属性来访问请求参数，而不需要每个参数都写一遍。下面是一个使用实体对象接收参数的示例： 定义一个用于接收参数的实体类： 12345678public class User &#123;private String name;private int age = 18;// getter 和 setter 略&#125; 在控制器中，使用实体对象接收，示例代码如下： 123456789101112@Controller@RequestMapping(&quot;param&quot;)public class ParamController &#123; @RequestMapping(value = &quot;/user&quot;, method = RequestMethod.POST) @ResponseBody public String addUser(User user) &#123; // 在这里可以使用 user 对象的属性来接收请求参数 System.out.println(&quot;user = &quot; + user); return &quot;success&quot;; &#125;&#125; 在上述代码中，将请求参数name和age映射到实体类属性上！要求属性名必须等于参数名！否则无法映射！ 路径参数接收 路径传递参数是一种在 URL 路径中传递参数的方式。在 RESTful 的 Web 应用程序中，经常使用路径传递参数来表示资源的唯一标识符或更复杂的表示方式。而 Spring MVC 框架提供了 @PathVariable 注解来处理路径传递参数。 @PathVariable 注解允许将 URL 中的占位符映射到控制器方法中的参数。 例如，如果我们想将 /user/&#123;id&#125; 路径下的 &#123;id&#125; 映射到控制器方法的一个参数中，则可以使用 @PathVariable 注解来实现。 下面是一个使用 @PathVariable 注解处理路径传递参数的示例： 1234567891011121314/*** 动态路径设计: /user/&#123;动态部分&#125;/&#123;动态部分&#125; 动态部分使用&#123;&#125;包含即可! &#123;&#125;内部动态标识!* 形参列表取值: @PathVariable Long id 如果形参名 = &#123;动态标识&#125; 自动赋值!* @PathVariable(&quot;动态标识&quot;) Long id 如果形参名 != &#123;动态标识&#125; 可以通过指定动态标识赋值!** 访问测试: /param/user/1/root -&gt; id = 1 uname = root*/@GetMapping(&quot;/user/&#123;id&#125;/&#123;name&#125;&quot;)@ResponseBodypublic String getUser(@PathVariable Long id, @PathVariable(&quot;name&quot;) String uname) &#123; System.out.println(&quot;id = &quot; + id + &quot;, uname = &quot; + uname); return &quot;user_detail&quot;;&#125; json参数接收 前端传递 JSON 数据时，Spring MVC 框架可以使用 @RequestBody 注解来将 JSON 数据转换为 Java 对象。@RequestBody 注解表示当前方法参数的值应该从请求体中获取，并且需要指定 value 属性来指示请求体应该映射到哪个参数上。其使用方式和示例代码如下： 前端发送 JSON 数据的示例：（使用postman测试） 12345&#123; &quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 18, &quot;gender&quot;: &quot;男&quot;&#125; 2. 定义一个用于接收 JSON 数据的 Java 类，例如： 123456public class Person &#123; private String name; private int age; private String gender; // getter 和 setter 略&#125; 在控制器中，使用 @RequestBody 注解来接收 JSON 数据，并将其转换为 Java 对象，例如： 1234567@PostMapping(&quot;/person&quot;)@ResponseBodypublic String addPerson(@RequestBody Person person) &#123; // 在这里可以使用 person 对象来操作 JSON 数据中包含的属性 return &quot;success&quot;;&#125; 在上述代码中，`@RequestBody` 注解将请求体中的 JSON 数据映射到 `Person` 类型的 `person` 参数上，并将其作为一个对象来传递给 `addPerson()` 方法进行处理。 完善配置 问题： 不支持json数据类型处理 没有json类型处理的工具（jackson） 解决： springmvc handlerAdpater配置json转化器,配置类需要明确： 123456789101112131415//TODO: SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]//TODO: 导入handlerMapping和handlerAdapter的三种方式//1.自动导入handlerMapping和handlerAdapter [推荐]//2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载//3.使用@Bean方式配置handlerMapper和handlerAdapter@EnableWebMvc //json数据处理,必须使用此注解,因为他会加入json处理器@Configuration@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;) //TODO: 进行controller扫描//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer &#123;&#125; pom.xml 加入jackson依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.15.0&lt;/version&gt;&lt;/dependency&gt; @EnableWebMvc注解说明 @EnableWebMvc注解效果等同于在 XML 配置中，可以使用 &lt;mvc:annotation-driven&gt; 元素！我们来解析&lt;mvc:annotation-driven&gt;对应的解析工作！ 让我们来查看下&lt;mvc:annotation-driven&gt;具体的动作：handlerMapping加入到ioc容器；添加jackson转化器；handlerAdapter加入到ioc容器；具体添加jackson转化对象方法。 接收Cookie数据 可以使用 @CookieValue 注释将 HTTP Cookie 的值绑定到控制器中的方法参数。 考虑使用以下 cookie 的请求： 1JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84 下面的示例演示如何获取 cookie 值： 1234@GetMapping(&quot;/demo&quot;)public void handle(@CookieValue(&quot;JSESSIONID&quot;) String cookie) &#123; //...&#125; 接收请求头数据 可以使用 @RequestHeader 批注将请求标头绑定到控制器中的方法参数。 请考虑以下带有标头的请求： 123456Host localhost:8080Accept text/html,application/xhtml+xml,application/xml;q=0.9Accept-Language fr,en-gb;q=0.7,en;q=0.3Accept-Encoding gzip,deflateAccept-Charset ISO-8859-1,utf-8;q=0.7,*;q=0.7Keep-Alive 300 下面的示例获取 Accept-Encoding 和 Keep-Alive 标头的值： 123456@GetMapping(&quot;/demo&quot;)public void handle( @RequestHeader(&quot;Accept-Encoding&quot;) String encoding, @RequestHeader(&quot;Keep-Alive&quot;) long keepAlive) &#123; //...&#125; 原生Api对象操作 https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods/arguments.html 下表描述了支持的控制器方法参数 Controller method argument 控制器方法参数 Description jakarta.servlet.ServletRequest, jakarta.servlet.ServletResponse 请求&#x2F;响应对象 jakarta.servlet.http.HttpSession 强制存在会话。因此，这样的参数永远不会为 null 。 java.io.InputStream, java.io.Reader 用于访问由 Servlet API 公开的原始请求正文。 java.io.OutputStream, java.io.Writer 用于访问由 Servlet API 公开的原始响应正文。 @PathVariable 接收路径参数注解 @RequestParam 用于访问 Servlet 请求参数，包括多部分文件。参数值将转换为声明的方法参数类型。 @RequestHeader 用于访问请求标头。标头值将转换为声明的方法参数类型。 @CookieValue 用于访问Cookie。Cookie 值将转换为声明的方法参数类型。 @RequestBody 用于访问 HTTP 请求正文。正文内容通过使用 HttpMessageConverter 实现转换为声明的方法参数类型。 java.util.Map, org.springframework.ui.Model, org.springframework.ui.ModelMap 共享域对象，并在视图呈现过程中向模板公开。 Errors, BindingResult 验证和数据绑定中的错误信息获取对象！ 获取原生对象示例： 123456789101112/*** 如果想要获取请求或者响应对象,或者会话等,可以直接在形参列表传入,并且不分先后顺序!* 注意: 接收原生对象,并不影响参数接收!*/@GetMapping(&quot;api&quot;)@ResponseBodypublic String api(HttpSession session , HttpServletRequest request, HttpServletResponse response)&#123; String method = request.getMethod(); System.out.println(&quot;method = &quot; + method); return &quot;api&quot;;&#125; 共享域对象操作属性（共享）域作用回顾 在 JavaWeb 中，共享域指的是在 Servlet 中存储数据，以便在同一 Web 应用程序的多个组件中进行共享和访问。常见的共享域有四种：ServletContext、HttpSession、HttpServletRequest、PageContext。 ServletContext 共享域：ServletContext 对象可以在整个 Web 应用程序中共享数据，是最大的共享域。一般可以用于保存整个 Web 应用程序的全局配置信息，以及所有用户都共享的数据。在 ServletContext 中保存的数据是线程安全的。 HttpSession 共享域：HttpSession 对象可以在同一用户发出的多个请求之间共享数据，但只能在同一个会话中使用。比如，可以将用户登录状态保存在 HttpSession 中，让用户在多个页面间保持登录状态。 HttpServletRequest 共享域：HttpServletRequest 对象可以在同一个请求的多个处理器方法之间共享数据。比如，可以将请求的参数和属性存储在 HttpServletRequest 中，让处理器方法之间可以访问这些数据。 PageContext 共享域：PageContext 对象是在 JSP 页面Servlet 创建时自动创建的。它可以在 JSP 的各个作用域中共享数据，包括pageScope、requestScope、sessionScope、applicationScope 等作用域。 共享域的作用是提供了方便实用的方式在同一 Web 应用程序的多个组件之间传递数据，并且可以将数据保存在不同的共享域中，根据需要进行选择和使用。 Request级别属性（共享）域 使用 Model 类型的形参 12345678910111213@RequestMapping(&quot;/attr/request/model&quot;)@ResponseBodypublic String testAttrRequestModel( // 在形参位置声明Model类型变量，用于存储模型数据 Model model) &#123; // 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域 // 存入请求域这个动作也被称为暴露到请求域 model.addAttribute(&quot;requestScopeMessageModel&quot;,&quot;i am very happy[model]&quot;); return &quot;target&quot;;&#125; 使用 ModelMap 类型的形参 12345678910111213@RequestMapping(&quot;/attr/request/model/map&quot;)@ResponseBodypublic String testAttrRequestModelMap( // 在形参位置声明ModelMap类型变量，用于存储模型数据 ModelMap modelMap) &#123; // 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域 // 存入请求域这个动作也被称为暴露到请求域 modelMap.addAttribute(&quot;requestScopeMessageModelMap&quot;,&quot;i am very happy[model map]&quot;); return &quot;target&quot;;&#125; 使用 Map 类型的形参 12345678910111213@RequestMapping(&quot;/attr/request/map&quot;)@ResponseBodypublic String testAttrRequestMap( // 在形参位置声明Map类型变量，用于存储模型数据 Map&lt;String, Object&gt; map) &#123; // 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域 // 存入请求域这个动作也被称为暴露到请求域 map.put(&quot;requestScopeMessageMap&quot;, &quot;i am very happy[map]&quot;); return &quot;target&quot;;&#125; 使用原生 request 对象 1234567891011@RequestMapping(&quot;/attr/request/original&quot;)@ResponseBodypublic String testAttrOriginalRequest( // 拿到原生对象，就可以调用原生方法执行各种操作 HttpServletRequest request) &#123; request.setAttribute(&quot;requestScopeMessageOriginal&quot;, &quot;i am very happy[original]&quot;); return &quot;target&quot;;&#125; 使用 ModelAndView 对象 123456789101112@RequestMapping(&quot;/attr/request/mav&quot;)public ModelAndView testAttrByModelAndView() &#123; // 1.创建ModelAndView对象 ModelAndView modelAndView = new ModelAndView(); // 2.存入模型数据 modelAndView.addObject(&quot;requestScopeMessageMAV&quot;, &quot;i am very happy[mav]&quot;); // 3.设置视图名称 modelAndView.setViewName(&quot;target&quot;); return modelAndView;&#125; Session级别属性（共享）域123456@RequestMapping(&quot;/attr/session&quot;)@ResponseBodypublic String testAttrSession(HttpSession session) &#123; //直接对session对象操作,即对会话范围操作! return &quot;target&quot;;&#125; Application级别属性（共享）域 解释：springmvc会在初始化容器的时候，讲servletContext对象存储到ioc容器中！ 1234567891011@Autowiredprivate ServletContext servletContext;@RequestMapping(&quot;/attr/application&quot;)@ResponseBodypublic String attrApplication() &#123; servletContext.setAttribute(&quot;appScopeMsg&quot;, &quot;i am hungry...&quot;); return &quot;target&quot;;&#125; SpringMVC响应数据handler方法分析 理解handler方法的作用和组成： 123456789101112131415161718/** * TODO: 一个controller的方法是控制层的一个处理器,我们称为handler * TODO: handler需要使用@RequestMapping/@GetMapping系列,声明路径,在HandlerMapping中注册,供DS查找! * TODO: handler作用总结: * 1.接收请求参数(param,json,pathVariable,共享域等) * 2.调用业务逻辑 * 3.响应前端数据(页面（不讲解模版页面跳转）,json,转发和重定向等) * TODO: handler如何处理呢 * 1.接收参数: handler(形参列表: 主要的作用就是用来接收参数) * 2.调用业务: &#123; 方法体 可以向后调用业务方法 service.xx() &#125; * 3.响应数据: return 返回结果,可以快速响应前端数据 */@GetMappingpublic Object handler(简化请求参数接收)&#123; 调用业务方法 返回的结果 （页面跳转，返回数据（json）） return 简化响应前端数据;&#125; 总结： 请求数据接收，我们都是通过handler的形参列表；前端数据响应，我们都是通过handler的return关键字快速处理！springmvc简化了参数接收和响应！ 页面跳转控制快速返回模板视图 开发模式回顾 在 Web 开发中，有两种主要的开发模式：前后端分离和混合开发。 前后端分离模式：[重点] 指将前端的界面和后端的业务逻辑通过接口分离开发的一种方式。开发人员使用不同的技术栈和框架，前端开发人员主要负责页面的呈现和用户交互，后端开发人员主要负责业务逻辑和数据存储。前后端通信通过 API 接口完成，数据格式一般使用 JSON 或 XML。前后端分离模式可以提高开发效率，同时也有助于代码重用和维护。 混合开发模式： 指将前端和后端的代码集成在同一个项目中，共享相同的技术栈和框架。这种模式在小型项目中比较常见，可以减少学习成本和部署难度。但是，在大型项目中，这种模式会导致代码耦合性很高，维护和升级难度较大。 对于混合开发，我们就需要使用动态页面技术，动态展示Java的共享域数据！！ jsp技术了解 JSP（JavaServer Pages）是一种动态网页开发技术，它是由 Sun 公司提出的一种基于 Java 技术的 Web 页面制作技术，可以在 HTML 文件中嵌入 Java 代码，使得生成动态内容的编写更加简单。 JSP 最主要的作用是生成动态页面。它允许将 Java 代码嵌入到 HTML 页面中，以便使用 Java 进行数据库查询、处理表单数据和生成 HTML 等动态内容。另外，JSP 还可以与 Servlet 结合使用，实现更加复杂的 Web 应用程序开发。 JSP 的主要特点包括： 简单：JSP 通过将 Java 代码嵌入到 HTML 页面中，使得生成动态内容的编写更加简单。 高效：JSP 首次运行时会被转换为 Servlet，然后编译为字节码，从而可以启用 Just-in-Time（JIT）编译器，实现更高效的运行。 多样化：JSP 支持多种标准标签库，包括 JSTL（JavaServer Pages 标准标签库）、EL（表达式语言）等，可以帮助开发人员更加方便的处理常见的 Web 开发需求。 总之，JSP 是一种简单高效、多样化的动态网页开发技术，它可以方便地生成动态页面和与 Servlet 结合使用，是 Java Web 开发中常用的技术之一。 准备jsp页面和依赖 pom.xml依赖 123456&lt;!-- jsp需要依赖! jstl--&gt;&lt;dependency&gt;&lt;groupId&gt;jakarta.servlet.jsp.jstl&lt;/groupId&gt;&lt;artifactId&gt;jakarta.servlet.jsp.jstl-api&lt;/artifactId&gt;&lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt; jsp页面创建 建议位置：/WEB-INF/下，避免外部直接访问！ 位置：/WEB-INF/views/home.jsp 1234567891011&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 可以获取共享域的数据,动态展示! jsp== 后台vue --&gt; $&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 快速响应模版页面 配置jsp视图解析器 1234567891011121314@EnableWebMvc //json数据处理,必须使用此注解,因为他会加入json处理器@Configuration@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;) //TODO: 进行controller扫描//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer &#123;//配置jsp对应的视图解析器@Overridepublic void configureViewResolvers(ViewResolverRegistry registry) &#123; //快速配置jsp模板语言对应的 registry.jsp(&quot;/WEB-INF/views/&quot;,&quot;.jsp&quot;);&#125;&#125; handler返回视图 12345678910111213141516/*** 跳转到提交文件页面 /save/jump* * 如果要返回jsp页面!* 1.方法返回值改成字符串类型* 2.返回逻辑视图名即可 * &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;/&gt;* + 逻辑视图名 +* &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;*/@GetMapping(&quot;jump&quot;)public String jumpJsp(Model model)&#123; System.out.println(&quot;FileController.jumpJsp&quot;); model.addAttribute(&quot;msg&quot;,&quot;request data!!&quot;); return &quot;home&quot;;&#125; 转发和重定向 在 Spring MVC 中，Handler 方法返回值来实现快速转发，可以使用 redirect 或者 forward 关键字来实现重定向。 12345678910111213@RequestMapping(&quot;/redirect-demo&quot;)public String redirectDemo() &#123; // 重定向到 /demo 路径 return &quot;redirect:/demo&quot;;&#125;@RequestMapping(&quot;/forward-demo&quot;)public String forwardDemo() &#123; // 转发到 /demo 路径 return &quot;forward:/demo&quot;;&#125;//注意： 转发和重定向到项目下资源路径都是相同，都不需要添加项目根路径！填写项目下路径即可！ 总结： 将方法的返回值，设置String类型 转发使用forward关键字，重定向使用redirect关键字 关键字: &#x2F;路径 注意：如果是项目下的资源，转发和重定向都一样都是项目下路径！都不需要添加项目根路径！ 返回JSON数据（重点）前置准备 导入jackson依赖 @ResponseBody 方法上使用@ResponseBody 可以在方法上使用 @ResponseBody注解，用于将方法返回的对象序列化为 JSON 或 XML 格式的数据，并发送给客户端。在前后端分离的项目中使用！ 测试方法： 123456@GetMapping(&quot;/accounts/&#123;id&#125;&quot;)@ResponseBodypublic Object handle() &#123; // ... return obj;&#125; 具体来说，@ResponseBody 注解可以用来标识方法或者方法返回值，表示方法的返回值是要直接返回给客户端的数据，而不是由视图解析器来解析并渲染生成响应体（viewResolver没用）。 类上使用@ResponseBody 如果类中每个方法上都标记了 @ResponseBody 注解，那么这些注解就可以提取到类上。 1234@ResponseBody //responseBody可以添加到类上,代表默认类中的所有方法都生效!@Controller@RequestMapping(&quot;param&quot;)public class ParamController &#123; @RestController 类上的 @ResponseBody 注解可以和 @Controller 注解合并为 @RestController 注解。所以使用了 @RestController 注解就相当于给类中的每个方法都加了 @ResponseBody 注解。 返回静态资源处理 静态资源概念 资源本身已经是可以直接拿到浏览器上使用的程度了，不需要在服务器端做任何运算、处理。典型的静态资源包括： 纯HTML文件 图片 CSS文件 JavaScript文件 …… 静态资源访问和问题解决 12345678910111213141516171819@EnableWebMvc //json数据处理,必须使用此注解,因为他会加入json处理器@Configuration@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;) //TODO: 进行controller扫描//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer &#123; //配置jsp对应的视图解析器 @Override public void configureViewResolvers(ViewResolverRegistry registry) &#123; //快速配置jsp模板语言对应的 registry.jsp(&quot;/WEB-INF/views/&quot;,&quot;.jsp&quot;); &#125; //开启静态资源处理 &lt;mvc:default-servlet-handler/&gt; @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; configurer.enable(); &#125;&#125; RESTFul风格设计和实战RESTFul风格概述RESTFul风格简介 RESTful（Representational State Transfer）是一种软件架构风格，用于设计网络应用程序和服务之间的通信。它是一种基于标准 HTTP 方法的简单和轻量级的通信协议，广泛应用于现代的Web服务开发。 通过遵循 RESTful 架构的设计原则，可以构建出易于理解、可扩展、松耦合和可重用的 Web 服务。RESTful API 的特点是简单、清晰，并且易于使用和理解，它们使用标准的 HTTP 方法和状态码进行通信，不需要额外的协议和中间件。 总而言之，RESTful 是一种基于 HTTP 和标准化的设计原则的软件架构风格，用于设计和实现可靠、可扩展和易于集成的 Web 服务和应用程序！ 学习RESTful设计原则可以帮助我们更好去设计HTTP协议的API接口！！ RESTFul风格特点 每一个URI代表1种资源（URI 是名词）； 客户端使用GET、POST、PUT、DELETE 4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源； 资源的表现形式是XML或者JSON； 客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。 RESTFul风格设计规范 HTTP协议请求方式要求 REST 风格主张在项目设计、开发过程中，具体的操作符合HTTP协议定义的请求方式的语义。 操作 请求方式 查询操作 GET 保存操作 POST 删除操作 DELETE 更新操作 PUT URL路径风格要求 REST风格下每个资源都应该有一个唯一的标识符，例如一个 URI（统一资源标识符）或者一个 URL（统一资源定位符）。资源的标识符应该能明确地说明该资源的信息，同时也应该是可被理解和解释的！ 使用URL+请求方式确定具体的动作，他也是一种标准的HTTP协议请求！ 操作 传统风格 REST 风格 保存 &#x2F;CRUD&#x2F;saveEmp URL 地址：&#x2F;CRUD&#x2F;emp 请求方式：POST 删除 &#x2F;CRUD&#x2F;removeEmp?empId&#x3D;2 URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2 请求方式：DELETE 更新 &#x2F;CRUD&#x2F;updateEmp URL 地址：&#x2F;CRUD&#x2F;emp 请求方式：PUT 查询 &#x2F;CRUD&#x2F;editEmp?empId&#x3D;2 URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2 请求方式：GET 总结 根据接口的具体动作，选择具体的HTTP协议请求方式 路径设计从原来携带动标识，改成名词，对应资源的唯一标识即可！ RESTFul风格好处1. 含蓄，安全 使用问号键值对的方式给服务器传递数据太明显，容易被人利用来对系统进行破坏。使用 REST 风格携带数据不再需要明显的暴露数据的名称。 2. 风格统一 URL 地址整体格式统一，从前到后始终都使用斜杠划分各个单词，用简单一致的格式表达语义。 3. 无状态 在调用一个接口（访问、操作资源）的时候，可以不用考虑上下文，不用考虑当前状态，极大的降低了系统设计的复杂度。 4. 严谨，规范 严格按照 HTTP1.1 协议中定义的请求方式本身的语义进行操作。 5. 简洁，优雅 过去做增删改查操作需要设计4个不同的URL，现在一个就够了。 6. 丰富的语义 通过 URL 地址就可以知道资源之间的关系。它能够把一句话中的很多单词用斜杠连起来，反过来说就是可以在 URL 地址中用一句话来充分表达语义。 RESTFul风格实战需求分析 数据结构： User {id 唯一标识,name 用户名，age 用户年龄} 功能分析 用户数据分页展示功能（条件：page 页数 默认1，size 每页数量 默认 10） 保存用户功能 根据用户id查询用户详情功能 根据用户id更新用户数据功能 根据用户id删除用户数据功能 多条件模糊查询用户功能（条件：keyword 模糊关键字，page 页数 默认1，size 每页数量 默认 10） RESTFul风格接口设计 接口设计 功能 接口和请求方式 请求参数 返回值 分页查询 GET &#x2F;user page&#x3D;1&amp;size&#x3D;10 { 响应数据 } 用户添加 POST &#x2F;user { user 数据 } {响应数据} 用户详情 GET &#x2F;user&#x2F;1 路径参数 {响应数据} 用户更新 PUT &#x2F;user { user 更新数据} {响应数据} 用户删除 DELETE &#x2F;user&#x2F;1 路径参数 {响应数据} 条件模糊 GET &#x2F;user&#x2F;search page&#x3D;1&amp;size&#x3D;10&amp;keywork&#x3D;关键字 {响应数据} 问题讨论 为什么查询用户详情，就使用路径传递参数，多条件模糊查询，就使用请求参数传递？ 误区：restful风格下，不是所有请求参数都是路径传递！可以使用其他方式传递！ 在 RESTful API 的设计中，路径和请求参数和请求体都是用来向服务器传递信息的方式。 对于查询用户详情，使用路径传递参数是因为这是一个单一资源的查询，即查询一条用户记录。使用路径参数可以明确指定所请求的资源，便于服务器定位并返回对应的资源，也符合 RESTful 风格的要求。 而对于多条件模糊查询，使用请求参数传递参数是因为这是一个资源集合的查询，即查询多条用户记录。使用请求参数可以通过组合不同参数来限制查询结果，路径参数的组合和排列可能会很多，不如使用请求参数更加灵活和简洁。 此外，还有一些通用的原则可以遵循： 路径参数应该用于指定资源的唯一标识或者 ID，而请求参数应该用于指定查询条件或者操作参数。 请求参数应该限制在 10 个以内，过多的请求参数可能导致接口难以维护和使用。 对于敏感信息，最好使用 POST 和请求体来传递参数。 后台接口实现 准备用户实体类， 准备用户Controller: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/*** projectName: com.atguigu.controller** description: 用户模块的控制器*/@RequestMapping(&quot;user&quot;)@RestControllerpublic class UserController &#123; /** * 模拟分页查询业务接口 */ @GetMapping public Object queryPage(@RequestParam(name = &quot;page&quot;,required = false,defaultValue = &quot;1&quot;)int page, @RequestParam(name = &quot;size&quot;,required = false,defaultValue = &quot;10&quot;)int size)&#123; System.out.println(&quot;page = &quot; + page + &quot;, size = &quot; + size); System.out.println(&quot;分页查询业务!&quot;); return &quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;; &#125; /** * 模拟用户保存业务接口 */ @PostMapping public Object saveUser(@RequestBody User user)&#123; System.out.println(&quot;user = &quot; + user); System.out.println(&quot;用户保存业务!&quot;); return &quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;; &#125; /** * 模拟用户详情业务接口 */ @PostMapping(&quot;/&#123;id&#125;&quot;) public Object detailUser(@PathVariable Integer id)&#123; System.out.println(&quot;id = &quot; + id); System.out.println(&quot;用户详情业务!&quot;); return &quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;; &#125; /** * 模拟用户更新业务接口 */ @PutMapping public Object updateUser(@RequestBody User user)&#123; System.out.println(&quot;user = &quot; + user); System.out.println(&quot;用户更新业务!&quot;); return &quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;; &#125; /** * 模拟条件分页查询业务接口 */ @GetMapping(&quot;search&quot;) public Object queryPage(@RequestParam(name = &quot;page&quot;,required = false,defaultValue = &quot;1&quot;)int page, @RequestParam(name = &quot;size&quot;,required = false,defaultValue = &quot;10&quot;)int size, @RequestParam(name = &quot;keyword&quot;,required= false)String keyword)&#123; System.out.println(&quot;page = &quot; + page + &quot;, size = &quot; + size + &quot;, keyword = &quot; + keyword); System.out.println(&quot;条件分页查询业务!&quot;); return &quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;; &#125;&#125; SpringMVC其他扩展全局异常处理机制异常处理两种方式 开发过程中是不可避免地会出现各种异常情况的，例如网络连接异常、数据格式异常、空指针异常等等。异常的出现可能导致程序的运行出现问题，甚至直接导致程序崩溃。因此，在开发过程中，合理处理异常、避免异常产生、以及对异常进行有效的调试是非常重要的。 对于异常的处理，一般分为两种方式： 编程式异常处理：是指在代码中显式地编写处理异常的逻辑。它通常涉及到对异常类型的检测及其处理，例如使用 try-catch 块来捕获异常，然后在 catch 块中编写特定的处理代码，或者在 finally 块中执行一些清理操作。在编程式异常处理中，开发人员需要显式地进行异常处理，异常处理代码混杂在业务代码中，导致代码可读性较差。 声明式异常处理：则是将异常处理的逻辑从具体的业务逻辑中分离出来，通过配置等方式进行统一的管理和处理。在声明式异常处理中，开发人员只需要为方法或类标注相应的注解（如 @Throws 或 @ExceptionHandler），就可以处理特定类型的异常。相较于编程式异常处理，声明式异常处理可以使代码更加简洁、易于维护和扩展。 站在宏观角度来看待声明式事务处理： 整个项目从架构这个层面设计的异常处理的统一机制和规范。 一个项目中会包含很多个模块，各个模块需要分工完成。如果张三负责的模块按照 A 方案处理异常，李四负责的模块按照 B 方案处理异常……各个模块处理异常的思路、代码、命名细节都不一样，那么就会让整个项目非常混乱。 使用声明式异常处理，可以统一项目处理异常思路，项目更加清晰明了！ 基于注解异常声明异常处理 声明异常处理控制器类 异常处理控制类，统一定义异常处理handler方法！ 123456789101112131415/*** projectName: com.atguigu.execptionhandler* * description: 全局异常处理器,内部可以定义异常处理Handler!*//*** @RestControllerAdvice = @ControllerAdvice + @ResponseBody* @ControllerAdvice 代表当前类的异常处理controller! */@RestControllerAdvicepublic class GlobalExceptionHandler &#123;&#125; 声明异常处理hander方法 异常处理handler方法和普通的handler方法参数接收和响应都一致！ 只不过异常处理handler方法要映射异常，发生对应的异常会调用！ 普通的handler方法要使用@RequestMapping注解映射路径，发生对应的路径调用！ 123456789101112131415161718192021222324252627282930313233343536/*** 异常处理handler * @ExceptionHandler(HttpMessageNotReadableException.class) * 该注解标记异常处理Handler,并且指定发生异常调用该方法!* * * @param e 获取异常对象!* @return 返回handler处理结果!*/@ExceptionHandler(HttpMessageNotReadableException.class)public Object handlerJsonDateException(HttpMessageNotReadableException e)&#123; return null;&#125;/*** 当发生空指针异常会触发此方法!* @param e* @return*/@ExceptionHandler(NullPointerException.class)public Object handlerNullException(NullPointerException e)&#123; return null;&#125;/*** 所有异常都会触发此方法!但是如果有具体的异常处理Handler! * 具体异常处理Handler优先级更高!* 例如: 发生NullPointerException异常!* 会触发handlerNullException方法,不会触发handlerException方法!* @param e* @return*/@ExceptionHandler(Exception.class)public Object handlerException(Exception e)&#123; return null;&#125; 配置文件扫描控制器类配置 确保异常处理控制类被扫描 12&lt;!-- 扫描controller对应的包,将handler加入到ioc--&gt;@ComponentScan(basePackages = &#123;&quot;com.atguigu.controller&quot;,&quot;com.atguigu.exceptionhandler&quot;&#125;) 拦截器使用拦截器概念 拦截器 Springmvc VS 过滤器 javaWeb： 相似点 拦截：必须先把请求拦住，才能执行后续操作 过滤：拦截器或过滤器存在的意义就是对请求进行统一处理 放行：对请求执行了必要操作后，放请求过去，让它访问原本想要访问的资源 不同点 工作平台不同 过滤器工作在 Servlet 容器中 拦截器工作在 SpringMVC 的基础上 拦截的范围 过滤器：能够拦截到的最大范围是整个 Web 应用 拦截器：能够拦截到的最大范围是整个 SpringMVC 负责的请求 IOC 容器支持 过滤器：想得到 IOC 容器需要调用专门的工具方法，是间接的 拦截器：它自己就在 IOC 容器中，所以可以直接从 IOC 容器中装配组件，也就是可以直接得到 IOC 容器的支持 选择： 功能需要如果用 SpringMVC 的拦截器能够实现，就不使用过滤器。 拦截器使用 创建拦截器类 12345678910111213141516171819202122232425262728public class Process01Interceptor implements HandlerInterceptor &#123; // if( ! preHandler())&#123;return;&#125; // 在处理请求的目标 handler 方法前执行 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;request = &quot; + request + &quot;, response = &quot; + response + &quot;, handler = &quot; + handler); System.out.println(&quot;Process01Interceptor.preHandle&quot;); // 返回true：放行 // 返回false：不放行 return true; &#125; // 在目标 handler 方法之后，handler报错不执行! @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;request = &quot; + request + &quot;, response = &quot; + response + &quot;, handler = &quot; + handler + &quot;, modelAndView = &quot; + modelAndView); System.out.println(&quot;Process01Interceptor.postHandle&quot;); &#125; // 渲染视图之后执行(最后),一定执行! @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;request = &quot; + request + &quot;, response = &quot; + response + &quot;, handler = &quot; + handler + &quot;, ex = &quot; + ex); System.out.println(&quot;Process01Interceptor.afterCompletion&quot;); &#125;&#125; 修改配置类添加拦截器 12345678910111213141516171819202122232425262728@EnableWebMvc //json数据处理,必须使用此注解,因为他会加入json处理器@Configuration@ComponentScan(basePackages = &#123;&quot;com.atguigu.controller&quot;,&quot;com.atguigu.exceptionhandler&quot;&#125;) //TODO: 进行controller扫描//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer &#123; //配置jsp对应的视图解析器 @Override public void configureViewResolvers(ViewResolverRegistry registry) &#123; //快速配置jsp模板语言对应的 registry.jsp(&quot;/WEB-INF/views/&quot;,&quot;.jsp&quot;); &#125; //开启静态资源处理 &lt;mvc:default-servlet-handler/&gt; @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; configurer.enable(); &#125; //添加拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; //将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求 registry.addInterceptor(new Process01Interceptor()); &#125;&#125; 配置详解 默认拦截全部 123456@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123; //将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求 registry.addInterceptor(new Process01Interceptor());&#125; 2. 精准配置 123456789101112@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123; //将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求 registry.addInterceptor(new Process01Interceptor()); //精准匹配,设置拦截器处理指定请求 路径可以设置一个或者多个,为项目下路径即可 //addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径 //也支持 /* 和 /** 模糊路径。 * 任意一层字符串 ** 任意层 任意字符串 registry.addInterceptor(new Process01Interceptor()).addPathPatterns(&quot;/common/request/one&quot;,&quot;/common/request/tow&quot;);&#125; 3. 排除配置 12345678910111213141516171819//添加拦截器@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123; //将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求 registry.addInterceptor(new Process01Interceptor()); //精准匹配,设置拦截器处理指定请求 路径可以设置一个或者多个,为项目下路径即可 //addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径 registry.addInterceptor(new Process01Interceptor()).addPathPatterns(&quot;/common/request/one&quot;,&quot;/common/request/tow&quot;); //排除匹配,排除应该在匹配的范围内排除 //addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径 //excludePathPatterns(&quot;/common/request/tow&quot;); 排除路径,排除应该在拦截的范围内 registry.addInterceptor(new Process01Interceptor()) .addPathPatterns(&quot;/common/request/one&quot;,&quot;/common/request/tow&quot;) .excludePathPatterns(&quot;/common/request/tow&quot;);&#125; 多个拦截器执行顺序 preHandle() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置顺序调用各个 preHandle() 方法。 postHandle() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置相反的顺序调用各个 postHandle() 方法。 afterCompletion() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置相反的顺序调用各个 afterCompletion() 方法。 参数校验 在 Web 应用三层架构体系中，表述层负责接收浏览器提交的数据，业务逻辑层负责数据的处理。为了能够让业务逻辑层基于正确的数据进行处理，我们需要在表述层对数据进行检查，将错误的数据隔绝在业务逻辑层之外。 校验概述 JSR 303 是 Java 为 Bean 数据合法性校验提供的标准框架，它已经包含在 JavaEE 6.0 标准中。JSR 303 通过在 Bean 属性上标注类似于 @NotNull、@Max 等标准的注解指定校验规则，并通过标准的验证接口对Bean进行验证。 注解 规则 @Null 标注值必须为 null @NotNull 标注值不可为 null @AssertTrue 标注值必须为 true @AssertFalse 标注值必须为 false @Min(value) 标注值必须大于或等于 value @Max(value) 标注值必须小于或等于 value @DecimalMin(value) 标注值必须大于或等于 value @DecimalMax(value) 标注值必须小于或等于 value @Size(max,min) 标注值大小必须在 max 和 min 限定的范围内 @Digits(integer,fratction) 标注值值必须是一个数字，且必须在可接受的范围内 @Past 标注值只能用于日期型，且必须是过去的日期 @Future 标注值只能用于日期型，且必须是将来的日期 @Pattern(value) 标注值必须符合指定的正则表达式 JSR 303 只是一套标准，需要提供其实现才可以使用。Hibernate Validator 是 JSR 303 的一个参考实现，除支持所有标准的校验注解外，它还支持以下的扩展注解： 注解 规则 @Email 标注值必须是格式正确的 Email 地址 @Length 标注值字符串大小必须在指定的范围内 @NotEmpty 标注值字符串不能是空字符串 @Range 标注值必须在指定的范围内 Spring 4.0 版本已经拥有自己独立的数据校验框架，同时支持 JSR 303 标准的校验框架。Spring 在进行数据绑定时，可同时调用校验框架完成数据校验工作。在SpringMVC 中，可直接通过注解驱动 @EnableWebMvc 的方式进行数据校验。Spring 的 LocalValidatorFactoryBean 既实现了 Spring 的 Validator 接口，也实现了 JSR 303 的 Validator 接口。只要在Spring容器中定义了一个LocalValidatorFactoryBean，即可将其注入到需要数据校验的 Bean中。Spring本身并没有提供JSR 303的实现，所以必须将JSR 303的实现者的jar包放到类路径下。 配置 @EnableWebMvc后，SpringMVC 会默认装配好一个 LocalValidatorFactoryBean，通过在处理方法的入参上标注 @Validated 注解即可让 SpringMVC 在完成数据绑定后执行数据校验的工作。 操作演示 导入依赖 123456789101112131415161718192021&lt;!-- 校验注解 --&gt;&lt;dependency&gt; &lt;groupId&gt;jakarta.platform&lt;/groupId&gt; &lt;artifactId&gt;jakarta.jakartaee-web-api&lt;/artifactId&gt; &lt;version&gt;9.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; &lt;!-- 校验注解实现--&gt; &lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;8.0.0.Final&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator-annotation-processor --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator-annotation-processor&lt;/artifactId&gt; &lt;version&gt;8.0.0.Final&lt;/version&gt;&lt;/dependency&gt; - 应用校验注解 1234567891011121314151617/** * projectName: com.atguigu.pojo */public class User &#123; //age 1 &lt;= age &lt; = 150 @Min(10) private int age; //name 3 &lt;= name.length &lt;= 6 @Length(min = 3,max = 10) private String name; //email 邮箱格式 @Email private String email;&#125; - handler标记和绑定错误收集 12345678910111213141516171819202122@RestController@RequestMapping(&quot;user&quot;)public class UserController &#123; /** * @Validated 代表应用校验注解! 必须添加! */ @PostMapping(&quot;save&quot;) public Object save(@Validated @RequestBody User user, //在实体类参数和 BindingResult 之间不能有任何其他参数, BindingResult可以接受错误信息,避免信息抛出! BindingResult result)&#123; //判断是否有信息绑定错误! 有可以自行处理! if (result.hasErrors())&#123; System.out.println(&quot;错误&quot;); String errorMsg = result.getFieldError().toString(); return errorMsg; &#125; //没有,正常处理业务即可 System.out.println(&quot;正常&quot;); return user; &#125;&#125; 易混总结 @NotNull、@NotEmpty、@NotBlank 都是用于在数据校验中检查字段值是否为空的注解，但是它们的用法和校验规则有所不同。 @NotNull (包装类型不为null) @NotNull 注解是 JSR 303 规范中定义的注解，当被标注的字段值为 null 时，会认为校验失败而抛出异常。该注解不能用于字符串类型的校验，若要对字符串进行校验，应该使用 @NotBlank 或 @NotEmpty 注解。 @NotEmpty (集合类型长度大于0) @NotEmpty 注解同样是 JSR 303 规范中定义的注解，对于 CharSequence、Collection、Map 或者数组对象类型的属性进行校验，校验时会检查该属性是否为 Null 或者 size()&#x3D;&#x3D;0，如果是的话就会校验失败。但是对于其他类型的属性，该注解无效。需要注意的是只校验空格前后的字符串，如果该字符串中间只有空格，不会被认为是空字符串，校验不会失败。 @NotBlank （字符串，不为null，切不为” “字符串） @NotBlank 注解是 Hibernate Validator 附加的注解，对于字符串类型的属性进行校验，校验时会检查该属性是否为 Null 或 “” 或者只包含空格，如果是的话就会校验失败。需要注意的是，@NotBlank 注解只能用于字符串类型的校验。 总之，这三种注解都是用于校验字段值是否为空的注解，但是其校验规则和用法有所不同。在进行数据校验时，需要根据具体情况选择合适的注解进行校验。 SpringMVC总结 核心点 掌握目标 springmvc框架 主要作用、核心组件、调用流程 简化参数接收 路径设计、参数接收、请求头接收、cookie接收 简化数据响应 模板页面、转发和重定向、JSON数据、静态资源 restful风格设计 主要作用、具体规范、请求方式和请求参数选择 功能扩展 全局异常处理、拦截器、参数校验注解 SSM整合实战（略）SpringBoot版本：3.0.5全新特性，快速整合掌握 SpringBoot3介绍SpringBoot3简介 到目前为止，你已经学习了多种配置Spring程序的方式。但是无论使用XML、注解、Java配置类还是他们的混合用法，你都会觉得配置文件过于复杂和繁琐，让人头疼！ SpringBoot 帮我们简单、快速地创建一个独立的、生产级别的 Spring 应用（说明：SpringBoot底层是Spring），大多数 SpringBoot 应用只需要编写少量配置即可快速整合 Spring 平台以及第三方技术！ SpringBoot的主要目标是： 为所有 Spring 开发提供更快速、可广泛访问的入门体验。 开箱即用，设置合理的默认值，但是也可以根据需求进行适当的调整。 提供一系列大型项目通用的非功能性程序（如嵌入式服务器、安全性、指标、运行检查等）。 约定大于配置，基本不需要主动编写配置类、也不需要 XML 配置文件。 总结：简化开发，简化配置，简化整合，简化部署，简化监控，简化运维。 快速入门 场景：浏览器发送**&#x2F;hello**请求，返回”Hello,Spring Boot 3!“ 开发步骤 创建Maven工程 添加依赖(springboot父工程依赖 , web启动器依赖) 编写启动引导类(springboot项目运行的入口) 编写处理器Controller 启动项目 创建项目 添加依赖 3.1 添加父工程坐标 SpringBoot可以帮我们方便的管理项目依赖 , 在Spring Boot提供了一个名为spring-boot-starter-parent的工程，里面已经对各种常用依赖的版本进行了管理，我们的项目需要以这个项目为父工程，这样我们就不用操心依赖的版本问题了，需要什么依赖，直接引入坐标(不需要添加版本)即可！ 123456&lt;!--所有springboot项目都必须继承自 spring-boot-starter-parent--&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt;&lt;/parent&gt; 3.2 添加web启动器 为了让Spring Boot帮我们完成各种自动配置，我们必须引入Spring Boot提供的**自动配置依赖**，我们称为**启动器**。因为我们是web项目，这里我们引入web启动器，在 pom.xml 文件中加入如下依赖： 1234567&lt;dependencies&gt;&lt;!--web开发的场景启动器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建启动类 创建package：com.atguigu 创建启动类：MainApplication 12345678910111213141516171819202122232425package com.atguigu;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/*** @SpringBootApplication是一个特殊的注解，用于标识一个Spring Boot应用程序的入口类。它的主要作用是将三个常用注解组合在一起，简化了配置的过程。** 具体而言，@SpringBootApplication注解包含以下三个注解的功能：* @Configuration：将该类标识为应用程序的配置类。它允许使用Java代码定义和配置Bean。* @EnableAutoConfiguration：启用Spring Boot的自动配置机制。它根据项目的依赖项自动配置Spring应用程序的行为。自动配置根据类路径、注解和配置属性等条件来决定要使用的功能和配置。* @ComponentScan：自动扫描并加载应用程序中的组件，如控制器、服务、存储库等。它默认扫描@SpringBootApplication注解所在类的包及其子包中的组件。** 使用@SpringBootApplication注解，可以将上述三个注解的功能集中在一个注解上，简化了配置文件的编写和组件的加载和扫描过程。它是Spring Boot应用程序的入口点，标识了应用程序的主类，* 并告诉Spring Boot在启动时应如何配置和加载应用程序。*/@SpringBootApplicationpublic class MainApplication &#123; //SpringApplication.run() 方法是启动 Spring Boot 应用程序的关键步骤。它创建应用程序上下文、 // 自动配置应用程序、启动应用程序，并处理命令行参数，使应用程序能够运行和提供所需的功能 public static void main(String[] args) &#123; SpringApplication.run(MainApplication.class,args); &#125;&#125; 编写处理器Controller 创建package：com.atguigu.controller 创建类：HelloController 注意： IoC和DI注解需要在启动类的同包或者子包下方可生效！无需指定，约束俗称。 1234567891011121314package com.atguigu.controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123; @GetMapping(&quot;/hello&quot;) public String hello()&#123; return &quot;Hello,Spring Boot 3!&quot;; &#125;&#125; 启动测试 入门总结 为什么依赖不需要写版本？ 每个boot项目都有一个父项目spring-boot-starter-parent parent的父项目是spring-boot-dependencies 父项目 版本仲裁中心，把所有常见的jar的依赖版本都声明好了。 比如：mysql-connector-j 启动器(Starter)是何方神圣？ Spring Boot提供了一种叫做Starter的概念，它是一组预定义的依赖项集合，旨在简化Spring应用程序的配置和构建过程。Starter包含了一组相关的依赖项，以便在启动应用程序时自动引入所需的库、配置和功能。 主要作用如下： 简化依赖管理：Spring Boot Starter通过捆绑和管理一组相关的依赖项，减少了手动解析和配置依赖项的工作。只需引入一个相关的Starter依赖，即可获取应用程序所需的全部依赖。 自动配置：Spring Boot Starter在应用程序启动时自动配置所需的组件和功能。通过根据类路径和其他设置的自动检测，Starter可以自动配置Spring Bean、数据源、消息传递等常见组件，从而使应用程序的配置变得简单和维护成本降低。 提供约定优于配置：Spring Boot Starter遵循“约定优于配置”的原则，通过提供一组默认设置和约定，减少了手动配置的需要。它定义了标准的配置文件命名约定、默认属性值、日志配置等，使得开发者可以更专注于业务逻辑而不是繁琐的配置细节。 快速启动和开发应用程序：Spring Boot Starter使得从零开始构建一个完整的Spring Boot应用程序变得容易。它提供了主要领域（如Web开发、数据访问、安全性、消息传递等）的Starter，帮助开发者快速搭建一个具备特定功能的应用程序原型。 模块化和可扩展性：Spring Boot Starter的组织结构使得应用程序的不同模块可以进行分离和解耦。每个模块可以有自己的Starter和依赖项，使得应用程序的不同部分可以按需进行开发和扩展。 Spring Boot提供了许多预定义的Starter，例如spring-boot-starter-web用于构建Web应用程序，spring-boot-starter-data-jpa用于使用JPA进行数据库访问，spring-boot-starter-security用于安全认证和授权等等。 使用Starter非常简单，只需要在项目的构建文件（例如Maven的pom.xml）中添加所需的Starter依赖，Spring Boot会自动处理依赖管理和配置。 通过使用Starter，开发人员可以方便地引入和配置应用程序所需的功能，避免了手动添加大量的依赖项和编写冗长的配置文件的繁琐过程。同时，Starter也提供了一致的依赖项版本管理，确保依赖项之间的兼容性和稳定性。 spring boot提供的全部启动器地址： https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.starters 命名规范： 官方提供的场景：命名为：spring-boot-starter-* 第三方提供场景：命名为：*-spring-boot-starter @SpringBootApplication注解的功效？ @SpringBootApplication添加到启动类上，是一个组合注解，他的功效有具体的子注解实现！ 12345@SpringBootConfiguration@EnableAutoConfiguration@ComponentScanpublic @interface SpringBootApplication &#123;&#125; @SpringBootApplication注解是Spring Boot框架中的核心注解，它的主要作用是简化和加速Spring Boot应用程序的配置和启动过程。 具体而言，@SpringBootApplication注解起到以下几个主要作用： 1. 自动配置：@SpringBootApplication注解包含了@EnableAutoConfiguration注解，用于启用Spring Boot的自动配置机制。自动配置会根据应用程序的依赖项和类路径，自动配置各种常见的Spring配置和功能，减少开发者的手动配置工作。它通过智能地分析类路径、加载配置和条件判断，为应用程序提供适当的默认配置。 2. 组件扫描：@SpringBootApplication注解包含了@ComponentScan注解，用于自动扫描并加载应用程序中的组件，例如控制器（Controllers）、服务（Services）、存储库（Repositories）等。它默认会扫描@SpringBootApplication注解所在类的包及其子包中的组件，并将它们纳入Spring Boot应用程序的上下文中，使它们可被自动注入和使用。 3. 声明配置类：@SpringBootApplication注解本身就是一个组合注解，它包含了@Configuration注解，将被标注的类声明为配置类。配置类可以包含Spring框架相关的配置、Bean定义，以及其他的自定义配置。通过@SpringBootApplication注解，开发者可以将配置类与启动类合并在一起，使得配置和启动可以同时发生。 总的来说，@SpringBootApplication注解的主要作用是简化Spring Boot应用程序的配置和启动过程。它自动配置应用程序、扫描并加载组件，并将配置和启动类合二为一，简化了开发者的工作量，提高了开发效率。 SpringBoot3配置文件统一配置管理概述 SpringBoot工程下，进行统一的配置管理，你想设置的任何参数（端口号、项目根路径、数据库连接信息等等）都集中到一个固定位置和命名的配置文件（application.properties或application.yml）中！ 配置文件应该放置在Spring Boot工程的src/main/resources目录下。这是因为src/main/resources目录是Spring Boot默认的类路径（classpath），配置文件会被自动加载并可供应用程序访问。 功能配置参数说明： https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties 细节总结： 集中式管理配置。统一在一个文件完成程序功能参数设置和自定义参数声明 。 位置：resources文件夹下，必须命名application 后缀 .properties &#x2F; .yaml &#x2F; .yml 。 如果同时存在application.properties | application.yml(.yaml) , properties的优先级更高。 配置基本都有默认值。 属性配置文件使用 配置文件 在 resource 文件夹下面新建 application.properties 配置文件 12345678910111213# application.properties 为统一配置文件# 内部包含: 固定功能的key,自定义的key# 此处的配置信息,我们都可以在程序中@Value等注解读取# 固定的key# 启动端口号server.port=80 # 自定义spring.jdbc.datasource.driverClassName=com.mysql.cj.jdbc.driverspring.jdbc.datasource.url=jdbc:mysql:///springboot_01spring.jdbc.datasource.username=rootspring.jdbc.datasource.password=root 读取配置文件 12345678910111213141516171819202122package com.atguigu.properties;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class DataSourceProperties &#123; @Value(&quot;$&#123;spring.jdbc.datasource.driverClassName&#125;&quot;) private String driverClassName; @Value(&quot;$&#123;spring.jdbc.datasource.url&#125;&quot;) private String url; @Value(&quot;$&#123;spring.jdbc.datasource.username&#125;&quot;) private String username; @Value(&quot;$&#123;spring.jdbc.datasource.password&#125;&quot;) private String password; // 生成get set 和 toString方法&#125; 3. 测试效果 在controller注入，输出进行测试 12345678@Autowiredprivate DataSourceProperties dataSourceProperties ;@RequestMapping(path = &quot;/hello&quot;)public String sayHello() &#123; System.out.println(dataSourceProperties); return &quot;Hello Spring Boot ! &quot; ;&#125; YAML配置文件使用 yaml格式介绍 YAML（YAML Ain’t Markup Language）是一种基于层次结构的数据序列化格式，旨在提供一种易读、人类友好的数据表示方式。 与.properties文件相比，YAML格式有以下优势： 层次结构：YAML文件使用缩进和冒号来表示层次结构，使得数据之间的关系更加清晰和直观。这样可以更容易理解和维护复杂的配置，特别适用于深层次嵌套的配置情况。 自我描述性：YAML文件具有自我描述性，字段和值之间使用冒号分隔，并使用缩进表示层级关系。这使得配置文件更易于阅读和理解，并且可以减少冗余的标点符号和引号。 注释支持：YAML格式支持注释，可以在配置文件中添加说明性的注释，使配置更具可读性和可维护性。相比之下，.properties文件不支持注释，无法提供类似的解释和说明。 多行文本：YAML格式支持多行文本的表示，可以更方便地表示长文本或数据块。相比之下，.properties文件需要使用转义符或将长文本拆分为多行。 类型支持：YAML格式天然支持复杂的数据类型，如列表、映射等。这使得在配置文件中表示嵌套结构或数据集合更加容易，而不需要进行额外的解析或转换。 更好的可读性：由于YAML格式的特点，它更容易被人类读懂和解释。它减少了配置文件中需要的特殊字符和语法，让配置更加清晰明了，从而减少了错误和歧义。 综上所述，YAML格式相对于.properties文件具有更好的层次结构表示、自我描述性、注释支持、多行文本表示、复杂数据类型支持和更好的可读性。这些特点使YAML成为一种有力的配置文件格式，尤其适用于复杂的配置需求和人类可读的场景。然而，选择使用YAML还是.properties取决于实际需求和团队的偏好，简单的配置可以使用.properties，而复杂的配置可以选择YAML以获得更多的灵活性和可读性 yaml语法说明 数据结构用树形结构呈现，通过缩进来表示层级， 连续的项目（集合）通过减号 ” - ” 来表示 键值结构里面的key&#x2F;value对用冒号 ” : ” 来分隔。 YAML配置文件的扩展名是yaml 或 yml 例如： 12345678910111213141516171819# YAML配置文件示例app_name: 我的应用程序version: 1.0.0author: 张三database: host: localhost port: 5432 username: admin password: password123features: - 登录 - 注册 - 仪表盘settings: analytics: true theme: dark 配置文件 12345678910spring: jdbc: datasource: driverClassName: com.mysql.jdbc.Driver url: jdbc:mysql:///springboot_02 username: root password: root server: port: 80 读取配置文件 读取方式和properties一致 测试效果 在controller注入，输出进行测试 批量配置文件注入 @ConfigurationProperties是SpringBoot提供的重要注解, 他可以将一些配置属性批量注入到bean对象。 创建类，添加属性和注解 在类上通过@ConfigurationProperties注解声明该类要读取属性配置 prefix&#x3D;”spring.jdbc.datasource” 读取属性文件中前缀为spring.jdbc.datasource的值。前缀和属性名称和配置文件中的key必须要保持一致才可以注入成功 1234567891011121314package com.atguigu.properties;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@Component@ConfigurationProperties(prefix = &quot;spring.jdbc.datasource&quot;)public class DataSourceConfigurationProperties &#123; private String driverClassName; private String url; private String username; private String password;&#125; 多环境配置和使用 需求 在Spring Boot中，可以使用多环境配置来根据不同的运行环境（如开发、测试、生产）加载不同的配置。SpringBoot支持多环境配置让应用程序在不同的环境中使用不同的配置参数，例如数据库连接信息、日志级别、缓存配置等。 以下是实现Spring Boot多环境配置的常见方法： 属性文件分离：将应用程序的配置参数分离到不同的属性文件中，每个环境对应一个属性文件。例如，可以创建application-dev.properties、application-prod.properties和application-test.properties等文件。在这些文件中，可以定义各自环境的配置参数，如数据库连接信息、端口号等。然后，在application.properties中通过spring.profiles.active属性指定当前使用的环境。Spring Boot会根据该属性来加载对应环境的属性文件，覆盖默认的配置。 YAML配置文件：与属性文件类似，可以将配置参数分离到不同的YAML文件中，每个环境对应一个文件。例如，可以创建application-dev.yml、application-prod.yml和application-test.yml等文件。在这些文件中，可以使用YAML语法定义各自环境的配置参数。同样，通过spring.profiles.active属性指定当前的环境，Spring Boot会加载相应的YAML文件。 命令行参数(动态)：可以通过命令行参数来指定当前的环境。例如，可以使用--spring.profiles.active=dev来指定使用开发环境的配置。 通过上述方法，Spring Boot会根据当前指定的环境来加载相应的配置文件或参数，从而实现多环境配置。这样可以简化在不同环境之间的配置切换，并且确保应用程序在不同环境中具有正确的配置。 多环境配置（基于方式b实践） 创建开发、测试、生产三个环境的配置文件 application-dev.yml（开发） 1234567spring: jdbc: datasource: driverClassName: com.mysql.cj.jdbc.Driver url: jdbc:mysql:///dev username: root password: root application-test.yml（测试） 1234567spring: jdbc: datasource: driverClassName: com.mysql.cj.jdbc.Driver url: jdbc:mysql:///test username: root password: root application-prod.yml（生产） 1234567spring: jdbc: datasource: driverClassName: com.mysql.cj.jdbc.Driver url: jdbc:mysql:///prod username: root password: root 环境激活 123spring: profiles: active: dev 测试效果 注意 : 如果设置了spring.profiles.active，并且和application有重叠属性，以active设置优先。 如果设置了spring.profiles.active，和application无重叠属性，application设置依然生效！ SpringBoot3整合SpringMVC实现过程 创建程序 引入依赖 创建启动类 创建实体类 编写Controller 访问测试 web相关配置 位置：application.yml 12345678# web相关的配置# https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties.serverserver: # 端口号设置 port: 80 # 项目根路径 servlet: context-path: /boot 当涉及Spring Boot的Web应用程序配置时，以下是五个重要的配置参数： server.port: 指定应用程序的HTTP服务器端口号。默认情况下，Spring Boot使用8080作为默认端口。您可以通过在配置文件中设置server.port来更改端口号。 server.servlet.context-path: 设置应用程序的上下文路径。这是应用程序在URL中的基本路径。默认情况下，上下文路径为空。您可以通过在配置文件中设置server.servlet.context-path属性来指定自定义的上下文路径。 spring.mvc.view.prefix和spring.mvc.view.suffix: 这两个属性用于配置视图解析器的前缀和后缀。视图解析器用于解析控制器返回的视图名称，并将其映射到实际的视图页面。spring.mvc.view.prefix定义视图的前缀，spring.mvc.view.suffix定义视图的后缀。 spring.resources.static-locations: 配置静态资源的位置。静态资源可以是CSS、JavaScript、图像等。默认情况下，Spring Boot会将静态资源放在classpath:/static目录下。您可以通过在配置文件中设置spring.resources.static-locations属性来自定义静态资源的位置。 spring.http.encoding.charset和spring.http.encoding.enabled: 这两个属性用于配置HTTP请求和响应的字符编码。spring.http.encoding.charset定义字符编码的名称（例如UTF-8），spring.http.encoding.enabled用于启用或禁用字符编码的自动配置。 这些是在Spring Boot的配置文件中与Web应用程序相关的一些重要配置参数。根据您的需求，您可以在配置文件中设置这些参数来定制和配置您的Web应用程序 静态资源处理 在WEB开发中我们需要引入一些静态资源 , 例如 : HTML , CSS , JS , 图片等 , 如果是普通的项目静态资源可以放在项目的webapp目录下。现在使用Spring Boot做开发 , 项目中没有webapp目录 , 我们的项目是一个jar工程，那么就没有webapp，我们的静态资源该放哪里呢？ 默认路径 在springboot中就定义了静态资源的默认查找路径： 12345678910111213141516171819package org.springframework.boot.autoconfigure.web;//..................public static class Resources &#123; private static final String[] CLASSPATH_RESOURCE_LOCATIONS = new String[]&#123;&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot;&#125;; private String[] staticLocations; private boolean addMappings; private boolean customized; private final Chain chain; private final Cache cache; public Resources() &#123; this.staticLocations = CLASSPATH_RESOURCE_LOCATIONS; this.addMappings = true; this.customized = false; this.chain = new Chain(); this.cache = new Cache(); &#125;//........... &#125; 默认的静态资源路径为： · classpath:&#x2F;META-INF&#x2F;resources&#x2F; · classpath:&#x2F;resources&#x2F; · classpath:&#x2F;static&#x2F; · classpath:&#x2F;public&#x2F; 我们只要静态资源放在这些目录中任何一个，SpringMVC都会帮我们处理。 我们习惯会把静态资源放在classpath:&#x2F;static&#x2F; 目录下。在resources目录下创建index.html文件 覆盖路径 12345678910111213# web相关的配置# https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties.serverserver: # 端口号设置 port: 80 # 项目根路径 servlet: context-path: /bootspring: web: resources: # 配置静态资源地址,如果设置,会覆盖默认值 static-locations: classpath:/webapp 自定义拦截器(SpringMVC配置) 拦截器声明 1234567891011121314151617181920212223242526package com.atguigu.interceptor;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import org.springframework.stereotype.Component;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;@Componentpublic class MyInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;MyInterceptor拦截器的preHandle方法执行....&quot;); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;MyInterceptor拦截器的postHandle方法执行....&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;MyInterceptor拦截器的afterCompletion方法执行....&quot;); &#125;&#125; 拦截器配置 正常使用配置类，只要保证，配置类要在启动类的同包或者子包方可生效！ 123456789101112131415161718192021222324package com.atguigu.config;import com.atguigu.interceptor.MyInterceptor;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class MvcConfig implements WebMvcConfigurer &#123; @Autowired private MyInterceptor myInterceptor ; /** * /** 拦截当前目录及子目录下的所有路径 /user/** /user/findAll /user/order/findAll * /* 拦截当前目录下的以及子路径 /user/* /user/findAll * @param registry */ @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(myInterceptor).addPathPatterns(&quot;/**&quot;); &#125;&#125; 拦截器效果测试 SpringBoot3整合Druid数据源 创建程序 引入依赖 启动类 配置文件编写 &gt; 添加druid连接池的基本配置 1234567891011121314151617181920212223242526272829303132333435363738394041spring: datasource: # 连接池类型 type: com.alibaba.druid.pool.DruidDataSource # Druid的其他属性配置 springboot3整合情况下,数据库连接信息必须在Druid属性下! druid: url: jdbc:mysql://localhost:3306/day01 username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver # 初始化时建立物理连接的个数 initial-size: 5 # 连接池的最小空闲数量 min-idle: 5 # 连接池最大连接数量 max-active: 20 # 获取连接时最大等待时间，单位毫秒 max-wait: 60000 # 申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 test-while-idle: true # 既作为检测的间隔时间又作为testWhileIdel执行的依据 time-between-eviction-runs-millis: 60000 # 销毁线程时检测当前连接的最后活动时间和当前时间差大于该值时，关闭当前连接(配置连接在池中的最小生存时间) min-evictable-idle-time-millis: 30000 # 用来检测数据库连接是否有效的sql 必须是一个查询语句(oracle中为 select 1 from dual) validation-query: select 1 # 申请连接时会执行validationQuery检测连接是否有效,开启会降低性能,默认为true test-on-borrow: false # 归还连接时会执行validationQuery检测连接是否有效,开启会降低性能,默认为true test-on-return: false # 是否缓存preparedStatement, 也就是PSCache,PSCache对支持游标的数据库性能提升巨大，比如说oracle,在mysql下建议关闭。 pool-prepared-statements: false # 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 max-pool-prepared-statement-per-connection-size: -1 # 合并多个DruidDataSource的监控数据 use-global-data-source-stat: truelogging: level: root: debug 编写Controller 启动测试 问题解决 通过源码分析，druid-spring-boot-3-starter目前最新版本是1.2.18，虽然适配了SpringBoot3，但缺少自动装配的配置文件，需要手动在resources目录下创建META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports，文件内容如下! 1com.alibaba.druid.spring.boot3.autoconfigure.DruidDataSourceAutoConfigure SpringBoot3整合MybatisMyBatis整合步骤 导入依赖：在您的Spring Boot项目的构建文件（如pom.xml）中添加MyBatis和数据库驱动的相关依赖。例如，如果使用MySQL数据库，您需要添加MyBatis和MySQL驱动的依赖。 配置数据源：在application.properties或application.yml中配置数据库连接信息，包括数据库URL、用户名、密码、mybatis的功能配置等。 创建实体类：创建与数据库表对应的实体类。 创建Mapper接口：创建与数据库表交互的Mapper接口。 创建Mapper接口SQL实现： 可以使用mapperxml文件或者注解方式 创建程序启动类 注解扫描：在Spring Boot的主应用类上添加@MapperScan注解，用于扫描和注册Mapper接口。 使用Mapper接口：在需要使用数据库操作的地方，通过依赖注入或直接实例化Mapper接口，并调用其中的方法进行数据库操作。 Mybatis整合实践 创建项目 导入依赖 配置文件 1234567891011121314151617181920server: port: 80 servlet: context-path: /spring: datasource: type: com.alibaba.druid.pool.DruidDataSource druid: url: jdbc:mysql:///day01 username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver mybatis: configuration: # setting配置 auto-mapping-behavior: full map-underscore-to-camel-case: true log-impl: org.apache.ibatis.logging.slf4j.Slf4jImpl type-aliases-package: com.atguigu.pojo # 配置别名 mapper-locations: classpath:/mapper/*.xml # mapperxml位置 实体类准备 Mapper接口准备 Mapper接口实现（XML） 位置：resources&#x2F;mapper&#x2F;UserMapper.xml 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace = 接口的全限定符 --&gt;&lt;mapper namespace=&quot;com.atguigu.mapper.UserMapper&quot;&gt; &lt;select id=&quot;queryAll&quot; resultType=&quot;user&quot;&gt; select * from users &lt;/select&gt;&lt;/mapper&gt; 编写三层架构代码 启动类和接口扫描 123456789@MapperScan(&quot;com.atguigu.mapper&quot;) //mapper接口扫描配置@SpringBootApplicationpublic class MainApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MainApplication.class,args); &#125;&#125; 启动测试 声明式事务整合配置 注：SpringBoot项目会自动配置一个 DataSourceTransactionManager，所以我们只需在方法（或者类）加上 @Transactional 注解，就自动纳入 Spring 的事务管理了 12345678@Transactionalpublic void update()&#123; User user = new User(); user.setId(1); user.setPassword(&quot;test2&quot;); user.setAccount(&quot;test2&quot;); userMapper.update(user);&#125; AOP整合配置 依赖导入: 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt; 直接使用aop注解即可: 1234567891011@Component@Aspectpublic class LogAdvice &#123; @Before(&quot;execution(* com..service.*.*(..))&quot;) public void before(JoinPoint joinPoint)&#123; System.out.println(&quot;LogAdvice.before&quot;); System.out.println(&quot;joinPoint = &quot; + joinPoint); &#125;&#125; SpringBoot3项目打包和运行添加打包插件 在Spring Boot项目中添加spring-boot-maven-plugin插件是为了支持将项目打包成可执行的可运行jar包。如果不添加spring-boot-maven-plugin插件配置，使用常规的java -jar命令来运行打包后的Spring Boot项目是无法找到应用程序的入口点，因此导致无法运行。 123456789&lt;!-- SpringBoot应用打包插件--&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 执行打包 在idea点击package进行打包 可以在编译的target文件中查看jar包 命令启动和参数说明 java -jar命令用于在Java环境中执行可执行的JAR文件。下面是关于java -jar命令的说明： 1命令格式：java -jar [选项] [参数] &lt;jar文件名&gt; -D&lt;name&gt;=&lt;value&gt;：设置系统属性，可以通过System.getProperty()方法在应用程序中获取该属性值。例如：java -jar -Dserver.port=8080 myapp.jar。 -X：设置JVM参数，例如内存大小、垃圾回收策略等。常用的选项包括： -Xmx&lt;size&gt;：设置JVM的最大堆内存大小，例如 -Xmx512m 表示设置最大堆内存为512MB。 -Xms&lt;size&gt;：设置JVM的初始堆内存大小，例如 -Xms256m 表示设置初始堆内存为256MB。 -Dspring.profiles.active=&lt;profile&gt;：指定Spring Boot的激活配置文件，可以通过application-&lt;profile&gt;.properties或application-&lt;profile&gt;.yml文件来加载相应的配置。例如：java -jar -Dspring.profiles.active=dev myapp.jar。 注意： -D 参数必须要在jar之前！否者不生效！ Mybatis-Plus版本：3.5.3.1全自动or框架，效率更高 MyBatis-Plus快速入门简介 https://baomidou.com/ MyBatis-Plus (opens new window)（简称 MP）是一个 MyBatis (opens new window) 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 特性： 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库 内置性能分析插件：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 支持数据库： MySQL，Oracle，DB2，H2，HSQL，SQLite，PostgreSQL，SQLServer，Phoenix，Gauss ，ClickHouse，Sybase，OceanBase，Firebird，Cubrid，Goldilocks，csiidb，informix，TDengine，redshift 达梦数据库，虚谷数据库，人大金仓数据库，南大通用(华库)数据库，南大通用数据库，神通数据库，瀚高数据库，优炫数据库 mybatis-plus总结： 自动生成单表的CRUD功能 提供丰富的条件拼接方式 全自动ORM类型持久层框架 快速入门 准备数据库脚本 现有一张 User 表，其表结构如下： id name age email 1 Jone 18 test1@baomidou.com 2 Jack 20 test2@baomidou.com 3 Tom 28 test3@baomidou.com 4 Sandy 21 test4@baomidou.com 5 Billie 24 test5@baomidou.com 12345678910111213141516171819DROP TABLE IF EXISTS user;CREATE TABLE user( id BIGINT(20) NOT NULL COMMENT &#x27;主键ID&#x27;, name VARCHAR(30) NULL DEFAULT NULL COMMENT &#x27;姓名&#x27;, age INT(11) NULL DEFAULT NULL COMMENT &#x27;年龄&#x27;, email VARCHAR(50) NULL DEFAULT NULL COMMENT &#x27;邮箱&#x27;, PRIMARY KEY (id));INSERT INTO user (id, name, age, email) VALUES(1, &#x27;Jone&#x27;, 18, &#x27;test1@baomidou.com&#x27;),(2, &#x27;Jack&#x27;, 20, &#x27;test2@baomidou.com&#x27;),(3, &#x27;Tom&#x27;, 28, &#x27;test3@baomidou.com&#x27;),(4, &#x27;Sandy&#x27;, 21, &#x27;test4@baomidou.com&#x27;),(5, &#x27;Billie&#x27;, 24, &#x27;test5@baomidou.com&#x27;); 准备boot工程 导入依赖 配置文件和启动类 完善连接池配置： 文件夹：META-INF.spring 文件名： org.springframework.boot.autoconfigure.AutoConfiguration.imports 内容：com.alibaba.druid.spring.boot3.autoconfigure.DruidDataSourceAutoConfigure application.yaml 功能编码 编写实体类 User.java（此处使用了 Lombok 简化代码） 测试和使用 添加测试类，进行功能测试： 1234567891011121314@SpringBootTest //springboot下测试环境注解public class SampleTest &#123; @Autowired private UserMapper userMapper; @Test public void testSelect() &#123; System.out.println((&quot;----- selectAll method test ------&quot;)); List&lt;User&gt; userList = userMapper.selectList(null); userList.forEach(System.out::println); &#125;&#125; 小结 通过以上几个简单的步骤，我们就实现了 User 表的 CRUD 功能，甚至连 XML 文件都不用编写！ 从以上步骤中，我们可以看到集成MyBatis-Plus非常的简单，只需要引入 starter 工程，并配置 mapper 扫描路径即可。 MyBatis-Plus核心功能基于Mapper接口CRUD 通用 CRUD 封装BaseMapper (opens new window)接口， Mybatis-Plus 启动时自动解析实体表关系映射转换为 Mybatis 内部对象注入容器! 内部包含常见的单表操作！ Insert方法1234// 插入一条记录// T 就是要插入的实体对象// 默认主键生成策略为雪花算法（后面讲解）int insert(T entity); Delete方法1234567891011// 根据 entity 条件，删除记录int delete(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; wrapper);// 删除（根据ID 批量删除）int deleteBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);// 根据 ID 删除int deleteById(Serializable id);// 根据 columnMap 条件，删除记录int deleteByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap); 类型 参数名 描述 Wrapper wrapper 实体对象封装操作类（可以为 null） Collection&lt;? extends Serializable&gt; idList 主键 ID 列表(不能为 null 以及 empty) Serializable id 主键 ID Map&lt;String, Object&gt; columnMap 表字段 map 对象 Update方法123456// 根据 whereWrapper 条件，更新记录int update(@Param(Constants.ENTITY) T updateEntity, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; whereWrapper);// 根据 ID 修改 主键属性必须值int updateById(@Param(Constants.ENTITY) T entity); 类型 参数名 描述 T entity 实体对象 (set 条件值,可为 null) Wrapper updateWrapper 实体对象封装操作类（可以为 null,里面的 entity 用于生成 where 语句） Select方法1234567891011121314151617181920212223242526272829// 根据 ID 查询T selectById(Serializable id);// 根据 entity 条件，查询一条记录T selectOne(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 查询（根据ID 批量查询）List&lt;T&gt; selectBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);// 根据 entity 条件，查询全部记录List&lt;T&gt; selectList(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 查询（根据 columnMap 条件）List&lt;T&gt; selectByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap);// 根据 Wrapper 条件，查询全部记录List&lt;Map&lt;String, Object&gt;&gt; selectMaps(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询全部记录。注意： 只返回第一个字段的值List&lt;Object&gt; selectObjs(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 entity 条件，查询全部记录（并翻页）IPage&lt;T&gt; selectPage(IPage&lt;T&gt; page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询全部记录（并翻页）IPage&lt;Map&lt;String, Object&gt;&gt; selectMapsPage(IPage&lt;T&gt; page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询总记录数Integer selectCount(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); 参数说明 类型 参数名 描述 Serializable id 主键 ID Wrapper queryWrapper 实体对象封装操作类（可以为 null） Collection&lt;? extends Serializable&gt; idList 主键 ID 列表(不能为 null 以及 empty) Map&lt;String, Object&gt; columnMap 表字段 map 对象 IPage page 分页查询条件（可以为 RowBounds.DEFAULT） 自定义和多表映射 mybatis-plus的默认mapperxml位置 123mybatis-plus: # mybatis-plus的配置 # 默认位置 private String[] mapperLocations = new String[]&#123;&quot;classpath*:/mapper/**/*.xml&quot;&#125;; mapper-locations: classpath:/mapper/*.xml 自定义mapper方法： 1234567public interface UserMapper extends BaseMapper&lt;User&gt; &#123; //正常自定义方法！ //可以使用注解@Select或者mapper.xml实现 List&lt;User&gt; queryAll();&#125; 基于Service接口CRUD 通用 Service CRUD 封装IService (opens new window)接口，进一步封装 CRUD 采用 get 查询单行 remove 删除 list 查询集合 page 分页 前缀命名方式区分 Mapper 层避免混淆， 对比Mapper接口CRUD区别： service添加了批量方法 service层的方法自动添加事务 使用Iservice接口方式 接口继承IService接口 123public interface UserService extends IService&lt;User&gt; &#123;&#125; 类继承ServiceImpl实现类 12345@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper,User&gt; implements UserService&#123;&#125; CRUD方法介绍1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980保存：// 插入一条记录（选择字段，策略插入）boolean save(T entity);// 插入（批量）boolean saveBatch(Collection&lt;T&gt; entityList);// 插入（批量）boolean saveBatch(Collection&lt;T&gt; entityList, int batchSize);修改或者保存：// TableId 注解存在更新记录，否插入一条记录boolean saveOrUpdate(T entity);// 根据updateWrapper尝试更新，否继续执行saveOrUpdate(T)方法boolean saveOrUpdate(T entity, Wrapper&lt;T&gt; updateWrapper);// 批量修改插入boolean saveOrUpdateBatch(Collection&lt;T&gt; entityList);// 批量修改插入boolean saveOrUpdateBatch(Collection&lt;T&gt; entityList, int batchSize);移除：// 根据 queryWrapper 设置的条件，删除记录boolean remove(Wrapper&lt;T&gt; queryWrapper);// 根据 ID 删除boolean removeById(Serializable id);// 根据 columnMap 条件，删除记录boolean removeByMap(Map&lt;String, Object&gt; columnMap);// 删除（根据ID 批量删除）boolean removeByIds(Collection&lt;? extends Serializable&gt; idList);更新：// 根据 UpdateWrapper 条件，更新记录 需要设置sqlsetboolean update(Wrapper&lt;T&gt; updateWrapper);// 根据 whereWrapper 条件，更新记录boolean update(T updateEntity, Wrapper&lt;T&gt; whereWrapper);// 根据 ID 选择修改boolean updateById(T entity);// 根据ID 批量更新boolean updateBatchById(Collection&lt;T&gt; entityList);// 根据ID 批量更新boolean updateBatchById(Collection&lt;T&gt; entityList, int batchSize);数量： // 查询总记录数int count();// 根据 Wrapper 条件，查询总记录数int count(Wrapper&lt;T&gt; queryWrapper);查询：// 根据 ID 查询T getById(Serializable id);// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(&quot;LIMIT 1&quot;)T getOne(Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper，查询一条记录T getOne(Wrapper&lt;T&gt; queryWrapper, boolean throwEx);// 根据 Wrapper，查询一条记录Map&lt;String, Object&gt; getMap(Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper，查询一条记录&lt;V&gt; V getObj(Wrapper&lt;T&gt; queryWrapper, Function&lt;? super Object, V&gt; mapper);集合：// 查询所有List&lt;T&gt; list();// 查询列表List&lt;T&gt; list(Wrapper&lt;T&gt; queryWrapper);// 查询（根据ID 批量查询）Collection&lt;T&gt; listByIds(Collection&lt;? extends Serializable&gt; idList);// 查询（根据 columnMap 条件）Collection&lt;T&gt; listByMap(Map&lt;String, Object&gt; columnMap);// 查询所有列表List&lt;Map&lt;String, Object&gt;&gt; listMaps();// 查询列表List&lt;Map&lt;String, Object&gt;&gt; listMaps(Wrapper&lt;T&gt; queryWrapper);// 查询全部记录List&lt;Object&gt; listObjs();// 查询全部记录&lt;V&gt; List&lt;V&gt; listObjs(Function&lt;? super Object, V&gt; mapper);// 根据 Wrapper 条件，查询全部记录List&lt;Object&gt; listObjs(Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询全部记录&lt;V&gt; List&lt;V&gt; listObjs(Wrapper&lt;T&gt; queryWrapper, Function&lt;? super Object, V&gt; mapper); 分页查询实现 导入分页插件 123456@Beanpublic MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor;&#125; 使用分页查询 123456789101112131415@Testpublic void testPageQuery()&#123; //设置分页参数 Page&lt;User&gt; page = new Page&lt;&gt;(1, 5); userMapper.selectPage(page, null); //获取分页数据 List&lt;User&gt; list = page.getRecords(); list.forEach(System.out::println); System.out.println(&quot;当前页：&quot;+page.getCurrent()); System.out.println(&quot;每页显示的条数：&quot;+page.getSize()); System.out.println(&quot;总记录数：&quot;+page.getTotal()); System.out.println(&quot;总页数：&quot;+page.getPages()); System.out.println(&quot;是否有上一页：&quot;+page.hasPrevious()); System.out.println(&quot;是否有下一页：&quot;+page.hasNext());&#125; 自定义的mapper方法使用分页 方法 1234//传入参数携带Ipage接口//返回结果为IPageIPage&lt;User&gt; selectPageVo(IPage&lt;?&gt; page, Integer id); 接口实现 123&lt;select id=&quot;selectPageVo&quot; resultType=&quot;xxx.xxx.xxx.User&quot;&gt; SELECT * FROM user WHERE id &gt; #&#123;id&#125;&lt;/select&gt; 测试 1234567891011121314151617@Testpublic void testQuick()&#123; IPage page = new Page(1,2); userMapper.selectPageVo(page,2); long current = page.getCurrent(); System.out.println(&quot;current = &quot; + current); long pages = page.getPages(); System.out.println(&quot;pages = &quot; + pages); long total = page.getTotal(); System.out.println(&quot;total = &quot; + total); List records = page.getRecords(); System.out.println(&quot;records = &quot; + records);&#125; 条件构造器使用条件构造器作用实例代码： 123456789QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();queryWrapper.eq(&quot;name&quot;, &quot;John&quot;); // 添加等于条件queryWrapper.ne(&quot;age&quot;, 30); // 添加不等于条件queryWrapper.like(&quot;email&quot;, &quot;@gmail.com&quot;); // 添加模糊匹配条件等同于： delete from user where name = &quot;John&quot; and age != 30 and email like &quot;%@gmail.com%&quot;// 根据 entity 条件，删除记录int delete(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; wrapper); 使用MyBatis-Plus的条件构造器，你可以构建灵活、高效的查询条件，而不需要手动编写复杂的 SQL 语句。它提供了许多方法来支持各种条件操作符，并且可以通过链式调用来组合多个条件。这样可以简化查询的编写过程，并提高开发效率。 条件构造器继承结构条件构造器类结构： ![](/images/SSM/mp-1.png) Wrapper ： 条件构造抽象类，最顶端父类 - AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件 - QueryWrapper ： 查询/删除条件封装 - UpdateWrapper ： 修改条件封装 - AbstractLambdaWrapper ： 使用Lambda 语法 - LambdaQueryWrapper ：用于Lambda语法使用的查询Wrapper - LambdaUpdateWrapper ： Lambda 更新封装Wrapper 基于QueryWrapper 组装条件组装查询条件： 1234567891011@Testpublic void test01()&#123; //查询用户名包含a，年龄在20到30之间，并且邮箱不为null的用户信息 //SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 AND (username LIKE ? AND age BETWEEN ? AND ? AND email IS NOT NULL) QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.like(&quot;username&quot;, &quot;a&quot;) .between(&quot;age&quot;, 20, 30) .isNotNull(&quot;email&quot;); List&lt;User&gt; list = userMapper.selectList(queryWrapper); list.forEach(System.out::println); 组装排序条件: 1234567891011@Testpublic void test02()&#123; //按年龄降序查询用户，如果年龄相同则按id升序排列 //SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 ORDER BY age DESC,id ASC QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper .orderByDesc(&quot;age&quot;) .orderByAsc(&quot;id&quot;); List&lt;User&gt; users = userMapper.selectList(queryWrapper); users.forEach(System.out::println);&#125; 组装删除条件: 12345678910@Testpublic void test03()&#123; //删除email为空的用户 //DELETE FROM t_user WHERE (email IS NULL) QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.isNull(&quot;email&quot;); //条件构造器也可以构建删除语句的条件 int result = userMapper.delete(queryWrapper); System.out.println(&quot;受影响的行数：&quot; + result);&#125; and和or关键字使用(修改)： 12345678910111213141516@Testpublic void test04() &#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); //将年龄大于20并且用户名中包含有a或邮箱为null的用户信息修改 //UPDATE t_user SET age=?, email=? WHERE username LIKE ? AND age &gt; ? OR email IS NULL) queryWrapper .like(&quot;username&quot;, &quot;a&quot;) .gt(&quot;age&quot;, 20) .or() .isNull(&quot;email&quot;); User user = new User(); user.setAge(18); user.setEmail(&quot;user@atguigu.com&quot;); int result = userMapper.update(user, queryWrapper); System.out.println(&quot;受影响的行数：&quot; + result);&#125; 指定列映射查询： 12345678910@Testpublic void test05() &#123; //查询用户信息的username和age字段 //SELECT username,age FROM t_user QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.select(&quot;username&quot;, &quot;age&quot;); //selectMaps()返回Map集合列表，通常配合select()使用，避免User对象中没有被查询到的列值为null List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(queryWrapper); maps.forEach(System.out::println);&#125; condition判断组织条件: 1234567891011121314151617181920212223 @Testpublic void testQuick3()&#123; String name = &quot;root&quot;; int age = 18; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); //判断条件拼接 //当name不为null拼接等于, age &gt; 1 拼接等于判断 //方案1: 手动判断 if (!StringUtils.isEmpty(name))&#123; queryWrapper.eq(&quot;name&quot;,name); &#125; if (age &gt; 1)&#123; queryWrapper.eq(&quot;age&quot;,age); &#125; //方案2: 拼接condition判断 //每个条件拼接方法都condition参数,这是一个比较运算,为true追加当前条件! //eq(condition,列名,值) queryWrapper.eq(!StringUtils.isEmpty(name),&quot;name&quot;,name) .eq(age&gt;1,&quot;age&quot;,age); &#125; 基于 UpdateWrapper组装条件使用queryWrapper: 12345678910111213141516@Testpublic void test04() &#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); //将年龄大于20并且用户名中包含有a或邮箱为null的用户信息修改 //UPDATE t_user SET age=?, email=? WHERE username LIKE ? AND age &gt; ? OR email IS NULL) queryWrapper .like(&quot;username&quot;, &quot;a&quot;) .gt(&quot;age&quot;, 20) .or() .isNull(&quot;email&quot;); User user = new User(); user.setAge(18); user.setEmail(&quot;user@atguigu.com&quot;); int result = userMapper.update(user, queryWrapper); System.out.println(&quot;受影响的行数：&quot; + result);&#125; 注意：使用queryWrapper + 实体类形式可以实现修改，但是无法将列值修改为null值！ 使用updateWrapper: 12345678910111213@Testpublic void testQuick2()&#123; UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;&gt;(); //将id = 3 的email设置为null, age = 18 updateWrapper.eq(&quot;id&quot;,3) .set(&quot;email&quot;,null) // set 指定列和结果 .set(&quot;age&quot;,18); //如果使用updateWrapper 实体对象写null即可! int result = userMapper.update(null, updateWrapper); System.out.println(&quot;result = &quot; + result);&#125; 使用updateWrapper可以随意设置列的值！！ 基于LambdaQueryWrapper组装条件1. **LambdaQueryWrapper对比QueryWrapper优势** QueryWrapper 示例代码： 123456QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();queryWrapper.eq(&quot;name&quot;, &quot;John&quot;) .ge(&quot;age&quot;, 18) .orderByDesc(&quot;create_time&quot;) .last(&quot;limit 10&quot;);List&lt;User&gt; userList = userMapper.selectList(queryWrapper); LambdaQueryWrapper 示例代码： 1234567LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();lambdaQueryWrapper.eq(User::getName, &quot;John&quot;) .ge(User::getAge, 18) .orderByDesc(User::getCreateTime) .last(&quot;limit 10&quot;);List&lt;User&gt; userList = userMapper.selectList(lambdaQueryWrapper); 从上面的代码对比可以看出，相比于 QueryWrapper，LambdaQueryWrapper 使用了实体类的属性引用（例如 User::getName、User::getAge），而不是字符串来表示字段名，这提高了代码的可读性和可维护性。 lambda表达式回顾 Lambda 表达式是 Java 8 引入的一种函数式编程特性，它提供了一种更简洁、更直观的方式来表示匿名函数或函数式接口的实现。Lambda 表达式可以用于简化代码，提高代码的可读性和可维护性。 Lambda 表达式的语法可以分为以下几个部分： 参数列表： 参数列表用小括号 () 括起来，可以指定零个或多个参数。如果没有参数，可以省略小括号；如果只有一个参数，可以省略小括号。 示例：(a, b), x -&gt;, () -&gt; 箭头符号： 箭头符号 -&gt; 分割参数列表和 Lambda 表达式的主体部分。 示例：-&gt; Lambda 表达式的主体： Lambda 表达式的主体部分可以是一个表达式或一个代码块。如果是一个表达式，可以省略 return 关键字；如果是多条语句的代码块，需要使用大括号 &#123;&#125; 括起来，并且需要明确指定 return 关键字。 示例： 单个表达式：x -&gt; x * x 代码块：(x, y) -&gt; &#123; int sum = x + y; return sum; &#125; Lambda 表达式的语法可以更具体地描述如下： 123456789101112131415161718192021222324252627// 使用 Lambda 表达式实现一个接口的方法interface Greeting &#123; void sayHello();&#125;public class LambdaExample &#123; public static void main(String[] args) &#123; //原始匿名内部类方式 Greeting greeting = new Greeting() &#123; @Override public void sayHello(int a) &#123; System.out.println(&quot;Hello, world!&quot;); &#125; &#125;; a-&gt;System.out.println(&quot;Hello, world!&quot;) // 使用 Lambda 表达式实现接口的方法 greeting = () -&gt; System.out.println(&quot;Hello, world!&quot;); System.out::println; () -&gt; 类.XXX(); -&gt; 类：：方法名 // 调用接口的方法 greeting.sayHello(); &#125;&#125; 3. 方法引用回顾: 方法引用是 Java 8 中引入的一种语法特性，它提供了一种简洁的方式来直接引用已有的方法或构造函数。方法引用可以替代 Lambda 表达式，使代码更简洁、更易读。 Java 8 支持以下几种方法引用的形式： 静态方法引用： 引用静态方法，语法为 类名::静态方法名。 实例方法引用： 引用实例方法，语法为 实例对象::实例方法名。 对象方法引用： 引用特定对象的实例方法，语法为 类名::实例方法名。 构造函数引用： 引用构造函数，语法为 类名::new。 演示代码: 12345678910111213import java.util.Arrays;import java.util.List;import java.util.function.Consumer;public class MethodReferenceExample &#123; public static void main(String[] args) &#123; List&lt;String&gt; names = Arrays.asList(&quot;John&quot;, &quot;Tom&quot;, &quot;Alice&quot;); // 使用 Lambda 表达式 names.forEach(name -&gt; System.out.println(name)); // 使用方法引用 names.forEach(System.out::println); &#125;&#125; 4. lambdaQueryWrapper使用案例: 1234567891011121314151617181920@Testpublic void testQuick4()&#123; String name = &quot;root&quot;; int age = 18; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); //每个条件拼接方法都condition参数,这是一个比较运算,为true追加当前条件! //eq(condition,列名,值) queryWrapper.eq(!StringUtils.isEmpty(name),&quot;name&quot;,name) .eq(age&gt;1,&quot;age&quot;,age); //TODO: 使用lambdaQueryWrapper LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;(); //注意: 需要使用方法引用 //技巧: 类名::方法名 lambdaQueryWrapper.eq(!StringUtils.isEmpty(name), User::getName,name); List&lt;User&gt; users= userMapper.selectList(lambdaQueryWrapper); System.out.println(users);&#125; 基于LambdaUpdateWrapper组装条件使用案例: 12345678910111213141516171819@Testpublic void testQuick2()&#123; UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;&gt;(); //将id = 3 的email设置为null, age = 18 updateWrapper.eq(&quot;id&quot;,3) .set(&quot;email&quot;,null) // set 指定列和结果 .set(&quot;age&quot;,18); //使用lambdaUpdateWrapper LambdaUpdateWrapper&lt;User&gt; updateWrapper1 = new LambdaUpdateWrapper&lt;&gt;(); updateWrapper1.eq(User::getId,3) .set(User::getEmail,null) .set(User::getAge,18); //如果使用updateWrapper 实体对象写null即可! int result = userMapper.update(null, updateWrapper); System.out.println(&quot;result = &quot; + result);&#125; 核心注解使用 理解和介绍 MyBatis-Plus是一个基于MyBatis框架的增强工具，提供了一系列简化和增强的功能，用于加快开发人员在使用MyBatis进行数据库访问时的效率。 MyBatis-Plus提供了一种基于注解的方式来定义和映射数据库操作，其中的注解起到了重要作用。 理解： 123public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; 此接口对应的方法为什么会自动触发 user表的crud呢？ 默认情况下， 根据指定的&lt;实体类&gt;的名称对应数据库表名，属性名对应数据库的列名！ 但是不是所有数据库的信息和实体类都完全映射！ 例如： 表名 t_user → 实体类 User 这时候就不对应了！ 自定义映射关系就可以使用mybatis-plus提供的注解即可！ @TableName注解 描述：表名注解，标识实体类对应的表 使用位置：实体类 12345678@TableName(&quot;sys_user&quot;) //对应数据库表名public class User &#123; private Long id; private String name; private Integer age; private String email;&#125; 特殊情况：如果表名和实体类名相同（忽略大小写）可以省略该注解！ 其他解决方案：全局设置前缀 ([https://www.baomidou.com/pages/56bac0/#基本配置](https://www.baomidou.com/pages/56bac0/#基本配置)) 1234mybatis-plus: # mybatis-plus的配置 global-config: db-config: table-prefix: sys_ # 表名前缀字符串 @TableId 注解 描述：主键注解 使用位置：实体类主键字段 123456789@TableName(&quot;sys_user&quot;)public class User &#123; @TableId(value=&quot;主键列名&quot;,type=主键策略) private Long id; private String name; private Integer age; private String email;&#125; 属性 类型 必须指定 默认值 描述 value String 否 “” 主键字段名 type Enum 否 IdType.NONE 指定主键类型 [IdType](https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-annotation/src/main/java/com/baomidou/mybatisplus/annotation/IdType.java)属性可选值： 值 描述 AUTO 数据库 ID 自增 (mysql配置主键自增长) ASSIGN_ID（默认） 分配 ID(主键类型为 Number(Long )或 String)(since 3.3.0),使用接口IdentifierGenerator的方法nextId(默认实现类为DefaultIdentifierGenerator雪花算法) 全局配置修改主键策略: 12345678910mybatis-plus: configuration: # 配置MyBatis日志 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl global-config: db-config: # 配置MyBatis-Plus操作表的默认前缀 table-prefix: t_ # 配置MyBatis-Plus的主键策略 id-type: auto 在以下场景下，添加`@TableId`注解是必要的： 1. 实体类的字段与数据库表的主键字段不同名：如果实体类中的字段与数据库表的主键字段不一致，需要使用`@TableId`注解来指定实体类中表示主键的字段。 2. 主键生成策略不是默认策略：如果需要使用除了默认主键生成策略以外的策略，也需要添加`@TableId`注解，并通过`value`属性指定生成策略。 雪花算法使用场景 雪花算法（Snowflake Algorithm）是一种用于生成唯一ID的算法。它由Twitter公司提出，用于解决分布式系统中生成全局唯一ID的需求。 在传统的自增ID生成方式中，使用单点数据库生成ID会成为系统的瓶颈，而雪花算法通过在分布式系统中生成唯一ID，避免了单点故障和性能瓶颈的问题。 雪花算法生成的ID是一个64位的整数，由以下几个部分组成： 时间戳：41位，精确到毫秒级，可以使用69年。 节点ID：10位，用于标识分布式系统中的不同节点。 序列号：12位，表示在同一毫秒内生成的不同ID的序号。 通过将这三个部分组合在一起，雪花算法可以在分布式系统中生成全局唯一的ID，并保证ID的生成顺序性。 雪花算法的工作方式如下： 当前时间戳从某一固定的起始时间开始计算，可以用于计算ID的时间部分。 节点ID是分布式系统中每个节点的唯一标识，可以通过配置或自动分配的方式获得。 序列号用于记录在同一毫秒内生成的不同ID的序号，从0开始自增，最多支持4096个ID生成。 需要注意的是，雪花算法依赖于系统的时钟，需要确保系统时钟的准确性和单调性，否则可能会导致生成的ID不唯一或不符合预期的顺序。 雪花算法是一种简单但有效的生成唯一ID的算法，广泛应用于分布式系统中，如微服务架构、分布式数据库、分布式锁等场景，以满足全局唯一标识的需求。 你需要记住的: 雪花算法生成的数字,需要使用Long 或者 String类型主键!! @TableField 描述：字段注解（非主键） 123456789@TableName(&quot;sys_user&quot;)public class User &#123; @TableId private Long id; @TableField(&quot;nickname&quot;) private String name; private Integer age; private String email;&#125; MyBatis-Plus会自动开启驼峰命名风格映射!!! MyBatis-Plus高级扩展逻辑删除实现 概念: 逻辑删除，可以方便地实现对数据库记录的逻辑删除而不是物理删除。逻辑删除是指通过更改记录的状态或添加标记字段来模拟删除操作，从而保留了删除前的数据，便于后续的数据分析和恢复。 物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除的数据 逻辑删除：假删除，将对应数据中代表是否被删除字段的状态修改为“被删除状态”，之后在数据库中仍旧能看到此条数据记录 逻辑删除实现: 数据库和实体类添加逻辑删除字段 表添加逻辑删除字段 可以是一个布尔类型、整数类型或枚举类型。 1ALTER TABLE USER ADD deleted INT DEFAULT 0 ; # int 类型 1 逻辑删除 0 未逻辑删除 2. 实体类添加逻辑删除属性 1234567891011121314@Datapublic class User &#123; // @TableId private Integer id; private String name; private Integer age; private String email; @TableLogic //逻辑删除字段 int mybatis-plus下,默认 逻辑删除值为1 未逻辑删除 1 private Integer deleted;&#125; 指定逻辑删除字段和属性值 单一指定 123456789101112@Datapublic class User &#123; // @TableId private Integer id; private String name; private Integer age; private String email; @TableLogic //逻辑删除字段 int mybatis-plus下,默认 逻辑删除值为1 未逻辑删除 1 private Integer deleted;&#125; 2. 全局指定 123456mybatis-plus: global-config: db-config: logic-delete-field: deleted # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2) logic-delete-value: 1 # 逻辑已删除值(默认为 1) logic-not-delete-value: 0 # 逻辑未删除值(默认为 0) 演示逻辑删除操作 逻辑删除以后,没有真正的删除语句,删除改为修改语句! 删除代码: 123456//逻辑删除@Testpublic void testQuick5()&#123; //逻辑删除 userMapper.deleteById(5);&#125; 执行效果: JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@5871a482] will not be managed by Spring &#x3D;&#x3D;&gt; Preparing: UPDATE user SET deleted&#x3D;1 WHERE id&#x3D;? AND deleted&#x3D;0&#x3D;&#x3D;&gt; Parameters: 5(Integer)&lt;&#x3D;&#x3D; Updates: 1 4. 测试查询数据 1234567@Testpublic void testQuick6()&#123; //正常查询.默认查询非逻辑删除数据 userMapper.selectList(null);&#125;//SELECT id,name,age,email,deleted FROM user WHERE deleted=0 乐观锁实现悲观锁和乐观锁场景和介绍**并发问题场景演示:** **解决思路: ** 乐观锁和悲观锁是在并发编程中用于处理并发访问和资源竞争的两种不同的锁机制!! 悲观锁： 悲观锁的基本思想是，在整个数据访问过程中，将共享资源锁定，以确保其他线程或进程不能同时访问和修改该资源。悲观锁的核心思想是”先保护，再修改”。在悲观锁的应用中，线程在访问共享资源之前会获取到锁，并在整个操作过程中保持锁的状态，阻塞其他线程的访问。只有当前线程完成操作后，才会释放锁，让其他线程继续操作资源。这种锁机制可以确保资源独占性和数据的一致性，但是在高并发环境下，悲观锁的效率相对较低。 乐观锁： 乐观锁的基本思想是，认为并发冲突的概率较低，因此不需要提前加锁，而是在数据更新阶段进行冲突检测和处理。乐观锁的核心思想是”先修改，后校验”。在乐观锁的应用中，线程在读取共享资源时不会加锁，而是记录特定的版本信息。当线程准备更新资源时，会先检查该资源的版本信息是否与之前读取的版本信息一致，如果一致则执行更新操作，否则说明有其他线程修改了该资源，需要进行相应的冲突处理。乐观锁通过避免加锁操作，提高了系统的并发性能和吞吐量，但是在并发冲突较为频繁的情况下，乐观锁会导致较多的冲突处理和重试操作。 理解点: 悲观锁和乐观锁是两种解决并发数据问题的思路,不是具体技术!!! **具体技术和方案:** 1. 乐观锁实现方案和技术： - 版本号/时间戳：为数据添加一个版本号或时间戳字段，每次更新数据时，比较当前版本号或时间戳与期望值是否一致，若一致则更新成功，否则表示数据已被修改，需要进行冲突处理。 - CAS（Compare-and-Swap）：使用原子操作比较当前值与旧值是否一致，若一致则进行更新操作，否则重新尝试。 - 无锁数据结构：采用无锁数据结构，如无锁队列、无锁哈希表等，通过使用原子操作实现并发安全。 2. 悲观锁实现方案和技术： - 锁机制：使用传统的锁机制，如互斥锁（Mutex Lock）或读写锁（Read-Write Lock）来保证对共享资源的独占访问。 - 数据库锁：在数据库层面使用行级锁或表级锁来控制并发访问。 - 信号量（Semaphore）：使用信号量来限制对资源的并发访问。 **介绍版本号乐观锁技术的实现流程:** - 每条数据添加一个版本号字段version - 取出记录时，获取当前 version - 更新时，检查获取版本号是不是数据库当前最新版本号 - 如果是[证明没有人修改数据], 执行更新, set 数据更新 , version = version+ 1 - 如果 version 不对[证明有人已经修改了]，我们现在的其他记录就是失效数据!就更新失败 使用mybatis-plus数据使用乐观锁1. 添加版本号更新插件 123456@Beanpublic MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); return interceptor;&#125; 2. 乐观锁字段添加@Version注解 注意: 数据库也需要添加version字段 1ALTER TABLE USER ADD VERSION INT DEFAULT 1 ; # int 类型 乐观锁字段 - 支持的数据类型只有:int,Integer,long,Long,Date,Timestamp,LocalDateTime - 仅支持 `updateById(id)` 与 `update(entity, wrapper)` 方法 12@Versionprivate Integer version; 3. 正常更新使用即可 123456789101112131415//演示乐观锁生效场景@Testpublic void testQuick7()&#123; //步骤1: 先查询,在更新 获取version数据 //同时查询两条,但是version唯一,最后更新的失败 User user = userMapper.selectById(5); User user1 = userMapper.selectById(5); user.setAge(20); user1.setAge(30); userMapper.updateById(user); //乐观锁生效,失败! userMapper.updateById(user1);&#125; 防全表更新和删除实现 针对 update 和 delete 语句 作用: 阻止恶意的全表更新删除 添加防止全表更新和删除拦截器 1234567@Beanpublic MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new BlockAttackInnerInterceptor()); return interceptor;&#125;&#125; 测试全部更新或者删除 123456789@Testpublic void testQuick8()&#123; User user = new User(); user.setName(&quot;custom_name&quot;); user.setEmail(&quot;xxx@mail.com&quot;); //Caused by: com.baomidou.mybatisplus.core.exceptions.MybatisPlusException: Prohibition of table update operation //全局更新,报错 userService.saveOrUpdate(user,null);&#125; MyBatis-Plus代码生成器(MyBatisX插件)Mybatisx插件逆向工程 MyBatis-Plus为我们提供了强大的mapper和service模板，能够大大的提高开发效率 但是在真正开发过程中，MyBatis-Plus并不能为我们解决所有问题，例如一些复杂的SQL，多表联查，我们就需要自己去编写代码和SQL语句，我们该如何快速的解决这个问题呢，这个时候可以使用MyBatisX插件 MyBatisX一款基于 IDEA 的快速开发插件，为效率而生。 MyBatisX快速代码生成 使用mybatisX插件,自动生成sql语句实现 https://baomidou.com/pages/ba5b24/#功能 微头条实战","tags":[{"name":"SSM","slug":"SSM","permalink":"http://example.com/tags/SSM/"}]},{"title":"Prompt Engineering","date":"2023-07-18T07:36:49.000Z","path":"2023/07/18/Prompt-Engineering/","text":"Prompt EngineeringPrompt Engineering, also known as In-Context Prompting, refers to methods for how to communicate with LLM to steer its behavior for desired outcomes without updating the model weights.提示工程，也称为上下文提示，是指如何在不更新模型权重的情况下与LLM通信以引导其行为以获得所需结果的方法。the goal of prompt engineering is about alignment and model steerability.提示工程的核心目标是对齐和模型可控性。 Basic PromptingZero-ShotZero-shot learning is to simply feed the task text to the model and ask for results: 12Text: i&#x27;ll bet the video game is a lot more fun than the film.Sentiment: Few-shotFew-shot learning presents a set of high-quality demonstrations, each consisting of both input and desired output, on the target task. As the model first sees good examples, it can better understand human intention and criteria for what kinds of answers are wanted. Therefore, few-shot learning often leads to better performance than zero-shot. However, it comes at the cost of more token consumption and may hit the context length limit when input and output text are long.但是，它以消耗更多的tokens为代价，并且当输入和输出文本较长时，可能会达到上下文长度限制。 123456789101112Text: (lawrence bounces) all over the stage, dancing, running, sweating, mopping his face and generally displaying the wacky talent that brought him fame in the first place.Sentiment: positiveText: despite all evidence to the contrary, this clunker has somehow managed to pose as an actual feature movie, the kind that charges full admission and gets hyped on tv and purports to amuse small children and ostensible adults.Sentiment: negativeText: for the first time in years, de niro digs deep emotionally, perhaps because he&#x27;s been stirred by the powerful work of his co-stars.Sentiment: positiveText: i&#x27;ll bet the video game is a lot more fun than the film.Sentiment: choice of prompt format, training examples, and the order of the examples can lead to dramatically different performance Calibrate Before Use: Improving Few-Shot Performance of Language Modelshttps://arxiv.org/abs/2102.09690 Tips for Example SelectionTips for Example OrderingInstruction PromptingInstructed LM (e.g. InstructGPT, natural instruction) finetunes a pretrained model with high-quality tuples of (task instruction, input, ground truth output) to make LM better understand user intention and follow instruction.RLHF (Reinforcement Learning from Human Feedback) is a common method to do so. The benefit of instruction following style fine-tuning improves the model to be more aligned with human intention and greatly reduces the cost of communication. When interacting with instruction models, we should describe the task requirement in details, trying to be specific and precise and avoiding say “not do something” but rather specify what to do.具体简洁地指明要做什么 1234Please label the sentiment towards the movie of the given movie review. The sentiment label should be &quot;positive&quot; or &quot;negative&quot;. Text: i&#x27;ll bet the video game is a lot more fun than the film. Sentiment: Explaining the desired audience is another smart way to give instructions解释所需的受众 12Describe what is quantum physics to a 6-year-old. safe content 12... in language that is safe for work. few-shot learning with instruction prompting: In-Context Instruction Learninghttps://arxiv.org/abs/2302.14691 Self-Consistency SamplingSelf-consistency sampling is to sample multiple outputs with temperature &gt; 0 and then selecting the best one out of these candidates. The criteria for selecting the best candidate can vary from task to task. A general solution is to pick majority vote. For tasks that are easy to validate such as a programming question with unit tests, we can simply run through the interpreter and verify the correctness with unit tests.对温度为大于0的多个输出进行采样，然后从这些候选输出中选择最佳输出。选择最佳候选人的标准可能因任务而异。一般的解决方案是选择多数票。 Self-Consistency Improves Chain of Thought Reasoning in Language Modelshttps://arxiv.org/abs/2203.11171 Chain-of-Thought (CoT)Chain-of-thought (CoT) prompting generates a sequence of short sentences to describe reasoning logics step by step, known as reasoning chains or rationales, to eventually lead to the final answer. The benefit of CoT is more pronounced for complicated reasoning tasks, while using large models (e.g. with more than 50B parameters). Simple tasks only benefit slightly from CoT prompting. Chain-of-Thought Prompting Elicits Reasoning in Large Language Modelshttps://arxiv.org/abs/2201.11903 Types of CoT prompts Few-shot CoT. It is to prompt the model with a few demonstrations, each containing manually written (or model-generated) high-quality reasoning chains. 123456789101112131415Question: Tom and Elizabeth have a competition to climb a hill. Elizabeth takes 30 minutes to climb the hill. Tom takes four times as long as Elizabeth does to climb the hill. How many hours does it take Tom to climb up the hill?Answer: It takes Tom 30*4 = &lt;&lt;30*4=120&gt;&gt;120 minutes to climb the hill.It takes Tom 120/60 = &lt;&lt;120/60=2&gt;&gt;2 hours to climb the hill.So the answer is 2.===Question: Jack is a soccer player. He needs to buy two pairs of socks and a pair of soccer shoes. Each pair of socks cost $9.50, and the shoes cost $92. Jack has $40. How much more money does Jack need?Answer: The total cost of two pairs of socks is $9.50 x 2 = $&lt;&lt;9.5*2=19&gt;&gt;19.The total cost of the socks and the shoes is $19 + $92 = $&lt;&lt;19+92=111&gt;&gt;111.Jack need $111 - $40 = $&lt;&lt;111-40=71&gt;&gt;71 more.So the answer is 71.===Question: Marty has 100 centimeters of ribbon that he must cut into 4 equal parts. Each of the cut parts must be divided into 5 equal parts. How long will each final cut be?Answer: Zero-shot CoT. Use natural language statement like “Let’s think step by step” to explicitly encourage the model to first generate reasoning chains and then to prompt with “Therefore, the answer is” to produce answers. Or a similar statement “Let’s work this out it a step by step to be sure we have the right answer”. 123Question: Marty has 100 centimeters of ribbon that he must cut into 4 equal parts. Each of the cut parts must be divided into 5 equal parts. How long will each final cut be?Answer: Let&#x27;s think step by step. Large Language Models are Zero-Shot Reasonershttps://arxiv.org/abs/2205.11916 Large Language Models Are Human-Level Prompt Engineershttps://arxiv.org/abs/2211.01910 PapersChain-of-Thought Prompting Elicits Reasoning in Large Language Models Google Research,Brain Team Motivation: scaling up model size alone has not proved sufficient for achieving high performance on challenging tasks such as arithmetic, commonsense, and symbolic reasoning; First, techniques for arithmetic reasoning can benefit from generating natural language rationales that lead to the final answer; Second, large language models offer the exciting prospect of in-context few-shot learning via prompting. Methods: Chain-of-Thought Prompting First, chain of thought, in principle, allows models to decompose multi-step problems into intermediate steps, which means that additional computation can be allocated to problems that require more reasoning steps; Second, a chain of thought provides an interpretable window into the behavior of the model; Third, chain-of-thought reasoning can be used for tasks such as math word problems, commonsense reasoning, and symbolic manipulation, and is potentially applicable (at least in principle) to any task that humans can solve via language; Finally, chain-of-thought reasoning can be readily elicited in sufficiently large off-the-shelf language models simply by including examples of chain of thought sequences into the exemplars of few-shot prompting. Experiments: Arithmetic Reasoningmanually composed a set of eight few-shot exemplars with chains of thought for prompting chain-of-thought prompting does not positively impact performance for small models, and only yields performance gains when used with models of ∼100B parameters. chain-of-thought prompting has larger performance gains for more-complicated problems. Robustness of Chain of Thought Commonsense Reasoning Symbolic Reasoning Large Language Models are Zero-Shot Reasoners Tokyo University + Google Research,Brain Team NeurIPS 2022 Motivation: Few-shot-CoT requiring human engineering of multi-step reasoning prompts; their performance deteriorates if prompt example question types and task question type are unmatched, suggesting high sensitivity to per-task prompt designs; these successes are often attributed to LLMs’ ability for few-shot learning. Methods: Zero-shot-CoT : Zero-shot Chain of Thought Two-stage prompting: Experiments: Zero-shot-CoT vs. Zero-shot Comparison with other baselines Does model size matter for zero-shot reasoning? How does prompt selection affect Zero-shot-CoT? How does prompt selection affect Few-shot-CoT? Automatic Chain of Thought Prompting in Large Language Models Amazon Web Servicescode: https://github.com/amazon-research/auto-cot Motivation: CoT prompting has two major paradigms. One leverages a simple prompt like “Let’s think step by step” to facilitate step-by-step thinking before answering a question. The other uses a few manual demonstrations one by one, each composed of a question and a reasoning chain that leads to an answer. The superior performance of the second paradigm hinges on the hand-crafting of task-specificdemonstrations one by one. these generated chains by first paradigm often come with mistakes. Methods: Auto-CoT : samples questions with diversity and generates reasoning chains to construct demonstrations (1) Retrieval-Q-CoT and Random-Q-CoT - Retrieval-Q-CoT Fails due to Misleading by Similarity - Errors Frequently Fall into the Same Cluster (2) Diversity May Mitigate Misleading by Similarity Experiments: Competitive Performance of Auto-CoT on Ten Datasets Effect of Wrong Demonstrations General Effectiveness Using the Codex LLM Self-consistency Improves Chain of Thought Reasoning in Language Models Google Research,Brain Team ICLR 2023 Motivation: Although language models have demonstrated remarkable success across a range of NLP tasks, their ability to demonstrate reasoning is often seen as a limitation, which cannot be overcome solely by increasing model scale; The Greedy Decoding of traditional chain-of-thought prompting: the repetitiveness,local-optimality, and the stochasticity of a single sampled generation. Methods: self-consistency,a new decoding strategy. It first samples a diverse set of reasoning paths instead of only taking the greedy one, and then selects the most consistent answer by marginalizing out the sampled reasoning paths. Self-consistency leverages the intuition that a complex reasoning problem typically admits multiple different ways of thinking leading to its unique correct answer. Experiments: test accuracy over a set of reasoning tasks by using different answer aggregation strategies Arithmetic Reasoning Commonsense and Symbolic Reasoning the num of sampled reasoning paths Self-Consistency helps when Chain-Of-Thought hurts performance Self-Consistency is Robust to Sampling Strategies and Scaling Self-Consistency Improves Robustness to Imperfect Prompts Rationale-Augmented Ensembles in Language Models Google Research,Brain Team Motivation: existing approaches, which rely on manual prompt engineering, are subject to sub-optimal rationales that may harm performance. Methods: Rationale-Augmented Ensembles , where we identify rationale sampling in the output space as the key component to robustly improve performance.(1) Optimality of the rationales in few-shot learning the addition of human-written rationales does not always yield better performances; the quality of the rationales in the prompts has a significant effect on final performance; simply including a rationale does not always improve task performance. (2) Rationale-augmented ensembles(that can automatically aggregate across diverse rationales to overcome the brittleness of performance to sub-optimal human-written rationales) Experiments: results for the PaLM-540B model(1) the “output-sampled” version yields better final performance than the “output-greedy” version for almost every task;(2) The “output-sampled” version of each rationale-ensembling method almost always improves performance over standard prompting without rationales, as well as rationale-based few-shot and zero-shot prompting;(3) rationale-augmented ensembles provide a reliable approach to improving the final task performance of rationale-based few-shot in-context learning. Interpretability of model predictions is also enhanced by the presence of generated rationales in the model outputs. Results on GPT-3 Effect of K in K-shot in-context learning &amp; Effect of templates and verbalizers Least-to-Most Prompting Enables Complex Reasoning in Large Language Models Google Research,Brain Team ICLR 2023 Motivation: Chain-of-thought prompting tends to perform poorly on tasks which requires solving problems harder than the exemplars shown in the prompts. Methods: least-to-most prompting, to break down a complex problem into a series of simpler subproblems and then solve them in sequence.(1) query the language model to decompose the problem into subproblems;(2) query the language model to sequentially solve the subproblems. The answer to the second subproblem is built on the answer to the first subproblem. Experiments: SYMBOLIC MANIPULATION COMPOSITIONAL GENERALIZATION MATH REASONING Compositional Semantic Parsing with Large Language Models Google Research + UMass Amherst CICS Motivation: SCAN is an artificial task built upon a synthetic language with a tiny vocabulary and is generated from a small set of grammar rules, and it is unclear whether least-to-most prompting‘s strong results transfer to more realistic tasks that are based on a larger vocabulary and more complicated grammars. decomposing a problem is more difficult. translation of constituents is context-dependent. Methods: dynamic least-to-most prompting (1) tree-structured decomposition of natural language inputs through LM-predicted syntactic parsing; 通过lm预测的语法解析对自然语言输入进行树结构分解; (2) use the decomposition to dynamically select exemplars; 使用分解动态选择范例; - Top-down matching: anonymize the decomposition tree of the input; Starting at the top of the anonymized tree, we use a heuristic approach to find exemplars such that all nodes are covered, prioritizing exemplars that match large subtrees. - Bottom-up matching: Then, we try to make sure that all leaf phrases are covered by an exemplar. If there is more than one exemplar for a certain phrase, we prefer exemplars where the phrase occurs within a similar anonymized subtree. (3) linearize the decomposition tree and prompt the model to sequentially generate answers to subproblems. 将分解树线性化，并提示模型按顺序生成子问题的答案。 Experiments: CFQ COGS Is dynamic least-to-most more effective than other prompting methods? &amp; How many exemplars are needed in the pool? Measuring and Narrowing the Compositionality Gap in Language Models Paul G. Allen School of Computer Science &amp; Engineering, University of Washingtoncode : https://github.com/ofirpress/self-ask Motivation: SCAN is an artificial task built upon a synthetic language with a tiny vocabulary and is generated from a small set of grammar rules, and it is unclear whether least-to-most prompting‘s strong results transfer to more realistic tasks that are based on a larger vocabulary and more complicated grammars. decomposing a problem is more difficult. translation of constituents is context-dependent. Methods: dynamic least-to-most prompting (1) tree-structured decomposition of natural language inputs through LM-predicted syntactic parsing; 通过lm预测的语法解析对自然语言输入进行树结构分解; (2) use the decomposition to dynamically select exemplars; 使用分解动态选择范例; - Top-down matching: anonymize the decomposition tree of the input; Starting at the top of the anonymized tree, we use a heuristic approach to find exemplars such that all nodes are covered, prioritizing exemplars that match large subtrees. - Bottom-up matching: Then, we try to make sure that all leaf phrases are covered by an exemplar. If there is more than one exemplar for a certain phrase, we prefer exemplars where the phrase occurs within a similar anonymized subtree. (3) linearize the decomposition tree and prompt the model to sequentially generate answers to subproblems. 将分解树线性化，并提示模型按顺序生成子问题的答案。 Experiments: CFQ COGS Is dynamic least-to-most more effective than other prompting methods? &amp; How many exemplars are needed in the pool? STaR: Bootstrapping Reasoning With ReasoningMaking Large Language Models Better Reasoners with Step-Aware VerifierLanguage Models are Multilingual Chain-of-Thought ReasonersChain of Thought Prompting Elicits Knowledge Augmentation Tsinghua + Ruc ACL Findings 2023 Motivation: Conventional knowledge-augmented deep learning methods typically employ task-specific approaches to gather external knowledge from various sources; In contrast, large language models are extensively pre-trained and can serve as a comprehensive source of external knowledge. Methods: CoT-KA, a Chain-of-Thought-based method that augments knowledge for deep learning. CoT-KA avoids the need for additional knowledge retrieval or knowledge reasoning models. (1) CoT Generation: Generating multiple CoTs for each sample in the train, dev, and test sets. (2) Input Augmentation: Taking the generated CoTs as the additional knowledge into the original input text for each sample. (3) Task-relevant Model Training: Fine-tuning a task-relevant model using the CoT-augmented samples. Experiments: NLU tasks NLG tasks explore the effectiveness of CoT-augmented fine-tuning by simply appending one CoT to the original input. GPT-3 (text-davinci-002) Given that the answers within CoTs can potentially be incorrect, we hypothesize that this portion of the CoTs will have a negative effect on the fine-tuning and mislead the model’s prediction. Knowledge Augmentation Comparison The Effect of CoT Size CoT Selection Strategy","tags":[{"name":"LLM","slug":"LLM","permalink":"http://example.com/tags/LLM/"}]},{"title":"offer-redis6","date":"2023-07-10T05:40:33.000Z","path":"2023/07/10/offer-redis6/","text":"Redis6NoSQL数据库解决性能的问题： 解决CPU及内存压力（如session问题） 解决IO压力（缓存数据库，减少IO的读操作） 概述NoSQL(NoSQL &#x3D; Not Only SQL )，意即“不仅仅是SQL”，泛指非关系型的数据库。NoSQL不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。 不遵循SQL标准。 不支持ACID。 远超于SQL的性能。适用场景： 对数据高并发的读写 海量数据的读写 对数据高可扩展性的不适用场景： 需要事务支持 基于sql的结构化查询存储，处理复杂的关系,需要即席查询。 具体数据库：Memcache、Redis、MongoDB等。 Redis概述 Redis是一个开源的key-value存储系统。 它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。 这些数据类型都支持push&#x2F;pop、add&#x2F;remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。 在此基础上，Redis支持各种不同方式的排序。 与memcached一样，为了保证效率，数据都是缓存在内存中。 区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。 并且在此基础上实现了master-slave(主从)同步。 默认端口号：6379 默认16个数据库，类似数组下标从0开始，初始默认使用0号库；切换数据库如: select 8。统一密码管理，所有库同样密码。dbsize查看当前数据库的key的数量；flushdb清空当前库；flushall通杀全部库。 串行 vs 多线程+锁（memcached） vs 单线程+多路IO复用(Redis) 常用数据类型 http://www.redis.cn/commands.html Redis键（key） keys *查看当前库所有key (匹配：keys *1) exists key判断某个key是否存在 type key 查看你的key是什么类型 del key 删除指定的key数据 unlink key 根据value选择非阻塞删除 仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。 expire key 10 10秒钟：为给定的key设置过期时间 ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期 字符串（String） String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。 String类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。 String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M 常用命令： set &lt;key&gt; &lt;value&gt; 添加键值对 *NX：当数据库中key不存在时，可以将key-value添加数据库 *XX：当数据库中key存在时，可以将key-value添加数据库，与NX参数互斥 *EX：key的超时秒数 *PX：key的超时毫秒数，与EX互斥 get &lt;key&gt; 查询对应键值 append &lt;key&gt; &lt;value&gt;将给定的&lt;value&gt;追加到原值的末尾 strlen &lt;key&gt;获得值的长度 setnx &lt;key&gt; &lt;value&gt;只有在 key 不存在时，才能设置 key 的值 incr &lt;key&gt; 将 key 中储存的数字值增1；只能对数字值操作，如果为空，新增值为1。（原子操作） decr &lt;key&gt; 将 key 中储存的数字值减1；只能对数字值操作，如果为空，新增值为-1 incrby &#x2F; decrby &lt;key&gt; &lt;步长&gt; 将 key 中储存的数字值增减。自定义步长。 mset key1 value1 key2 value2 ….. 同时设置一个或多个 key-value对 mget key1 key2 key3 ….. 同时获取一个或多个 value msetnx key1 value1 key2 value2 ….. 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。 getrange &lt;key&gt; &lt;起始位置&gt;&lt;结束位置&gt; 获得值的范围，类似java中的substring，前包，后包 setrange &lt;key&gt; &lt;起始位置&gt; &lt;value&gt; 用 &lt;value&gt;覆写&lt;key&gt;所储存的字符串值，从&lt;起始位置&gt;开始(索引从0开始)。 setex &lt;key&gt; &lt;过期时间&gt; &lt;value&gt; 设置键值的同时，设置过期时间，单位秒。 getset &lt;key&gt; &lt;value&gt; 以新换旧，设置了新值同时获得旧值。 列表（List） 单键多值，Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。 它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。 常用命令： lpush&#x2F;rpush key value1 value2 value3 …. 从左边&#x2F;右边插入一个或多个值。 lpop&#x2F;rpop key 从左边&#x2F;右边吐出一个值。值在键在，值光键亡。 rpoplpush key1 key2 从key1列表右边吐出一个值，插到key2列表左边。 lrange &lt;key&gt; &lt;start&gt; &lt;stop&gt; 按照索引下标获得元素(从左到右) lrange mylist 0 -1 0左边第一个，-1右边第一个，（0-1表示获取所有） lindex &lt;key&gt; &lt;index&gt; 按照索引下标获得元素(从左到右) llen &lt;key&gt; 获得列表长度 linsert &lt;key&gt; before &lt;value&gt; &lt;newvalue&gt;在&lt;value&gt;的后面插入&lt;newvalue&gt;插入值 lrem &lt;key&gt; &lt;n&gt; &lt;value&gt; 从左边删除n个value(从左到右) lset &lt;key&gt; &lt;index&gt; &lt;value&gt; 将列表key下标为index的值替换成value 集合（Set） Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。 Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的复杂度都是O(1)。 一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变。 常用命令： sadd key value1 value2 ….. 将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略 smembers key 取出该集合的所有值。 sismember key value 判断集合key是否为含有该value值，有1，没有0 scard key 返回该集合的元素个数。 srem key value1 value2 …. 删除集合中的某个元素。 spop key 随机从该集合中吐出一个值。 srandmember key n 随机从该集合中取出n个值。不会从集合中删除 。 smove source destination value 把集合中一个值从一个集合移动到另一个集合 sinter key1 key2 返回两个集合的交集元素。 sunion key1 key2 返回两个集合的并集元素。 sdiff key1 key2 返回两个集合的差集元素(key1中的，不包含key2中的) 哈希（Hash） Redis hash 是一个键值对集合。 Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。 类似Java里面的Map&lt;String,Object&gt; 用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key&#x2F;value结构来存储 常用命令： hset key field value 给key集合中的field键赋值value hget key1 field 从key1集合field取出value hmset key1 field1 value field2 value2 … 批量设置hash的值 hexists key1 field 查看哈希表 key 中，给定域 field 是否存在。 hkeys key 列出该hash集合的所有field hvals key 列出该hash集合的所有value hincrby key field increment为哈希表 key 中的域 field 的值加上增量 1 -1 hsetnx key field value 将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在。 有序集合（Zset） Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。 不同之处是有序集合的每个成员都关联了一个评分（score）,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。 因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。 访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。 底层结构：跳跃表 常用命令： zadd key score1 value1 score2 value2 …. 将一个或多个 member 元素及其 score 值加入到有序集 key 当中。 zrange key start stop WITHSCORES 返回有序集 key 中，下标在start stop之间的元素，带WITHSCORES，可以让分数一起和值返回到结果集。 zrangebyscore key min max withscores ‘limit offset count’ 返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。 zrevrangebyscore key max min withscores ‘limit offset count’ 同上，改为从大到小排列。 zincrby key increment value 为元素的score加上增量 zrem key value 删除该集合下，指定值的元素 zcount key min max 统计该集合，分数区间内的元素个数 zrank key value 返回该值在集合中的排名，从0开始。 Bitmaps(new)Redis提供了Bitmaps这个“数据类型”可以实现对位的操作： Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。 Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。 常用命令： setbit设置Bitmaps中某个偏移量的值（0或1） getbit获取Bitmaps中某个偏移量的值 bitcount统计字符串被设置为1的bit数 bitop：是一个复合操作， 它可以做多个Bitmaps的and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在destkey中。 Bitmaps与set对比：假设网站有1亿用户， 每天独立访问的用户有5千万，这种情况下使用Bitmaps能节省很多的内存空间， 尤其是随着时间推移节省的内存还是非常可观的。但Bitmaps并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有10万（大量的僵尸用户），这时候使用Bitmaps就不太合适了， 因为基本上大部分位都是0。 HyperLogLog(new)Redis HyperLogLog 是用来做基数（不重复元素）统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。 常用命令： pfadd添加指定元素到 HyperLogLog 中，如果执行命令后HLL估计的近似基数发生变化，则返回1，否则返回0。 pfcount计算HLL的近似基数，可以计算多个HLL，比如用HLL存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可。 pfmerge将一个或多个HLL合并后的结果存储在另一个HLL中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得。 Geospatial(new)Redis 3.2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。 常用命令： geoadd添加地理位置（经度，纬度，名称） geopos获得指定地区的坐标值 geodist获取两个位置之间的直线距离 georadius以给定的经纬度为中心，找出某一半径内的元素 Redis配置文件redis.conf ###Units单位### 配置大小单位,开头定义了一些基本的度量单位，只支持bytes，不支持bit，大小写不敏感2. ###INCLUDES包含###类似jsp中的include，多实例的情况可以把公用的配置文件提取出来3. ###网络相关配置###默认情况bind&#x3D;127.0.0.1只能接受本机的访问请求；不写的情况下，无限制接受任何ip地址的访问；生产环境肯定要写你应用服务器的地址；服务器是需要远程访问的，所以需要将其注释掉；如果开启了protected-mode，那么在没有设定bind ip且没有设密码的情况下，Redis只允许接受本机的响应。tcp-backlog设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和&#x3D;未完成三次握手队列 + 已经完成三次握手队列。在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。timeout代表一个空闲的客户端维持多少秒会关闭，0表示关闭该功能。即永不关闭。tcp-keepalive代表对访问客户端的一种心跳检测，每个n秒检测一次。单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60。4. ###GENERAL通用###daemonize是否为后台进程，设置为yes，守护进程，后台启动。pidfile存放pid文件的位置，每个实例会产生一个不同的pid文件。loglevel指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为notice。logfile日志文件名称。5. ###SECURITY安全###设置密码6. ###LIMITS限制###maxclients设置redis同时可以与多少个客户端进行连接。默认情况下为10000个客户端。如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。maxmemory 建议必须设置，否则，将内存占满，造成服务器宕机。maxmemory-policy、maxmemory-samples。 Redis的发布和订阅 Redis 发布订阅 (pub&#x2F;sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。 Redis 客户端可以订阅任意数量的频道。 命令行实现： SUBSCRIBE channel1 publish channel1 hello Jedis案例-模拟验证码发送案例描述： 输入手机号，点击发送后随机生成6位数字码，2分钟有效 输入验证码，点击验证，返回成功或失败 每个手机号每天只能输入3次实现分析： 生成随机6位数字验证码：Random 验证码在两分钟内有效：把验证码放到redis里面，设置过期时间为120秒 判断验证码是否一直：从redis获取验证码和输入的验证码进行比较 每个手机每天只能发送3次验证码：incr每次发送之后+1，大于2时候，提交不能发送","tags":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"}]},{"title":"offer-javaweb","date":"2023-07-06T04:29:03.000Z","path":"2023/07/06/offer-javaweb/","text":"JAVAWEBHTML HTML是解释型的文本标记语言，不区分大小写 html,head,title,meta,body,br,p,hr,div,table,form,u,i,b,sup,sub,&amp;nbsp,span,ul,ol,li,tr,td,th,h1-h6,a,input,select,textarea,img 2-1. html , head , title , meta , body , br , ul , ol , h1-h6 , a , img , &amp;nbsp, p , div , span 2-2. table tr , th , td 2-3. form(action&#x3D;’’ , method&#x3D;’post’) input type&#x3D;’text,pasword,radio,checkbox,submit,button,reset” select , textarea 2-4. frameset表示页面框架、frame表示框架中的具体页面引用；iframe在一个页面嵌入一个子页面。 CSS简介层叠式样式表被style标签包围的环境为CSS环境，可以写CSS代码，值 “text&#x2F;css” 指示内容是标准的 CSS。 1234&lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt; CSS的分类：标签样式表、类样式表、ID样式表、组合样式表CSS从位置上的分类：嵌入样式表、内部样式表、外部样式表 盒子模型 border(-top&#x2F;-left…) margin 和 padding 注意浏览器的兼容问题！tips： 12345678910111213body&#123; margin:0; padding:0;&#125;``` ### CSS布局 position: absolute -- 绝对定位 , 需要配合使用 left , top relative -- 相对定位 , 一般会和 float , margin , padding .... 一起使用 ## JavaScript Javascript : 客户端的一个脚本语言 js是一门弱类型的语言 , 变量的数据类型由后面赋的值的类型决定 &lt;script language=&quot;javascript&quot;&gt; /* var str = &quot;hello world&quot;; alert(typeof str); str = 9999 ; alert(typeof str); */ /* var person = new Object(); person.pid = &quot;p001&quot;; person.pname=&quot;鸠摩智&quot;; alert(person.pid+&quot;_&quot;+person.pname); */ //java 方法 public String hello(String name)&#123; return &quot;hello to &quot; + name ; &#125; //js 方法 function hello(num1 , num2 , name)&#123; if(num1&gt;num2)&#123; return &quot;hello to&quot; + name ; &#125;else&#123; alert(&quot;HELLO&quot;); &#125; &#125; &lt;/script&gt; ## WEB 1. C/S：客户端服务器架构模式 优点：充分利用客户端机器的资源，减轻服务器的负荷（一部分安全要求不高的计算任务存储任务放在客户端执行，不需要把所有的计算和存储都在服务器端执行，从而能够减轻服务器的压力，也能够减轻网络负荷） 缺点：需要安装客户端；升级维护成本较高 2. B/S：浏览器服务器架构模式 优点：客户端不需要安装；维护成本较低 缺点：所有的计算和存储任务都是放在服务器端，服务器的负荷较重；在服务端计算完成之后把结果再传输给客户端，因此客户端和服务端会进行非常频繁的数据通信，从而网络负荷较重 ### Tomcat Web容器： 1. Tomcat的安装和配置 * 解压:不要有中文不要有空格 * 目录结构说明 : bin 可执行文件目录 conf 配置文件目录 lib 存放lib的目录 logs 日志文件目录 webapps 项目部署的目录 work 工作目录 temp 临时目录 deploy :部署 baidu&gt; context root * 配置环境变量，让tomcat能够运行因为tomcat也是用java和C来写的，因此需要JRE，所以需要配置JAVA HOME * 启动tomcat，然后访问主页 2. 新建Web项目，并在tomcat中部署最后再访问 ### Servlet #### 使用场景 1. 用户在html的表单添加请求，action=&quot;add&quot;，method=&quot;post&quot; 2. 新建AddServlet文件，继承HttpServlet，重写doPost或doGet方法，通过request.getParameter根据name值获取表单中的属性，以及添加其他有关数据库的代码。 3. WEB-INFO目录下的web.xml文件中添加映射配置： ```xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;AddServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.atguigu.servlets.AddServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;AddServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/add&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 1. 用户发请求，action=add 2. 项目中，web.xml中找到url-pattern = /add -&gt; 第12行 3. 找第11行的servlet-name = AddServlet 4. 找和servlet-mapping中servlet-name一致的servlet ， 找到第7行 5. 找第8行的servlet-class -&gt; com.atguigu.servlets.AddServlet 6. 用户发送的是post请求（method=post） ， 因此 tomcat会执行AddServlet中的doPost方法 --&gt; &lt;/web-app&gt; 可以通过welcome-file-list标签进行设置欢迎页(在tomcat的web.xml中设置，或者在自己项目的web.xml中设置)。 设置编码post方式下，doPost开头设置编码，在所有获取参数动作之前，防止中文乱码 request.setCharacterEncoding(&quot;UTF-8&quot;); get方式目前不需要设置编码（基于tomcat8），tomcat8之前，设置编码，.getBytes(“xxx”)，再重新组装成格式 Servlet的继承关系 继承关系 javax.servlet.Servlet接口 javax.servlet.GenericServlet抽象类 javax.servlet.http.HttpServlet抽象子类 相关方法 javax.servlet.Servlet接口: void init(config) - 初始化方法 void service(request,response) - 服务方法 void destory() - 销毁方法 javax.servlet.GenericServlet抽象类： void service(request,response) - 仍然是抽象的 javax.servlet.http.HttpServlet 抽象子类： void service(request,response) - 不是抽象的 String method &#x3D; req.getMethod(); 获取请求的方式 各种if判断，根据请求方式不同，决定去调用不同的do方法 if (method.equals(“GET”)) { this.doGet(req,resp); } else if (method.equals(“HEAD”)) { this.doHead(req, resp); } else if (method.equals(“POST”)) { this.doPost(req, resp); } else if (method.equals(“PUT”)) {}… 在HttpServlet这个抽象类中，do方法都差不多: protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String protocol = req.getProtocol(); String msg = lStrings.getString(&quot;http.method_get_not_supported&quot;); if (protocol.endsWith(&quot;1.1&quot;)) &#123; resp.sendError(405, msg); &#125; else &#123; resp.sendError(400, msg); &#125; &#125; Servlet的生命周期 生命周期：从出生到死亡的过程就是生命周期。对应Servlet中的三个方法：init(),service(),destroy() 默认情况下： 第一次接收请求时，这个Servlet会进行实例化(调用构造方法)、初始化(调用init())、然后服务(调用service()) 从第二次请求开始，每一次都是服务 当容器关闭时，其中的所有的servlet实例会被销毁，调用销毁方法 通过案例我们发现： Servlet实例tomcat只会创建一个，所有的请求都是这个实例去响应。 默认情况下，第一次请求时，tomcat才会去实例化，初始化，然后再服务.这样的好处是什么？ 提高系统的启动速度 。 这样的缺点是什么？ 第一次请求时，耗时较长。 因此得出结论： 如果需要提高系统的启动速度，当前默认情况就是这样。如果需要提高响应速度，我们应该设置Servlet的初始化时机。 Servlet的初始化时机： 默认是第一次接收请求时，实例化，初始化 我们可以通过load-on-startup来设置servlet启动的先后顺序，数字越小，启动越靠前，最小值0 Servlet在容器中是：单例的、线程不安全的 单例：所有的请求都是同一个实例去响应 线程不安全：一个线程需要根据这个实例中的某个成员变量值去做逻辑判断。但是在中间某个时机，另一个线程改变了这个成员变量的值，从而导致第一个线程的执行路径发生了变化 我们已经知道了servlet是线程不安全的，给我们的启发是： 尽量的不要在servlet中定义成员变量。如果不得不定义成员变量，那么不要去：①不要去修改成员变量的值 ②不要去根据成员变量的值做一些逻辑判断 Http协议 HTTP：Hyper Text Transfer Protocol 超文本传输协议 Http是无状态的，包含 请求和响应 两个部分 Http请求报文包含三个部分：请求行、请求消息头、请求主题 请求行：请求方式、访问地址URL、请求的协议（一般是http1.1） 请求消息头：通过具体的参数对本次请求进行具体的说明，包含许多键值对 请求体：① get方式，没有请求体，但有queryString ② post方式，有请求体 form data ③ json格式，有请求体，request payload Http响应报文也包含三个部分：响应行、响应消息头、响应体 响应行：协议、响应状态码、响应状态 响应消息头：包含了服务器的信息；服务器发送给浏览器的信息（内容的媒体类型、编码、内容长度等） 响应体：响应的实际内容（比如请求xxx.html页面时，响应的内容就是&lt;html&gt;&lt;head&gt;&lt;body&gt;&lt;form&gt;） 会话Session Http是无状态的：服务器无法判断这两次请求时同一个客户端发过来的，还是不同的客户端发过来的。 带的问题：无法区分同一个用户，导致混乱 通过会话跟踪技术来解决无状态问题 客户端第一次发请求给服务器，服务器获取session，获取不到，则创建新的，然后响应给客户端 下次客户端给服务器发请求时，会把sessionID带给服务器，那么服务器就能获取到了，那么服务器就判断这一次请求和上次某次请求是同一个客户端，从而能够区分开客户端 常用的API: request.getSession() -&gt; 获取当前的会话，没有则创建一个新的会话 request.getSession(true) -&gt; 效果和不带参数相同 request.getSession(false) -&gt; 获取当前会话，没有则返回null，不会创建新的 session.getId() -&gt; 获取sessionID session.isNew() -&gt; 判断当前session是否是新的 session.getMaxInactiveInterval() -&gt; session的非激活间隔时长，默认1800秒 session.setMaxInactiveInterval() session.invalidate() -&gt; 强制性让会话立即失效 session.getAttribute()&#x2F;setAttribute(key,value)，removeAttribute() …. session保存作用域时和具体的某一个session对应的 服务器内部转发以及客户端重定向 服务器内部转发：request.getRequestDispatcher(“…”).forward(request,response); 一次请求响应的过程，对于客户端而言，内部经过了多少次转发，客户端是不知道的 地址栏没有变化 客户端重定向：response.sendRedirect(“…”); 两次请求响应的过程。客户端肯定知道请求URL有变化 地址栏有变化 Thymeleaf","tags":[{"name":"Web","slug":"Web","permalink":"http://example.com/tags/Web/"}]},{"title":"offer-Nginx","date":"2023-05-10T13:54:52.000Z","path":"2023/05/10/offer-Nginx/","text":"Nginx","tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/tags/JAVA/"}]},{"title":"Dialog Papers","date":"2023-04-27T09:05:08.000Z","path":"2023/04/27/Dialog-Papers/","text":"1 Target-Guided Open-Domain Conversation(ACL 2019) code: https://github.com/squareRoot3/Target-Guided-Conversation motivation: we want a conversational system to chat naturally with human and proactively guide the conversation to a designated target subject approach: propose a structured approach that introduces coarse-grained keywords to control the intended content of system responses. then attain smooth conversation transition through turn-level supervised learning, and drive the conversation towards the target with discourse-level constraints. further derive a keyword-augmented conversation dataset for the study. divide-and-conquer approach Turn-level Keyword Transitionthis module aims to predict keywords of the next response that is appropriate in the conversation context. This part is agnostic to the end target,and therefore aligns with the conventional chitchat objective. We thus can use any open-ended chat data with extracted utterance keywords tolearn the prediction module in a supervised manner. Pairwise PMI-based Transitiongiven two keywords wi and wj , computes likeliness of wj → wi: PMI(wi, wj ) &#x3D; log p(wi|wj )&#x2F;p(wi) where p(wi|wj ) is the ratio of transitioning to wi in the next turn given wj in the current turn, and p(wi) is the ratio of wi occurrence. The approach enjoys simplicity and interpretability, yet can suffer from data sparsity and perform poorly with a priori unseen transition pairs. Neural-based Predictionfirst use a recurrent network to encode the conversation history, and feed the resulting features to a prediction layer to obtain a distribution over keywords for the next turn.The network is learned by maximizing the likelihood of observed keywords in the data. The neural approach is straightforward, but can rely on a large amount of data for learning. Hybrid Kernel-based Method*given a pair of a current keyword and a candidate next keyword, by first measuring the cosine similarity of their normalized word embeddings, and feeding the quantity to a kernel layer consisting of K RBF kernels.The output of the kernel layer is a K-dimension kernel feature vector, which is then fed to a single-unit dense layer for a candidate score.The score is finally normalized across all candidate keywords to yield the candidate probability distribution. Discourse-level Target-Guided StrategyThis module aims to fulfill the end target by proactively driving the discussion topic forward in the course of the conversation. constrain that the keyword of each turn must move strictly closer to the end target compared to those of preceding turns. use cosine similarity between normalized word embeddings as the measure of keyword closeness. the above constraint first collects a set of valid candidates, and the turn-level transition module samples or picks the most likely one the from the set according to the keyword distribution. the predicted keyword for next response can be both a smooth transition and an effective step towards the target. Keyword-augmented Response RetrievalThe final module in the system aims to produce a response conditioning on both the conversation history and the predicted keyword. retrieval-based approach* or generation-based method Datasetthe PersonaChat corpus: The conversations cover a broadrange of topics such as work, family, personal interest, etc; and the discussion topics change frequently during the course of the conversations.These properties make the conversations particularly suitable for learning smooth, natural transitions at each turn. without end targets and do not exhibit target-guided behaviors *apply a rule-based keyword extractor which combines TF-IDF and Part-Of Speech features for scoring word salience Case Study 2 Target-Guided Open-Domain Conversation Planning (COLING 2022) code:https://github.com/y-kishinami/TGCP motivation: Prior studies addressing target-oriented conversational tasks lack a crucial notion that has been intensively studied in the context of goaloriented artificial intelligence agents, namely,planning contributions: propose the TGCP task as a framework to assess the prerequisite ability of a model for goal-oriented conversation planning conduct a set of experiments on the TGCP framework usingseveral existing retrieval-based neural models and recently proposed strong generative neural models of conversational agents Our experimental results reveal the challenges facing current technology Using TGCP, we revealed that the dialogue models with current technology have difficulty planning conversations to achieve given goals while ensuring the naturalness of the conversation. The experimental results also showed that refining the subgoal strategies for generative models might be an effective method to overcome this trade-off. 3 Conversational Graph Grounded Policy Learning for Open-Domain Conversation Generation(ACL 2020) motivation: utterance-level methods tend to produce less coherent multi-turn dialogs since it is quite challenging to learn semantic transitions in a dialog flow merely from dialog data without the help of prior information approach：propose to represent prior information about dialog transitions as a graph and learn a graph grounded dialog policy, aimed at fostering a more coherent and controllable dialog. a Conversational Graph (CG) that captures both localappropriateness and global-coherence information, a reinforcement learning (RL) based policy，model that learns to leverage the CG to foster a more coherent dialog. Conversational Graph (CG)use vertices to represent utterance content, and edges to represent dialog transitions between utterances： a what-vertex that contains a keyword a how-vertex that contains a responding mechanism (from a multi-mapping based generator) to capture rich variability of expressionsalso use this multi-mapping based method to build edges between two what-vertices to capture the local-appropriateness between the two keywords as a message and a response respectively Given a user message, to obtain candidate actions, the NLU module attempts to retrieve contextually relevant subgraphs from CG. The state&#x2F;action module maintains candidate actions, history keywords that selected by policy at previous turns or mentioned by user, and the message. The policy module learns to select a response keyword and aresponding mechanism from the above subgraphs. The NLG module first encodes the message into a representation using a message encoder and the selected mechanism, and then employs a Seq2BFmodel (Mou et al., 2016) to produce a response with the above representation and the selected keyword as input. Background: Multi-mapping Generator for NLG CG ConstructionGiven a dialog corpus D, we construct the CG with three steps: what-vertex construction:use a rule-based keyword extractor to obtain salient keywords from utterances in D how-vertex construction: a set of responding mechanisms from the generator edge construction: One is to join two what-vertices:selecting top five keywords decoded (decoding length is 1) by each responding mechanism the other is to join a what-vertex and a how-vertex:use the ground-truth response to select the most suitable mechanism for each keyword.select top five mechanisms that are frequently selected for vw’s keyword NLUTo obtain subgraphs to provide high-quality candidate actions: extract keywords in the last utterance of the context (message) using the same tool in CG construction link each keyword to the CG through exact string matching, to obtain multiple hit what-vertices retrieve a subgraph for each keyword, and use vertices (exclude hit what-vertices) in these subgraphs as candidate actions State&#x2F;ActionThis module maintains candidate actions, history keywords that selected by the policy or mentioned by user, and the message. Policy State representation： concatenate a message representation and a history keywords representation + a graph attention mechanism and graph embedding to encode global structure information into state representation Policy decision： what-policy selects a what-vertex from candidate what-vertices how-policy selects a how-vertex from how-vertex neighbors of the selected what-vertex Rewardsutterance-level rewards: Local relevance：DualEncoder in (Lowe et al., 2015) Repetition：Repetition penalty is 1 if the generated response shares more than 60% words with any contextual utterances, otherwise 0 Target similarity：calculate cosine similarity between the chosen keyword and the target word in pretrained word embedding space as target similarity To leverage the global graph structure information of CG to facilitate policy learning： Global coherence： the average cosine distance between the chosen what-vertex and one of history what-vertices (selected or mentioned previously) in TransE based embedding space Sustainability： calculate a PageRank score (calculated on the full CG) for the chosen whatvertex Shortest path distance to the target：closer 1;otherwise 0;not change -1 NLGfeed the keyword in the selected what-vertex and r¯ into a Seq2BF decoder (Mou et al., 2016) for response generation.","tags":[{"name":"Dialog","slug":"Dialog","permalink":"http://example.com/tags/Dialog/"}]},{"title":"offer---Java","date":"2023-04-10T11:13:37.000Z","path":"2023/04/10/offer-Java/","text":"Java基础Java程序编写和执行流程 编写。 .java结尾的源文件 编译。 对源文件编译成.class， “javac xxx.java” 运行。 “java 字节码文件名” 企业真题（一）1.一个”.java”源文件中是否可以包括多个类？有什么限制(明*数据)是！ 一个源文件中可以声明多个类，但是最多只能有一个类使用public进行声明。且要求声明为public的类的类名与源文件名相同。 2.Java 的优势（阿**巴） 跨平台型 安全性高 简单性 高性能 面向对象性 健壮性 3.常用的几个命令行操作都有哪些？(至少4个)（北京数字**）略 4.Java 中是否存在内存溢出、内存泄漏？如何解决？举例说明（拼*多）存在！ 不能举例。 5. 如何看待Java是一门半编译半解释型的语言（携*）关键字特点：关键字都是小写（class,void,static,public）‘const’ 和 ‘goto’ not used but served；true，false，null 不是关键字，为字面量 标识符命名规则： 由 26 个英文字母大小写，0-9 ，_或 $ 组成 数字不可以开头。 不可以使用关键字和保留字，但能包含关键字和保留字。 Java 中严格区分大小写，长度无限制。 标识符不能包含空格。命名规范： 包名：多单词组成时所有字母都小写：xxxyyyzzz。 例如：java.lang、com.atguigu.bean 类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz 例如：HelloWorld，String，System 等 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz 例如：age,name,bookName,main,binarySearch,getName 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ 例如：MAX_VALUE,PI,DEFAULT_CAPACITY 变量注意： Java 中每个变量必须先声明，后使用。 使用变量名来访问这块区域的数据。 变量的作用域：其定义所在的一对{ }内。 变量只有在其作用域内才有效。出了作用域，变量不可以再被调用。 同一个作用域内，不能定义重名的变量。基本数据类型：包括 整数类型、浮点数类型、字符类型、布尔类型。引用数据类型：包括数组、 类、接口、枚举、注解、记录。 基本数据类型整数类型：byte、short、int、long 定义 long 类型的变量，赋值时需要以”l”或”L”作为后缀。 Java 程序中变量通常声明为 int 型，除非不足以表示较大的数，才使用 long。 Java 的整型常量默认为 int 型。 浮点类型：float、double float：尾数可以精确到 7 位有效数字 double：精度是 float 的两倍 定义 float 类型的变量，赋值时需要以”f”或”F”作为后缀。 Java 的浮点型常量默认为 double 型。注意： 并不是所有的小数都能可以精确的用二进制浮点数表示。二进制浮点数不能精确的表示 0.1、0.01、0.001 这样 10 的负次幂。（为什么 0.1 + 0.2 不等于 0.3） 浮点类型 float、double 的数据不适合在不容许舍入误差的金融计算领域。如果需要精确数字计算或保留指定位数的精度，需要使用 BigDecimal 类。 字符类型：char 形式 1：使用单引号(‘ ‘)括起来的单个字符。 形式 2：直接使用 Unicode 值来表示字符型常量：‘\\uXXXX’。其中，XXXX 代表一个十六进制整数。例如：\\u0023 表示 ‘#’。 形式 3：Java 中还允许使用转义字符‘\\’来将其后的字符转变为特殊字符型常量。 如：’\\n’表示换行符 布尔类型：boolean boolean 类型用来判断逻辑条件，一般用于流程控制语句中 boolean 类型数据只有两个值：true、false，无其它；不可以使用 0 或非 0 的整数替代 false 和 true 基本数据类型变量间运算规则自动类型提升规则：将取值范围小（或容量小）的类型自动提升为取值范围大（或容量大）的类型 。 当存储范围小的数据类型与存储范围大的数据类型变量一起混合运算时，会按照其中最大的类型运算 当 byte,short,char 数据类型的变量进行算术运算时，按照 int 类型处理。 强制类型转换规则：将取值范围大（或容量大）的类型强制转换成取值范围小（或容量小）的类型。转换格式：数据类型 1 变量名 &#x3D; (数据类型 1)被强转数据值; &#x2F;&#x2F;()中的数据类型必须&lt;&#x3D;变量值的数据类型 当把存储范围大的值（常量值、变量的值、表达式计算的结果值）强制转换为存储范围小的变量时，可能会损失精度或溢出 double d = 1.2; int num = (int)d;//损失精度 int i = 200; byte b = (byte)i;//溢出 声明 long 类型变量时，可以出现省略后缀的情况。float 则不同。 基本数据类型与 String 的运算String 不是基本数据类型，属于引用数据类型 任意八种基本数据类型的数据与 String 类型只能进行连接“+”运算，且结果一定也是 String 类型 String 类型不能通过强制类型()转换，转为其他的类型；借助包装类的方法才能转 常识：进制的认识 熟悉：二进制（以0B、0b开头）、十进制、八进制（以0开头）、十六进制（以0x或0X开头）的声明方式。 二进制的理解 正数：原码、反码、补码三码合一。 负数：原码、反码、补码不相同。了解三者之间的关系。 计算机的底层是以补码的方式存储数据的。 熟悉：二进制与十进制之间的转换 了解：二进制与八进制、十六进制间的转换 运算符算术运算符 + - + - * / % (前)++ (后)++ (前)-- (后)-- + 赋值运算符&#x3D; +&#x3D;、 -&#x3D;、*&#x3D;、 &#x2F;&#x3D;、%&#x3D;① 当“&#x3D;”两侧数据类型不一致时，可以使用自动类型转换或使用强制类型转换原则进行处理。② 支持连续赋值。③ +&#x3D;、 -&#x3D;、*&#x3D;、 &#x2F;&#x3D;、%&#x3D; 操作，不会改变变量本身的数据类型。 比较运算符&#x3D;&#x3D; !&#x3D; &gt; &lt; &gt;&#x3D; &lt;&#x3D; instanceof① instanceof 在面向对象的多态性的位置讲解。② &#x3D;&#x3D; !&#x3D; &gt; &lt; &gt;&#x3D; &lt;&#x3D; 适用于基本数据类型。(细节：&gt; &lt; &gt;&#x3D; &lt;&#x3D;不适用于boolean类型) 运算的结果为boolean类型。③ 了解： &#x3D;&#x3D; !&#x3D; 可以适用于引用数据类型④ 区分：&#x3D;&#x3D; 与 &#x3D; 逻辑运算符 &amp; &amp;&amp; | || ! ^ 说明：① 逻辑运算符针对的都是boolean类型的变量进行的操作② 逻辑运算符运算的结果也是boolean类型。③ 逻辑运算符常使用条件判断结构、循环结构中 区分：&amp; 和 &amp;&amp;1、相同点：两个符号表达的都是”且”的关系。只有当符号左右两边的类型值均为true时，结果才为true。 2、执行过程： 1）如果符号左边是true，则&amp; 、&amp;&amp; 都会执行符号右边的操作 2）如果符号左边是false，则 &amp; 会继续执行符号右边的操作，&amp;&amp; 不会执行符号右边的操作3、开发中，我们推荐使用&amp;&amp; 区分：| 和 ||（与&amp; 和 &amp;&amp;类似） 位运算符(了解) &lt;&lt; &gt;&gt; &gt;&gt;&gt; &amp; | ^ ~ 说明： ① &lt;&lt; &gt;&gt; &gt;&gt;&gt; &amp; | ^ ~ ：针对数值类型的变量或常量进行运算，运算的结果也是数值② &lt;&lt; : 在一定范围内，每向左移动一位，结果就在原有的基础上 * 2。（对于正数、负数都适用）；&gt;&gt; : 在一定范围内，每向右移动一位，结果就在原有的基础上 &#x2F; 2。（对于正数、负数都适用） 面试题：高效的方式计算2 * 8 ？ （2 &lt;&lt; 3 或 8 &lt;&lt; 1） 条件运算符 (条件表达式)? 表达式1 : 表达式2 说明：① 条件表达式的结果是boolean类型。② 如果条件表达式的结果是true，则执行表达式1。否则，执行表达式2。③ 表达式1 和 表达式2 需要是相同的类型或能兼容的类型。 ④ 开发中，凡是可以使用条件运算符的位置，都可以改写为if-else。 反之，能使用if-else结构，不一定能改写为条件运算符。 建议，在二者都能使用的情况下，推荐使用条件运算符。因为执行效率稍高。 企业真题（二）1. 高效的方式计算2 * 8的值 (文**辉、轮*科技)使用 &lt;&lt; 2. &amp;和&amp;&amp;的区别？(恒*电子、*度)略 3. Java中的基本类型有哪些？String 是最基本的数据类型吗？(恒*电子)8种基本数据类型。（略） String不是，属于引用数据类型。 4. Java中的基本数据类型包括哪些？（*米）12类似问题：&gt; Java的基础数据类型有哪些？String是吗？（贝壳） 略 5. Java开发中计算金额时使用什么数据类型？（5*到家）不能使用float或double，因为精度不高。 使用BigDecimal类替换，可以实现任意精度的数据的运算。 6. char型变量中能不能存储一个中文汉字，为什么？(*通快递)可以的。char c1 &#x3D; ‘中’; char c2 &#x3D; ‘a’。 因为char使用的是unicode字符集，包含了世界范围的所有的字符。 7. 代码分析(君*科技、新*陆)12short s1=1; s1=s1+1; //有什么错？ =右边是int类型。需要强转 12short s1=1;s1+=1; //有什么错? 没错 8. int i&#x3D;0; i&#x3D;i++执行这两句化后变量 i 的值为（*软）0。 9. 如何将两个变量的值互换（北京*彩、中外*译咨询）123456String s1 = &quot;abc&quot;;String s2 = &quot;123&quot;;String temp = s1;s1 = s2;s2 = temp; 10. boolean 占几个字节（阿**巴）1234567编译时不谈占几个字节。但是JVM在给boolean类型分配内存空间时，boolean类型的变量占据一个槽位(slot，等于4个字节)。细节：true:1 false:0&gt;拓展：在内存中，byte\\short\\char\\boolean\\int\\float : 占用1个slot double\\long :占用2个slot 11. 为什么Java中0.1 + 0.2结果不是0.3？（字*跳动）在代码中测试0.1 + 0.2，你会惊讶的发现，结果不是0.3，而是0.3000……4。这是为什么？ 几乎所有现代的编程语言都会遇到上述问题，包括 JavaScript、Ruby、Python、Swift 和 Go 等。引发这个问题的原因是，它们都采用了IEEE 754标准。 IEEE是指“电气与电子工程师协会”，其在1985年发布了一个IEEE 754计算标准，根据这个标准，小数的二进制表达能够有最大的精度上限提升。但无论如何，物理边界是突破不了的，它仍然不能实现“每一个十进制小数，都对应一个二进制小数”。正因如此，产生了0.1 + 0.2不等于0.3的问题。 具体的： 整数变为二进制，能够做到“每个十进制整数都有对应的二进制数”，比如数字3，二进制就是11；再比如，数字43就是二进制101011，这个毫无争议。 对于小数，并不能做到“每个小数都有对应的二进制数字”。举例来说，二进制小数0.0001表示十进制数0.0625 （至于它是如何计算的，不用深究）；二进制小数0.0010表示十进制数0.125；二进制小数0.0011表示十进制数0.1875。看，对于四位的二进制小数，二进制小数虽然是连贯的，但是十进制小数却不是连贯的。比如，你无法用四位二进制小数的形式表示0.125 ~ 0.1875之间的十进制小数。 所以在编程中，遇见小数判断相等情况，比如开发银行、交易等系统，可以采用四舍五入或者“同乘同除”等方式进行验证，避免上述问题。 分支结构if-else12345if(条件表达式) &#123; 语句块1;&#125;else&#123; 语句块2;&#125; switch-case 在特殊的场景下，分支结构可以考虑使用switch-case 指定的数据类型：byte \\ short \\ char \\ int ; 枚举类（jdk5.0）\\ String (jdk7.0) 可以考虑的常量值有限且取值情况不多。 特别之处：case穿透。 在能使用switch-case的情况下，推荐使用switch-case，因为比if-else效率稍高 12345678910111213switch(表达式)&#123; case 常量1: //执行语句1 //break; case 常量2: //执行语句2 //break; ... default: //执行语句2 //break;&#125; 循环结构for 凡是循环结构，都有4个要素：①初始化条件 ②循环条件（是boolean类型） ③ 循环体 ④ 迭代条件 应用场景：有明确的遍历的次数。 for(int i &#x3D; 1;i &lt;&#x3D; 100;i++) while 应用场景：没有明确的遍历次数。 do-while 至少会执行一次循环体。 开发中，使用的较少 break和continue break在开发中常用；而continue较少使用 笔试题：break和continue的区别。 1234567891011121314/*1. break和continue关键字的使用 使用范围 在循环结构中的作用 相同点break: switch-case 循环结构中 结束（或跳出）当前循环结构 在此关键字的后面不能声明执行语句。continue: 循环结构中 结束（或跳出）当次循环 在此关键字的后面不能声明执行语句。 2. 了解带标签的break和continue的使用3. 开发中，break的使用频率要远高于continue。 */ Math类的random() random()调用以后，会返回一个[0.0,1.0)范围的double型的随机数 需求：获取一个[a,b]范围的随机整数？(int)(Math.random() * (b - a + 1)) + a 企业真题（三）1. break和continue的作用(智*图)略 2. if分支语句和switch分支语句的异同之处(智*图) if-else语句优势 if语句的条件是一个布尔类型值，if条件表达式为true则进入分支，可以用于范围的判断，也可以用于等值的判断，使用范围更广。 switch语句的条件是一个常量值（byte,short,int,char,枚举,String），只能判断某个变量或表达式的结果是否等于某个常量值，使用场景较狭窄。 switch语句优势 当条件是判断某个变量或表达式是否等于某个固定的常量值时，使用if和switch都可以，习惯上使用switch更多。因为效率稍高。当条件是区间范围的判断时，只能使用if语句。 使用switch可以利用穿透性，同时执行多个分支，而if…else没有穿透性。 3. 什么时候用语句if，什么时候选用语句switch(灵伴*来科技)同上 4. switch语句中忘写break会发生什么(北京*蓝)case穿透 5. Java支持哪些类型循环(上海*睿) for;while;do-while 增强for （或foreach），放到集合中讲解 6. while和do while循环的区别(国*科技研究院) do-while至少会执行一次。 IDEA的认识 IDEA(集成功能强大、符合人体工程学（设置人性化）) Eclipse 企业真题（四）1. 开发中你接触过的开发工具都有哪些？IDEA 2. 谈谈你对Eclipse和IDEA使用上的感受？Eclipse不够人性化。 数组数组的概述 数组，就可以理解为多个相同数据的组合。 是程序中的容器：数组、集合框架（List、Set、Map） 数组存储的数据的特点：依次紧密排列的、有序的、可以重复的 此时的数组、集合框架都是在内存中对多个数据的存储。 数组的其它特点：一旦初始化，其长度就是确定的、不可更改的。 数组名中引用的是这块连续空间的首地址。 一维数组的使用（重要）123456789101112131415&gt; 数组的声明和初始化 int[] arr = new int[10]; String[] arr1 = new String[]&#123;&quot;Tom&quot;,&quot;Jerry&quot;&#125;; 注意：Java 语言中声明数组时不能指定其长度(数组中元素的个数)。 例如：int a[5]; //非法&gt; 调用数组的指定元素:使用角标、索引、index &gt;index从0开始！因为第一个元素距离数组首地址间隔 0 个单元格。&gt; 数组的属性：length,表示数组的长度&gt; 数组的遍历&gt; 数组元素的默认初始化值 对于基本数据类型而言，默认初始化值各有不同。对于引用数据类型而言，默认初始化值为 null（注意与 0 不同！）&gt; 一维数组的内存解析（难） 前提：在main()中声明变量：int[] arr = new int[]&#123;1,2,3&#125;; &gt; 虚拟机栈：main()作为一个栈帧，压入栈空间中。在main()栈帧中，存储着arr变量。arr记录着数组实体的首地址值。 &gt; 堆：数组实体存储在堆空间中。 二维数组的使用（难点） 二维数组：一维数组的元素，又是一个一维数组，则构成了二维数组。 123456&gt; 数组的声明和初始化&gt; 调用数组的指定元素&gt; 数组的属性：length,表示数组的长度&gt; 数组的遍历&gt; 数组元素的默认初始化值&gt; 二维数组的内存解析（难） 数组的常用算法（重要） 数值型数组的特征值的计算：最大值、最小值、总和、平均值等 数组元素的赋值。比如：杨辉三角；彩票随机生成数（6位；1-30；不能重复）；回形数 数组的复制、赋值 数组的反转 数组的扩容、缩容 数组的查找 线性查找 二分法查找（前提：数组有序） 数组的排序 冒泡排序：最简单 快速排序：最常用 Arrays工具类的使用 熟悉一下内部的常用的方法 toString() &#x2F; sort() &#x2F; binarySearch() 数组中的常见异常 ArrayIndexOutOfBoundsException NullPointerException 企业真题（五）1. 数组有没有length()这个方法? String有没有length()这个方法？（*蓝）数组没有length()，是length属性。 String有length() 2. 有数组int[] arr，用Java代码将数组元素顺序颠倒（闪*购）略 3. 为什么数组要从0开始编号，而不是1(中*支付)数组的索引，表示了数组元素距离首地址的偏离量。因为第1个元素的地址与首地址相同，所以偏移量就是0。所以从0开始。 4. 数组有什么排序的方式，手写一下（平*保险）冒泡。 快排。（讲完递归方法以后，大家就可以练习一下） 5. 常见排序算法，说下快排过程，时间复杂度？（5*到家）见课件。 快排：O(nlogn) 6. 二分算法实现数组的查找（神舟*天软件）略 7. 怎么求数组的最大子序列和（携*）1234567891011121314151617181920212223242526272829303132333435363738394041/* * 输入一个整形数组，数组里有正数也有负数。数组中连续的一个或多个整数组成一个子数组，每个子数组都有一个和。 * 求所有子数组的和的最大值。要求时间复杂度为O(n)。 例如：输入的数组为1, -2, 3, 10, -4, 7, 2, -5，和最大的子数组为3, 10, -4, 7, 2， 因此输出为该子数组的和18。 */public class ArrDemo &#123; public static void main(String[] args) &#123; int[] arr = new int[]&#123;1, -2, 3, 10, -4, 7, 2, -5&#125;; int i = getGreatestSum(arr); System.out.println(i); &#125; public static int getGreatestSum(int[] arr)&#123; int greatestSum = 0; if(arr == null || arr.length == 0)&#123; return 0; &#125; int temp = greatestSum; for(int i = 0;i &lt; arr.length;i++)&#123; temp += arr[i]; if(temp &lt; 0)&#123; temp = 0; &#125; if(temp &gt; greatestSum)&#123; greatestSum = temp; &#125; &#125; if(greatestSum == 0)&#123; greatestSum = arr[0]; for(int i = 1;i &lt; arr.length;i++)&#123; if(greatestSum &lt; arr[i])&#123; greatestSum = arr[i]; &#125; &#125; &#125; return greatestSum; &#125;&#125; 8. Arrays 类的排序方法是什么？如何实现排序的？（阿*、阿*校招）略 面向对象-基础面向过程 vs 面向对象（了解） 不管是面向过程、面向对象，都是程序设计的思路。 面向过程：以函数为基本单位，适合解决简单问题。比如：开车 面向对象：以类为基本单位，适合解决复杂问题。比如：造车 类、对象 类：抽象的，概念上的定义 对象：具体的，类的一个一个的实例。 面向对象完成具体功能的操作的三步流程（非常重要） 123步骤1：创建类，并设计类的内部成员（属性、方法）步骤2：创建类的对象。比如：Phone p1 = new Phone();步骤3：通过对象，调用其内部声明的属性或方法，完成相关的功能 对象的内存解析 创建类的一个对象；创建类的多个对象；方法的调用的内存解析 Java中内存结构的划分 Java中内存结构划分为：虚拟机栈、堆、方法区；程序计数器、本地方法栈 虚拟机栈：以栈帧为基本单位，有入栈和出栈操作；每个栈帧入栈操作对应一个方法的执行；方法内的局部变量会存储在栈帧中。 堆空间：new 出来的结构（数组、对象）：① 数组，数组的元素在堆中 ② 对象的成员变量在堆中。 方法区：加载的类的模板结构。 类的成员之一：属性（或成员变量） 成员变量 vs 局部变量相同点： 变量声明的格式相同： 数据类型 变量名 &#x3D; 初始化值 变量必须先声明、后初始化、再使用。 变量都有其对应的作用域。只在其作用域内是有效的不同点： 声明位置和方式 （1）实例变量：在类中方法外 （2）局部变量：在方法体{}中或方法的形参列表、代码块中 在内存中存储的位置不同 （1）实例变量：堆 （2）局部变量：栈 生命周期 （1）实例变量：和对象的生命周期一样，随着对象的创建而存在，随着对象被 GC 回收而消亡， 而且每一个对象的实例变量是独立的。（2）局部变量：和方法调用的生命周期一样，每一次方法被调用而在存在，随着方法执行的结束而消亡， 而且每一次方法调用都是独立。 作用域 （1）实例变量：通过对象就可以使用，本类中直接调用，其他类中“对象.实例变量” （2）局部变量：出了作用域就不能使用 修饰符（后面来讲） （1）实例变量：public,protected,private,final,volatile,transient 等 （2）局部变量：final 默认值 （1）实例变量：有默认值 （2）局部变量：没有，必须手动初始化。其中的形参比较特殊，靠实参给它初始化。 属性 &lt;&#x3D;&gt; 成员变量 &lt;&#x3D;&gt;field &lt;&#x3D;&gt; 字段、域 类的成员之二：方法 方法的声明：权限修饰符 返回值类型 方法名(形参列表){ &#x2F;&#x2F; 方法体} 重点：返回值类型、形参列表 return关键字的使用 再谈方法方法的重载(overload) 方法的重载的要求：“两同一不同” 同类同名参数不同 调用方法时，如何确定调用的是某个指定的方法呢？① 方法名 ② 形参列表 可变个数形参的方法JDK 5.0 中提供了 Varargs(variable number of arguments)机制 格式：(int … args) 方法的参数传递机制：值传递(重点、难点)12&gt; 如果形参是基本数据类型的变量，则将实参保存的数据值赋给形参。&gt; 如果形参是引用数据类型的变量，则将实参保存的地址值赋给形参。 递归方法 递归方法构成了隐式的循环 对比：相较于循环结构，递归方法效率稍低，内存占用偏高。 递归调用会占用大量的系统堆栈，内存耗用多，在递归调用层次多时速度要比循环慢的多，所以在使用递归时要慎重。 在要求高性能的情况下尽量避免使用递归，递归调用既花时间又耗内存。考虑使用循环迭代 对象数组 String[] ；Person[] ; Customer[] package、import关键字的使用 package：指明声明的类所属的包。 import：当前类中，如果使用其它包下的类（除java.lang包），原则上就需要导入。 java.lang—-包含一些 Java 语言的核心类，如 String、Math、Integer、System 和 Thread，提供常用功能 java.net—-包含执行与网络相关的操作的类和接口。 java.io —-包含能提供多种输入&#x2F;输出功能的类。 java.util—-包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。 java.text—-包含了一些 java 格式化相关的类 java.sql—-包含了 java 进行 JDBC 数据库编程的相关类&#x2F;接口 java.awt—-包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI) oop的特征之一：封装性12Java规定了4种权限修饰，分别是：private、缺省、protected、public。我们可以使用4种权限修饰来修饰类及类的内部成员。当这些成员被调用时，体现可见性的大小。 举例： 123&gt; 场景1：私有化(private)类的属性，提供公共(public)的get和set方法，对此属性进行获取或修改&gt; 场景2：将类中不需要对外暴露的方法，设置为private&gt; 场景3：单例模式中构造器private的了，避免在类的外部创建实例。（放到static关键字后讲） 上理论：程序设计的原则之一 12345理论上： -`高内聚`：类的内部数据操作细节自己完成，不允许外部干涉； （Java程序通常以类的形态呈现，相关的功能封装到方法中。） -`低耦合`：仅暴露少量的方法给外部使用，尽量方便外部调用。 （给相关的类、方法设置权限，把该隐藏的隐藏起来，该暴露的暴露出去） 注意：开发中，一般成员实例变量都习惯使用 private 修饰，再提供相应的public 权限的 get&#x2F;set 方法访问。对于 final 的实例变量，不提供 set()方法。对于 static final 的成员变量，习惯上使用 public 修饰。 类的成员之三：构造器 如何定义：权限修饰符 类名(形参列表){} 构造器的作用：① 搭配上new，用来创建对象 ② 初始化对象的成员变量 三个小知识类的实例变量的赋值过程（重要） 在类的属性中，可以有哪些位置给属性赋值？① 默认初始化；② 显式初始化；③ 构造器中初始化； ④ 通过”对象.方法”的方式赋值；⑤ 通过”对象.属性”的方式赋值； 这些位置执行的先后顺序是怎样？① - ② - ③ - ④&#x2F;⑤ JavaBean所谓JavaBean，是指符合如下标准的Java类： 类是公共的 有一个无参的公共的构造器 有属性，且有对应的get、set方法 UML类图熟悉。 企业真题（六）2.1 类与对象1. 面向对象，面向过程的理解？（平*金服、英**达）略。 2. Java 的引用类型有哪几种（阿*校招）类、数组、接口；枚举、注解、记录 3. 类和对象的区别（凡*科技、上*银行）略。 4. 面向对象，你解释一下，项目中哪些地方用到面向对象？（燕*金融）“万事万物皆对象”。 2.2 Java内存结构1. Java虚拟机中内存划分为哪些区域，详细介绍一下（神**岳、数*互融）略。 2. 对象存在Java内存的哪块区域里面？（阿*）堆空间。 2.3 权限修饰符（封装性）1. private 、缺省、protected、public的表格化作用区域（爱*信、拓*思、中*瑞飞）略 2. main方法的public能不能换成private？为什么？（凡*科技、顺*）能。但是改以后就不能作为程序的入口了，就只是一个普通的方法。 2.4 构造器1. 构造方法和普通方法的区别（凡*科技、软*动力、中*软）编写代码的角度：没有共同点。声明格式、作用都不同。 字节码文件的角度：构造器会以&lt;init&gt;()方法的形态呈现，用以初始化对象。 2. 构造器Constructor是否可被overload?（鸿*网络）可以。 3. 无参构造器和有参构造器的的作用和应用（北京楚*龙）略 2.5 属性及属性赋值顺序1. 成员变量与局部变量的区别（艾*软件）6个点。 2. 变量赋值和构造方法加载的优先级问题（凡*科技、博*软件）变量显式赋值先于构造器中的赋值。 如何证明？我看的字节码文件。 面向对象-进阶this关键字的使用 this调用的结构：属性、方法；构造器 this调用属性或方法时，理解为：当前对象或当前正在创建的对象。 12345678public void setName(String name)&#123; //当属性名和形参名同名时，必须使用this来区分 this.name = name;&#125;public Person(String name)&#123; this(); this.name = name;&#125; this()：调用本类的无参构造器。 this(形参列表)的方式，表示调用当前类中其他的重载的构造器。注意：• 不能出现递归调用。比如，调用自身构造器。– 推论：如果一个类中声明了 n 个构造器，则最多有 n - 1 个构造器中使用了”this(形参列表)”• this()和 this(实参列表)只能声明在构造器首行。– 推论：在类的一个构造器中，最多只能声明一个”this(参数列表)” 面向对象的特征二：继承性 继承性的好处 继承的出现减少了代码冗余，提高了代码的复用性。 继承的出现，更有利于功能的扩展。 继承的出现让类与类之间产生了 is-a 的关系，为多态的使用提供了前提。继承描述事物之间的所属关系，这种关系是：is-a 的关系。可见，父类更通用、更一般，子类更具体。 注意：不要仅为了获取其他类中某个功能而去继承 Java中继承性的特点 局限性：类的单继承性。后续我们通过类实现接口的方式，解决单继承的局限性。 支持多层继承，一个父类可以声明多个子类。 基础：class A extends B{}类 A，称为子类、派生类(derived class)、SubClass类 B，称为父类、超类、基类(base class)、SuperClass 理解：子类就获取了父类中声明的全部的属性、方法。可能受封装性的影响，不能直接调用。 方法的重写（override &#x2F; overwrite）@Override 使用说明：写在方法上面，用来检测是不是满足重写方法的要求。这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。建议保留，这样编译器可以帮助我们检查格式，另外也可以让阅读源代码的程序员清晰的知道这是一个重写的方法。 要求 子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表。 子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型。（例如：Student &lt; Person）。注意：如果返回值类型是基本数据类型和 void，那么必须是相同。 子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限。（public &gt; protected &gt; 缺省 &gt; private）注意：① 父类私有方法不能重写 ② 跨包的父类缺省的方法也不能重写 子类方法抛出的异常不能大于父类被重写方法的异常 此外，子类与父类中同名同参数的方法必须同时声明为非 static 的(即为重写)，或者同时声明为 static 的（不是重写）。因为 static 方法是属于类的，子类无法覆盖父类的方法。 面试题：方法的重载与重写的区别？ 方法的重载：“两同一不同” 方法的重写： 前提：类的继承关系 子类对父类中同名同参数方法的覆盖、覆写。 super关键字的使用 super可以调用的结构：属性、方法；构造器 super：父类的 super调用父类的属性、方法： 如果子父类中出现了同名的属性，此时使用super.的方式，表明调用的是父类中声明的属性。 子类重写了父类的方法。如果子类的任何一个方法中需要调用父类被重写的方法时，需要使用super. super调用构造器： 子类继承父类时，不会继承父类的构造器。只能通过“super(形参列表)”的方式调用父类指定的构造器。 在子类的构造器中，首行要么使用了”this(形参列表)”，要么使用了”super(形参列表)”。 如果在子类构造器的首行既没有显示调用”this(形参列表)”，也没有显式调用“super(形参列表)”， 则子类此构造器默认调用”super()”，即调用父类中空参的构造器。 一个类中声明有 n 个构造器，最多有 n-1 个构造器中使用了”this(形参列表)”，则剩下的那个一定使用”super(形参列表)” （熟悉）子类对象实例化的全过程 结果上来说：体现为继承性 过程上来说：子类调用构造器创建对象时，一定会直接或间接的调用其父类的构造器，以及父类的父类的构造器，…，直到调用到Object()的构造器。 面向对象的特征三：多态性 广义上的理解：子类对象的多态性、方法的重写；方法的重载 狭义上的理解：子类对象的多态性。 格式：Object obj &#x3D; new String(“hello”); Person p &#x3D; new Man();父类的引用指向子类的对象。 多态的好处：减少了大量的重载的方法的定义；开闭原则 举例：public boolean equals(Object obj) 多态，无处不在！讲了抽象类、接口以后，会有更好的理解。 弊端：一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法。 多态的使用：虚拟方法调用。“编译看左边，运行看右边”。属性不存在多态性。 多态的逆过程：向下转型，使用强转符()。 为了避免出现强转时的ClassCastException，建议()之前使用instanceOf进行判断。 向下转型：（子类类型）父类变量 Person p2 &#x3D; new Man(); Man m1 &#x3D; (Man)p2 建议在向下转型之前，使用instanceof进行判断，避免出现类型转换异常 格式：a instanceof A ：判断对象a是否是类A的实例 Object类的使用 根父类，默认的父类，java.lang.Object equals() 只能比较引用类型，Object 类源码中 equals()的作用与“&#x3D;&#x3D;”相同：比较是否指向同一个对象。对类 File、String、Date 及包装类（Wrapper Class）来说，是比较类型及内容而不考虑引用的是否是同一个对象；在这些类中重写了 Object 类的 equals()方法。 重写和不重写的区别 面试题： &#x3D;&#x3D; 和 equals() 1234 1. == 既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引 用类型就是比较内存地址2. equals 的话，它是属于 java.lang.Object 类里面的方法，如果该方法没有被重写过默认也是==;我们可以看到 String 等类的 equals 方法是被重写过的，而且 String 类在日常开发中用的比较多，久而久之，形成了 equals 是比较值的错误观点。3. 具体要看自定义类里有没有重写 Object 的 equals 方法来判断。通常情况下，重写 equals 方法，会比较类中的相应属性是否都相等。*/ toString()的使用 Object中toString()调用后，返回当前对象所属的类和地址值。 开发中常常重写toString()，用于返回当前对象的属性信息。 clone() 深拷贝 finalize() 当GC要回收此对象时，调用该方法（从JDK9开始过时），可能导致内部出现循环引用，导致此对象不能被回收 getClass() \\ hashCode() \\ notify() \\ notifyAll() \\ wait() 企业真题(七)2.1 继承性1. 父类哪些成员可以被继承，属性可以被继承吗？可以或者不可以，请举下例子。（北京明**信）父类的属性、方法可以被继承。构造器可以被子类调用。 2.2 重写1. 什么是Override，与Overload的区别（顺*、软**力、明*数据、阳*科技、中*软）略 2. Overload的方法是否可以改变返回值的类型?（新*陆）public void method(int i){} public int method(int j,int k){} 3. 构造器Constructor是否可被override?（鸿*网络、深圳德**技、航**普）不能！构造器可以重载 4. 为什么要有重载，我随便命名一个别的函数名不行吗？谈谈你是怎么理解的。（腾*）见名知意。 2.3 super关键字1. super和this的区别(蚂**服)把两个关键字各自的特点说清楚。 2. this、super关键字分别代表什么?以及他们各自的使用场景和作用。（北京楚*龙）略 2.4 多态1. 谈谈你对多态的理解(三*重工、江*智能、银*数据、君*科技)1234类似问法：&gt; Java中实现多态的机制是什么(国*电网)&gt; 什么是多态？（上*银行）&gt; Java中的多态是什么意思？（贝*） 略 2. 多态new出来的对象跟不多态new出来的对象区别在哪？（万*智能）Person p &#x3D; new Man(); &#x2F;&#x2F;虚方法调用。屏蔽了子类Man类特有的属性和方法。 Man m &#x3D; new Man(); 3. 说说你认为多态在代码中的体现（楚*龙）无处不在！ 略 2.5 Object类1. &#x3D;&#x3D;与equals的区别（拓*思）12类似问法：&gt; 两个对象A和B，A==B，A.equals(B)有什么区别（华油**普） 略 2. 重写equals方法要注意什么？（安**网络科技） 明确判定两个对象实体equals()的标准。是否需要所有的属性参与。 对象的属性，又是自定义的类型，此属性也需要重写equals() 3. Java中所有类的父类是什么？他都有什么方法？（阿*校招）12相关问题：&gt; Object类有哪些方法？（恒*电子） 面向对象-高级关键字：static static：静态的，随着类的加载而加载、执行。 static用来修饰：属性、方法、代码块、内部类 1234567[修饰符] class 类&#123; [其他修饰符] static 数据类型 变量名; [其他修饰符] static 返回值类型 方法名(形参列表)&#123;方法体&#125;&#125; 被修饰后的成员具备以下特点： 随着类的加载而加载 优先于对象存在 修饰的成员，被所有对象所共享 访问权限允许时，可不创建对象，直接被类调用 熟悉：static修饰的类变量、类方法与不使用static修饰的区别。 类变量：类的生命周期内，只有一个。被类的多个实例共享。 掌握：我们遇到属性或方法时，需要考虑是否声明为static的。 单例模式（或单子模式） 经典的设计模式有23种 解决的问题：在整个软件系统中，只存在当前类的唯一实例。 实现方式：饿汉式、懒汉式、枚举类等 对比饿汉式和懒汉式 饿汉式：“立即加载”，线程安全的。 懒汉式：”延迟加载”，线程不安全。 需要会手写饿汉式和懒汉式 饿汉式： 123456789101112class Singleton &#123; // 1.私有化构造器 private Singleton() &#123; &#125; // 2.内部提供一个当前类的实例 // 4.此实例也必须静态化 private static Singleton single = new Singleton(); // 3.提供公共的静态的方法，返回当前类的对象 public static Singleton getInstance() &#123; return single; &#125; &#125; 懒汉式： 123456789101112131415class Singleton &#123; // 1.私有化构造器 private Singleton() &#123; &#125; // 2.内部提供一个当前类的实例 // 4.此实例也必须静态化 private static Singleton single; // 3.提供公共的静态的方法，返回当前类的对象 public static Singleton getInstance() &#123; if(single == null) &#123; single = new Singleton(); &#125; return single; &#125; &#125; 优点和应用场景由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。 理解main()方法由于 JVM 需要调用类的 main()方法，所以该方法的访问权限必须是 public，又因为 JVM 在执行 main()方法时不必创建对象，所以该方法必须是 static 的，该方法接收一个 String 类型的数组参数，该数组中保存执行 Java 命令时传递给所运行的类的参数。又因为 main() 方法是静态的，我们不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员，这种情况，我们在之前的例子中多次碰到。 public static void main(String[] args){} 理解1：作为程序的入口；普通的静态方法 理解2：如何使用main()与控制台进行数据的交互。 命令行：java 类名 “Tom” “Jerry” “123” 类的成员之四：代码块12345[修饰符] class 类&#123;static&#123;静态代码块&#125;&#125; 分类：静态代码块、非静态代码块 使用频率上来讲：用的比较少。 静态代码块： 可以有输出语句。 可以对类的属性、类的声明进行初始化操作。 不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法。 若有多个静态的代码块，那么按照从上到下的顺序依次执行。 静态代码块的执行要先于非静态代码块。 静态代码块随着类的加载而加载，且只执行一次。 123456789private static String country;private String name;&#123;System.out.println(&quot;非静态代码块，country = &quot; + country);&#125;static &#123;country = &quot;中国&quot;;System.out.println(&quot;静态代码块&quot;);&#125; 非静态代码块：随着对象的创建而执行 总结：对象的实例变量可以赋值的位置及先后顺序 ① 默认初始化② 显式初始化 或 ⑤ 代码块中初始化③ 构造器中初始化 ④ 有了对象以后，通过”对象.属性”或”对象.方法”的方法进行赋值 执行的先后顺序：① - ②&#x2F;⑤ - ③ - ④ 关键字：final 用来修饰：类、方法、变量（成员变量、局部变量） 类：不能被继承，没有子类。提高安全性，提高程序的可读性。 方法：不能被子类重写。 变量：是一个“常量”，一旦赋值不能修改。即常量，常量名建议使用大写字母。如果某个成员变量用 final 修饰后，没有 set 方法，并且必须初始化（可以显式赋值、或在初始化块赋值、实例变量还可以在构造器中赋值） 关键字：abstract 抽象的 用来修饰：类、方法 类：抽象类：不能实例化。 方法：抽象方法：没有方法体，必须由子类实现此方法。 使用说明： 抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。 抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写全部的抽象方法，仍为抽象类。 抽象类中，也有构造方法，是供子类创建对象时，初始化父类成员变量使用的。理解：子类的构造方法中，有默认的 super()或手动的 super(实参列表)，需要访问父类构造方法。 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。 注意事项： 不能用 abstract 修饰变量、代码块、构造器； 不能用 abstract 修饰私有方法、静态方法、final 的方法、final 的类。 关键字：interface interface：接口，用来定义一组规范、一种标准。 123456789[修饰符] interface 接口名&#123;//接口的成员列表：// 公共的静态常量// 公共的抽象方法// 公共的默认方法（JDK1.8 以上）// 公共的静态方法（JDK1.8 以上）// 私有方法（JDK1.9 以上）&#125; 123456789101112131415161718public interface USB3&#123; //静态常量 long MAX_SPEED = 500*1024*1024;//500MB/s //抽象方法 void in(); void out(); //默认方法 default void start()&#123; System.out.println(&quot;开始&quot;); &#125; default void stop()&#123; System.out.println(&quot;结束&quot;); &#125; //静态方法 static void show()&#123; System.out.println(&quot;USB 3.0 可以同步全速地进行读写操作&quot;); &#125;&#125; 掌握：接口中可以声明的结构。 属性：使用public static final修饰 方法：jdk8之前：只能声明抽象方法，使用public abstract修饰 ​ jdk8中：声明static方法、default方法。 ​ jdk9中：声明private方法。 类实现接口（implements）：接口不能创建对象，但是可以被类实现（implements ，类似于被继承）。类与接口的关系为实现关系，即类实现接口，该类可以称为接口的实现类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 implements 关键字。 接口的多实现（implements）：在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的多实现。并且，一个类能继承一个父类，同时实现多个接口。 接口的多继承(extends)：一个接口能继承另一个或者多个接口。 JDK8 中相关冲突问题： 默认方法冲突问题：（1）类优先原则：当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的抽象方法重名，子类就近选择执行父类的成员方法。（2）接口冲突（左右为难）：当一个类同时实现了多个父接口，而多个父接口中包含方法签名相同的默认方法时，选择保留其中一个，通过“接口名.super.方法名”的方法选择保留哪个接口的默认方法；当一个子接口同时继承了多个接口，而多个父接口中包含方法签名相同的默认方法时，子接口重写默认方法。（子接口重写默认方法时，default 关键字可以保留；子类重写默认方法时，default 关键字不可以保留） 常量冲突问题：当子类继承父类又实现父接口，而父类中存在与父接口常量同名的成员变量，并且该成员变量名在子类中仍然可见。当子类同时实现多个接口，而多个接口存在相同同名常量。此时在子类中想要引用父类或父接口的同名的常量或成员变量时，就会有冲突问题。 笔试题：抽象类、接口的对比。 类的成员之五：内部类1234&gt; 成员内部类的理解&gt; 如何创建成员内部类的实例&gt; 如何在成员内部类中调用外部类的结构&gt; 局部内部类的基本使用（关注：如何在方法内创建匿名局部内部类的对象） 枚举类：enum 枚举类的实现：– 在 JDK5.0 之前，需要程序员自定义枚举类型。 12345678910111213141516171819class Season&#123;private final String SEASONNAME;//季节的名称private final String SEASONDESC;//季节的描述private Season(String seasonName,String seasonDesc)&#123;this.SEASONNAME = seasonName;this.SEASONDESC = seasonDesc;&#125;public static final Season SPRING = new Season(&quot;春天&quot;, &quot;春暖花开&quot;);public static final Season SUMMER = new Season(&quot;夏天&quot;, &quot;夏日炎炎&quot;);public static final Season AUTUMN = new Season(&quot;秋天&quot;, &quot;秋高气爽&quot;);public static final Season WINTER = new Season(&quot;冬天&quot;, &quot;白雪皑皑&quot;);@Overridepublic String toString() &#123;return &quot;Season&#123;&quot; +&quot;SEASONNAME=&#x27;&quot; + SEASONNAME + &#x27;\\&#x27;&#x27; +&quot;, SEASONDESC=&#x27;&quot; + SEASONDESC + &#x27;\\&#x27;&#x27; +&#x27;&#125;&#x27;;&#125;&#125; – 在 JDK5.0 之后，Java 支持 enum 关键字来快速定义枚举类型。 12345678910111213141516171819public enum SeasonEnum &#123;SPRING(&quot;春天&quot;,&quot;春风又绿江南岸&quot;),SUMMER(&quot;夏天&quot;,&quot;映日荷花别样红&quot;),AUTUMN(&quot;秋天&quot;,&quot;秋水共长天一色&quot;),WINTER(&quot;冬天&quot;,&quot;窗含西岭千秋雪&quot;);private final String seasonName;private final String seasonDesc;private SeasonEnum(String seasonName, String seasonDesc) &#123;this.seasonName = seasonName;this.seasonDesc = seasonDesc;&#125;public String getSeasonName() &#123;return seasonName;&#125;public String getSeasonDesc() &#123;return seasonDesc;&#125;&#125; enum 中常用方法：String toString(): 默认返回的是常量名（对象名），可以继续手动重写该方法！ static 枚举类型[] values():返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值，是一个静态方法 static 枚举类型 valueOf(String name)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。 String name():得到当前枚举常量的名称。建议优先使用 toString()。 int ordinal():返回当前枚举常量的次序号，默认从 0 开始 实现接口的枚举类 123456789enum A implements 接口 1，接口 2&#123;常量名 1(参数)&#123;//抽象方法的实现或重写&#125;,常量名 2(参数)&#123;//抽象方法的实现或重写&#125;,//...&#125; 掌握：使用enum关键字定义枚举类即可。 注解:Annotation 框架 &#x3D; 注解 + 反射 + 设计模式 Java基础阶段：简单。@Override(限定重写父类方法，该注解只能用于方法) 、 @Deprecated(用于表示所修饰的元素(类，方法等)已过时)、@SuppressWarnings(抑制编译器警告) 元注解：对现有的注解进行解释说明。 @Target：表明可以用来修饰的结构 @Retation：表明生命周期 如何自定义注解。 1234[元注解][修饰符] @interface 注解名&#123; [成员列表]&#125; JUnit 单元测试默认情况下，在单元测试方法中使用 Scanner 时，并不能实现控制台数据的输入。需要做如下设置：在 idea64.exe.vmoptions 配置文件中加入下面一行设置，重启 idea 后生效。-Deditable.java.test.console&#x3D;true 包装类的使用 掌握：基本数据类型对应的包装类都有哪些？ 掌握：基本数据类型、包装类、String三者之间的转换 基本数据类型 &lt;-&gt; 包装类：自动装箱、自动拆箱（从 JDK5.0 开始） 基本数据类型、包装类 &lt;-&gt; String String的valueOf(xxx) 包装类的parseXxx(String str) 包装类的其它 API 数据类型的最大最小值：Integer.MAX_VALUE 和 Integer.MIN_VALUE; Long.MAX_VALUE 和 Long.MIN_VALUE; Double.MAX_VALUE 和 Double.MIN_VALUE 字符转大小写：Character.toUpperCase(‘x’); Character.toLowerCase(‘X’); 整数转进制：Integer.toBinaryString(int i); Integer.toHexString(int i); Integer.toOctalString(int i) 比较的方法：Double.compare(double d1, double d2);Integer.compare(int x, int y) 面试题： 123456789101112131415public void method1() &#123; Integer i = new Integer(1); Integer j = new Integer(1); System.out.println(i == j);//false //底层都会调用Integer的valueOf() Integer m = 1; Integer n = 1; System.out.println(m == n);//true 看源码，如果在[-128,127]间,从现有数组里取，（享元模式） Integer x = 128; Integer y = 128; System.out.println(x == y);//false&#125; Object o1 = true ? new Integer(1) : new Double(2.0);//三目运算符后面类型必须一致System.out.println(o1);//1.0 企业真题（八）2.1 static关键字1. 静态变量和实例变量的区别？（保*丰、*软国际、*软华*、北京明**信）12类似问题：&gt; 说明静态变量和实例变量之间的区别和使用场景（上海*动） 略 2. 静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？（*度）12类似问题：&gt; 在java中，可以重载一个static方法吗？可以覆盖一个static方法吗？（Vi*o） 静态方法不能被重写。不存在多态性。 3. 是否可以从一个static方法内部发出对非static方法的调用？（同*顺）只能通过对象来对非静态方法的调用。 4. 被static修饰的成员(类、方法、成员变量)能否再使用private进行修饰？（联*优势）完全可以。除了代码块。 2.2 设计模式1. 知道哪些设计模式？（*通快递、蚂**服）单例模式、模板方法、享元设计模式 2. 开发中都用到了那些设计模式?用在什么场合? （久*国际物流）略 2.3 main()1. main()方法的public能不能换成private，为什么（凡*科技、顺*）可以改。但是改完以后就不是程序入口了。 2. main()方法中是否可以调用非静态方法？（浩*科技）只能通过对象来对非静态方法的调用。 2.4 代码块1. 类的组成和属性赋值执行顺序?（航*拓普）12类似问题：&gt; Java中类的变量初始化的顺序？（*壳） 略。 2. 静态代码块，普通代码块，构造方法，从类加载开始的执行顺序？（恒*电子）1234类似问题：&gt; 类加载成员变量、静态代码块、构造器的加载顺序（*科软、软**力、同*顺）&gt; static代码块(静态代码块)是否在类的构造函数之前被执行（联*优势） 静态代码块 –&gt; 普通代码块 –&gt; 构造器 2.5 final关键字1. 描述一下对final理解（华**博普）略 2. 判断题：使用final修饰一个变量时，是引用不能改变，引用指向的对象可以改变？（*米）引用不能改变。 引用指向的对象实体中的属性，如果没有使用final修饰，则可以改变。 3. 判断题：final不能用于修饰构造方法？（联*优势）是的。 4. final或static final 修饰成员变量，能不能进行++操作？（佳*贸易）不能。 2.6 抽象类与接口1. 什么是抽象类？如何识别一个抽象类？（易*支付）使用abstract修饰。 2. 为什么不能用abstract修饰属性、私有方法、构造器、静态方法、final的方法？（止**善）略。 为了语言的自洽。 3. 接口与抽象类的区别？（字*跳动、阿*校招、*度校招、**计算机技术及应用研究所、航*拓普、纬*、招**晟、汇*云通、数信**科技、北京永*鼎力、上海*连科技）略。 4. 接口是否可继承接口？抽象类是否可实现（implements）接口？抽象类是否可继承实现类（concrete class）？（航*拓普、*蝶、深圳德*科技）12类似问题：&gt; 接口A可以继承接口B吗?接口A可以实现接口B吗?（久*国际物流） 是；是；是； 5. 接口可以有自己属性吗？（华*中盛）可以。必须是public static final的 6. 访问接口的默认方法如何使用(上海*思)使用实现类的对象进行调用。而且实现还可以重写此默认方法。 2.7 内部类1. 内部类有哪几种？（华油**普、来*科技）略。 2. 内部类的特点说一下（招通**）123类似问题：&gt; 说一下内部类的好处（北京楚*龙）&gt; 使用过内部类编程吗，有什么作用（软**力） 8.匿名类说一下（阿*校招、上海立*网络）略 2.8 枚举类1. 枚举可以继承吗?（顺*）使用enum定义的，其父类就是Enum类，就不要再继承其他的类了。 2.9 包装类1. Java基本类型与包装类的区别（凡*科技）略。 2.10 综合1. 谈谈你对面向对象的理解(君*科技、航*拓普、…) 面向对象的两个要素：类、对象 —&gt; 面向对象编程。“万事万物皆对象”。 面向对象的三大特征 接口，与类并列的结构，作为一个补充：类可以实现多个接口。 2. 面向对象的特征有哪些方面? （北京楚*龙、深圳德*科技、直*科技、米*奇网络、航*拓普）12类似问题：&gt; 面向对象核心是什么？（平**服） 异常处理异常的概述1234567891011121. 什么是异常？指的是程序在执行过程中，出现的非正常情况，如果不处理最终会导致JVM的非正常停止。2. 异常的抛出机制Java中把不同的异常用不同的类表示，一旦发生某种异常，就`创建该异常类型的对象`，并且抛出（throw）。然后程序员可以捕获(catch)到这个异常对象，并处理；如果没有捕获(catch)这个异常对象，那么这个异常对象将会导致程序终止。3. 如何对待异常 对于程序出现的异常，一般有两种解决方法：一是遇到错误就终止程序的运行。另一种方法是程序员在编写程序时， 就充分考虑到各种可能发生的异常和错误，极力预防和避免。实在无法避免的，要编写相应的代码进行异常的检测、 以及`异常的处理`，保证代码的`健壮性`。 异常的体系结构及常见的异常123456789101112131415161718192021java.lang.Throwable:异常体系的根父类 • public void printStackTrace()：打印异常的详细信息。 包含了异常的类型、异常的原因、异常出现的位置、在开发和调试阶段都得使用printStackTrace。 • public String getMessage()：获取发生异常的原因。 |---java.lang.Error:错误。Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。 一般不编写针对性的代码进行处理。 |---- StackOverflowError（栈内存溢出）和 OutOfMemoryError（堆内存溢出，简称OOM） |---java.lang.Exception:异常。我们可以编写针对性的代码进行处理。 |----编译时异常：(受检异常)在执行javac.exe命令时，出现的异常。 |----- ClassNotFoundException |----- FileNotFoundException |----- IOException |----运行时异常：(非受检异常)在执行java.exe命令时，出现的异常。 |---- ArrayIndexOutOfBoundsException |---- NullPointerException |---- ClassCastException |---- NumberFormatException |---- InputMismatchException |---- ArithmeticException 1234567891011121314151617【面试题】说说你在开发中常见的异常都有哪些？开发1-2年：|----编译时异常：(受检异常)在执行javac.exe命令时，出现的异常。 |----- ClassNotFoundException |----- FileNotFoundException |----- IOException|----运行时异常：(非受检异常)在执行java.exe命令时，出现的异常。 |---- ArrayIndexOutOfBoundsException |---- NullPointerException |---- ClassCastException |---- NumberFormatException |---- InputMismatchException |---- ArithmeticException开发3年以上：OOM。 异常处理的方式123456789过程1：“抛” &gt;&quot;自动抛&quot; ： 程序在执行的过程当中，一旦出现异常，就会在出现异常的代码处，自动生成对应异常类的对象，并将此对象抛出。 &gt;&quot;手动抛&quot; ：程序在执行的过程当中，不满足指定条件的情况下，我们主动的使用&quot;throw + 异常类的对象&quot;方式抛出异常对象。过程2：“抓” 狭义上讲：try-catch的方式捕获异常，并处理。 广义上讲：把“抓”理解为“处理”。则此时对应着异常处理的两种方式：① try-catch-finally ② throws try-catch-finally12345678910111213141516171819202122232425261. 基本结构：try&#123; ...... //可能产生异常的代码&#125;catch( 异常类型1 e )&#123; ...... //当产生异常类型1型异常时的处置措施&#125;catch( 异常类型2 e )&#123; ...... //当产生异常类型2型异常时的处置措施&#125;finally&#123; ...... //无论是否发生异常，都无条件执行的语句&#125;2. 使用细节：&gt; 将可能出现异常的代码声明在try语句中。一旦代码出现异常，就会自动生成一个对应异常类的对象。并将此对象抛出。&gt; 针对于try中抛出的异常类的对象，使用之后的catch语句进行匹配。一旦匹配上，就进入catch语句块进行处理。 一旦处理接触，代码就可继续向下执行。&gt; 如果声明了多个catch结构，不同的异常类型在不存在子父类关系的情况下，谁声明在上面，谁声明在下面都可以。 如果多个异常类型满足子父类的关系，则必须将子类声明在父类结构的上面。否则，报错。&gt; catch中异常处理的方式： ① 自己编写输出的语句。 ② printStackTrace()：打印异常的详细信息。 （推荐） ③ getMessage()：获取发生异常的原因。&gt; try中声明的变量，出了try结构之后，就不可以进行调用了。&gt; try-catch结构是可以嵌套使用的。 123456789101112133. finally的使用说明：3.1 finally的理解&gt; 我们将一定要被执行的代码声明在finally结构中。&gt; 更深刻的理解：无论try中或catch中是否存在仍未被处理的异常，无论try中或catch中是否存在return语句等，finally 中声明的语句都一定要被执行。&gt; finally语句和catch语句是可选的，但finally不能单独使用。3.2 什么样的代码我们一定要声明在finally中呢？&gt; 我们在开发中，有一些资源（比如：输入流、输出流，数据库连接、Socket连接等资源），在使用完以后，必须显式的进行关闭操作，否则，GC不会自动的回收这些资源。进而导致内存的泄漏。 为了保证这些资源在使用完以后，不管是否出现了未被处理的异常的情况下，这些资源能被关闭。我们必须将这些操作声明在finally中！ throws12345678910111213141516171. 格式：在方法的声明处，使用&quot;throws 异常类型1,异常类型2,...&quot;2. 举例：public void test() throws 异常类型1,异常类型2,.. &#123; //可能存在编译时异常&#125;3. 是否真正处理了异常？&gt; 从编译是否能通过的角度看，看成是给出了异常万一要是出现时候的解决方案。此方案就是，继续向上抛出(throws)。&gt; 但是，此throws的方式，仅是将可能出现的异常抛给了此方法的调用者。此调用者仍然需要考虑如何处理相关异常。 从这个角度来看，throws的方式不算是真正意义上处理了异常。4. 方法的重写的要求：(针对于编译时异常来说的)子类重写的方法抛出的异常类型可以与父类被重写的方法抛出的异常类型相同，或是父类被重写的方法抛出的异常类型的子类。 开发中的经验之谈： 1234567开发中，如何选择异常处理的两种方式？(重要、经验之谈)- 如果程序代码中，涉及到资源的调用（流、数据库连接、网络连接等），则必须考虑使用try-catch-finally来处理， 保证不出现内存泄漏。- 如果父类被重写的方法没有throws异常类型，则子类重写的方法中如果出现异常，只能考虑使用try-catch-finally 进行处理，不能throws。- 开发中，方法a中依次调用了方法b,c,d等方法，方法b,c,d之间是递进关系。此时，如果方法b,c,d中有异常， 我们通常选择使用throws，而方法a中通常选择使用try-catch-finally。 手动throw异常对象1在方法内部，满足指定条件的情况下，使用&quot;throw 异常类的对象&quot;的方式抛出。 如何自定义异常类123① 继承于现有的异常体系。通常继承于RuntimeException \\ Exception② 通常提供几个重载的构造器③ 提供一个全局常量，声明为：static final long serialVersionUID; 123为什么需要自定义异常类？我们其实更关心的是，通过异常的名称就能直接判断此异常出现的原因。既然如此，我们就有必要在实际开发场景中，不满足我们指定的条件时，指明我们自己特有的异常类。通过此异常类的名称，就能判断出具体出现的问题。 企业真题（九）2.1 异常概述1. Java的异常体系简单介绍下（网*）123包含问题：&gt; 4.异常的顶级接口是什么（软**力）&gt; 异常类的继承关系,exception下都有哪些类？（上海*冉信息） 略 2. Java异常处理机制（*科软）两种处理方案：try-catch-finally ；throws 3. 异常的两种类型，Error和Exception的区别(上海冠*新创、北京中**译、*度)略 4. 运行时异常与一般异常有何异同？（华*思为）运行时异常：RuntimeException 编译可以通过。在运行时可能抛出。出现的概率高一些；一般针对于运行时异常，都不处理。 一般异常：Exception 编译不能通过。要求必须在编译之前，考虑异常的处理。不处理编译不通过。 5. 说几个你常见到的异常（华油**普）123类似问题：&gt; 请列出Java中常见的几种异常？（百*园）&gt; 给我一个你最常见到的runtime exception。（*蝶） 略 2.2 try-catch-finally1. 说说final、finally、finalize的区别（北京中**译、艾*软件、拓*思、*科软）12类似问题：&gt; 1. finally和final的区别（*科软） 略。 2. 如果不使用try-catch，程序出现异常会如何？(上海冠*新创科技)对于当前方法来讲，如果不使用try-catch，则在出现异常对象以后会抛出此对象。如果没有处理方案，就会终止程序的执行。 3. try … catch捕捉的是什么异常？（北京亿*东方）Exception。非Error 4. 如果执行finally代码块之前方法返回了结果或者jvm退出了，这时finally块中的代码还会执行吗?(恒*电子)特别的：System.exit(0); 5. 在try语句中有return语句，最后写finally语句，finally语句中的code会不会执行？何时执行？如果执行是在return前还是后（拓*思、华**为）略 6. 捕获异常在catch块里一定会进入finally吗？catch里能return吗？catch里return还会进finally吗？在try里return是什么情况？（*蓝）略 2.3 throw与throws1. throw和throws的区别？（北京亿**方、北京新*阳光）角度1：”形”，即使用的格式 12throw:使用在方法内部，“throw 异常类的对象”throws:使用在方法的声明处，&quot;throws 异常类1,异常类2,...&quot; 角度2：”角色”或作用不同。 123456上游排污，下游治污。过程1：“抛” &gt;throw过程2：“抓” &gt; try-catch ; throws 2. 子类重写父类抛出异常的方法，能否抛出比父类更高级别的异常类（顺*）不能！ 2.4 自定义异常1. 如何自定义一个异常？（*软国际）略 多线程几个概念1234567程序(program)：为完成特定任务，用某种语言编写的`一组指令的集合`。即指一段静态的代码。进程(process)：程序的一次执行过程，或是正在内存中运行的应用程序。程序是静态的，进程是动态的。 进程作为操作系统调度和分配资源的最小单位。线程(thread)：进程可进一步细化为线程，是程序内部的一条执行路径。 线程作为CPU调度和执行的最小单位 1234线程调度策略分时调度：所有线程`轮流使用` CPU 的使用权，并且平均分配每个线程占用 CPU 的时间。抢占式调度：让`优先级高`的线程以`较大的概率`优先使用 CPU。如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。 12345678&gt; 单核CPU与多核CPU• 单核 CPU，在一个时间单元内，只能执行一个线程的任务。&gt; 并行与并发• 并行（parallel）：指两个或多个事件在同一时刻发生（同时发生）。指在同一时刻，有多条指令在多个 CPU 上同时执行。比如：多个人同时做不同的事。 • 并发（concurrency）：指两个或多个事件在同一个时间段内发生。即在一段时间内，有多条指令在单个 CPU 上快速轮换、交替执行，使得在宏观上具有多个进程同时执行的效果。 2. 如何创建多线程（重点）Java 语言的 JVM 允许程序运行多个线程，使用 java.lang.Thread 类代表线程，所有的线程对象都必须是 Thread 类或其子类的实例。 方式1：继承Thread类 Thread 类的特性： 每个线程都是通过某个特定 Thread 对象的 run()方法来完成操作的，因此 把 run()方法体称为线程执行体。 通过该 Thread 对象的 start()方法来启动这个线程，而非直接调用 run() 要想实现多线程，必须在主线程中创建新的线程对象。 方式2：实现Runnable接口 Java 有单继承的限制，当我们无法继承 Thread 类时，那么该如何做呢？在核心类库中提供了 Runnable 接口，我们可以实现 Runnable 接口，重写 run()方法，然后再通过 Thread 类的对象代理启动和执行我们的线程体 run()方法123456 //创建自定义类对象 线程任务对象MyRunnable mr = new MyRunnable();//创建线程对象Thread t = new Thread(mr, &quot;长江&quot;); 使用匿名内部类对象来实现线程的创建和启动 123456789101112131415161718new Thread(&quot;新的线程！&quot;)&#123;@Overridepublic void run() &#123;for (int i = 0; i &lt; 10; i++) &#123;System.out.println(getName()+&quot;：正在执行！&quot;+i);&#125;&#125;&#125;.start();new Thread(new Runnable()&#123;@Overridepublic void run() &#123;for (int i = 0; i &lt; 10; i++) &#123;System.out.println(Thread.currentThread().getName()+&quot;：&quot; +i);&#125;&#125;&#125;).start(); 方式3：实现Callable接口 （jdk5.0新增） 与使用 Runnable 相比， Callable 功能更强大些 相比 run()方法，可以有返回值 方法可以抛出异常 支持泛型的返回值（需要借助 FutureTask 类，获取返回结果） Future 接口（了解） 可以对具体 Runnable、Callable 任务的执行结果进行取消、查询是否完成、获取结果等。 FutureTask 是 Futrue 接口的唯一的实现类 FutureTask 同时实现了 Runnable, Future 接口。它既可以作为Runnable 被线程执行，又可以作为 Future 得到 Callable 的返回值 缺点：在获取分线程执行结果的时候，当前线程（或是主线程）受阻塞，效率较低。 方式4：使用线程池（jdk5.0新增） 12345678910• ExecutorService：真正的线程池接口。常见子类 ThreadPoolExecutor– void execute(Runnable command) ：执行任务/命令，没有返回值，一般用来执行 Runnable– &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)：执行任务，有返回值，一般又来执行 Callable– void shutdown() ：关闭连接池• Executors：一个线程池的工厂类，通过此类的静态工厂方法可以创建多种类型的线程池对象。– Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池– Executors.newFixedThreadPool(int nThreads); 创建一个可重用固定线程数的线程池– Executors.newSingleThreadExecutor() ：创建一个只有一个线程的线程池– Executors.newScheduledThreadPool(int corePoolSize)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。 3. Thread类的常用方法、线程的生命周期123456789101112131415161718192021222324252627熟悉常用的构造器和方法：1. 线程中的构造器- public Thread() :分配一个新的线程对象。- public Thread(String name) :分配一个指定名字的新的线程对象。- public Thread(Runnable target) :指定创建线程的目标对象，它实现了Runnable接口中的run方法- public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字。2.线程中的常用方法：&gt; start():①启动线程 ②调用线程的run()&gt; run():将线程要执行的操作，声明在run()中。&gt; currentThread():获取当前执行代码对应的线程&gt; getName(): 获取线程名&gt; setName(): 设置线程名&gt; sleep(long millis):静态方法，调用时，可以使得当前线程睡眠指定的毫秒数&gt; yield():静态方法，一旦执行此方法，就释放CPU的执行权，让系统的线程调度器重新调度一次&gt; join(): 在线程a中通过线程b调用join()，意味着线程a进入阻塞状态，直到线程b执行结束，线程a才结束阻塞状态，继续执行。&gt; isAlive():判断当前线程是否存活3. 线程的优先级：getPriority():获取线程的优先级setPriority():设置线程的优先级。范围[1,10]Thread类内部声明的三个常量：- MAX_PRIORITY（10）：最高优先级- MIN _PRIORITY （1）：最低优先级- NORM_PRIORITY （5）：普通优先级，默认情况下main线程具有普通优先级。 线程的生命周期： jdk5.0之前： 线程的生命周期有五种状态：新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）、死亡（Dead） jdk5.0及之后：Thread类中定义了一个内部类State 1234567891011121314public enum State &#123; NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED;&#125; 4. 如何解决线程安全问题(重点、难点) 什么是线程的安全问题？多个线程操作共享数据，就有可能出现安全问题。 如何解决线程的安全问题？有几种方式？ 同步机制：① 同步代码块 ② 同步方法 同步代码块：synchronized 关键字可以用于某个区块前面，表示只对这个区块 的资源实行互斥访问 123synchronized(同步锁)&#123;需要同步操作的代码&#125; 同步方法：synchronized 关键字直接修饰方法，表示同一时刻只有一个线程能进入这个方法，其他线程在外面等着。 1234public synchronized void method()&#123;可能会产生线程安全问题的代码&#125; - 重点关注两个事：共享数据及操作共享数据的代码；同步监视器（保证唯一性） 12在实现Runnable接口的方式中，同步监视器可以考虑使用：this。在继承Thread类的方式中，同步监视器要慎用this，可以考虑使用：当前类.class。 12非静态的同步方法，默认同步监视器是this静态的同步方法，默认同步监视器是当前类本身。 jdk5.0新增：Lock接口及其实现类。（保证多个线程共用同一个Lock的实例） Lock 锁也称同步锁，加锁与释放锁方法，如下： public void lock() :加同步锁。 public void unlock() :释放同步锁。 synchronized 与 Lock 的对比 Lock 是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized 是隐式锁，出了作用域、遇到异常等自动解锁 Lock 只有代码块锁，synchronized 有代码块锁和方法锁 使用 Lock 锁，JVM 将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类），更体现面向对象。 （了解）Lock 锁可以对读不加锁，对写加锁，synchronized 不可以 （了解）Lock 锁可以有多种获取锁的方式，可以从 sleep 的线程中抢到锁，synchronized 不可以说明：开发建议中处理线程安全问题优先使用顺序为：Lock —-&gt; 同步代码块 —-&gt; 同步方法 5. 同步机制相关的问题 懒汉式的线程安全的写法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class LazyOne &#123;private static LazyOne instance;private LazyOne()&#123;&#125;//方式 1：public static synchronized LazyOne getInstance1()&#123;if(instance == null)&#123;instance = new LazyOne();&#125;return instance;&#125;//方式 2：public static LazyOne getInstance2()&#123;synchronized(LazyOne.class) &#123;if (instance == null) &#123;instance = new LazyOne();&#125;return instance;&#125;&#125;//方式 3：public static LazyOne getInstance3()&#123;if(instance == null)&#123;synchronized (LazyOne.class) &#123;try &#123;Thread.sleep(10);//加这个代码，暴露问题&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;if(instance == null)&#123;instance = new LazyOne();&#125;&#125;&#125;return instance;&#125;/*注意：上述方式 3 中，有指令重排问题mem = allocate(); 为单例对象分配内存空间instance = mem; instance 引用现在非空，但还未初始化ctorSingleton(instance); 为单例对象通过 instance 调用构造器从 JDK2 开始，分配空间、初始化、调用构造器会在线程的工作存储区一次性完成，然后复制到主存储区。但是需要 volatile 关键字，避免指令重排。*/&#125; 同步机制会带来的问题：死锁 死锁产生的条件及规避方式• 互斥条件• 占用且等待• 不可抢夺（或不可抢占）• 循环等待以上 4 个条件，同时出现就会触发死锁。 6. 线程间的通信 在同步机制下，考虑线程间的通信 wait() 、notify() 、notifyAll() 都需要使用在同步代码块或同步方法中。 高频笔试题：wait() &#x2F; sleep()相同点：一旦执行，都会使得当前线程结束执行状态，进入阻塞状态。不同点：① 定义方法所属的类：sleep():Thread 中定义。 wait():Object 中定义② 使用范围的不同：sleep()可以在任何需要使用的位置被调用； wait():必须使用在同步代码块或同步方法中③ 都在同步结构中使用的时候，是否释放同步监视器的操作不同：sleep():不会释放同步监视器 ;wait():会释放同步监视器④ 结束等待的方式不同：sleep()：指定时间一到就结束阻塞。 wait():可以指定时间也可以无限等待直到 notify 或 notifyAll。 企业真题（十）2.1 线程概述1. 什么是线程(*云网络)略 2. 线程和进程有什么区别(*团、腾*、*云网络、神**岳、言*有物、直*科技)进程：对应一个运行中的程序。 线程：运行中的进程的一条或多条执行路径。 3. 多线程使用场景（嘉*医疗） 手机app应用的图片的下载 迅雷的下载 Tomcat服务器上web应用，多个客户端发起请求，Tomcat针对多个请求开辟多个线程处理 2.2 如何实现多线程1. 如何在Java中出实现多线程？(阿*校招、当*置业、鸿*网络、奥*医药、*科软、慧*、上海驿*软件、海*科)123类似问题：&gt; 创建多线程用Runnable还是Thread(北京中*瑞飞)&gt; 多线程有几种实现方法，都是什么？（锐*（上海）企业管理咨询） 四种。 2. Thread类中的start()和run()有什么区别？(北京中油**、爱*信、神*泰岳、直*科技，*软国际，上海*学网络)start()：① 开启线程 ② 调用线程的run() 3. 启动一个线程是用run()还是start()?（*度）start() 4. Java中Runnable和Callable有什么不同？(平*金服、银*数据、好*在、亿*征信、花儿**网络)123456与之前的方式的对比：与Runnable方式的对比的好处&gt; call()可以有返回值，更灵活&gt; call()可以使用throws的方式处理异常，更灵活&gt; Callable使用了泛型参数，可以指明具体的call()的返回值类型，更灵活有缺点吗？如果在主线程中需要获取分线程call()的返回值，则此时的主线程是阻塞状态的。 5. 什么是线程池，为什么要使用它？(上海明*物联网科技)1234此方式的好处：&gt; 提高了程序执行的效率。（因为线程已经提前创建好了）&gt; 提高了资源的复用率。（因为执行完的线程并未销毁，而是可以继续执行其他的任务）&gt; 可以设置相关的参数，对线程池中的线程的使用进行管理 2.3 常用方法、生命周期1. sleep() 和 yield()区别？(神*泰岳)sleep()：一旦调用，就进入“阻塞”（或TIMED_WAITING状态） yield():释放cpu的执行权，处在RUNNABLE的状态 2. 线程创建的中的方法、属性情况？(招通**、数*互融)略 3. 线程的生命周期？(中国**电子商务中心、*科软、慧*)略 4. 线程的基本状态以及状态之间的关系？(直*科技)1234类似问题：&gt; 线程有哪些状态？如何让线程进入阻塞？（华*中*，*兴）&gt; 线程有几个状态，就绪和阻塞有什么不同。（美*）&gt; Java的线程都有哪几种状态（字*跳动、*东、*手） 略 5. stop()和suspend()方法为何不推荐使用？（上海驿*软件）stop()：一旦执行，线程就结束了，导致run()有未执行结束的代码。stop()会导致释放同步监视器，导致线程安全问题。 suspend()：与resume()搭配使用，导致死锁。 6. Java 线程优先级是怎么定义的？（软*动力）三个常量。[1,10] 2.4 线程安全与同步机制1. 你如何理解线程安全的？线程安全问题是如何造成的？（*软国际）1234类似问题：&gt; 线程安全说一下？（奥*医药）&gt; 对线程安全的理解（*度校招）&gt; 什么是线程安全？(银*数据) 略 2. 多线程共用一个数据变量需要注意什么？（史*夫软件）线程安全问题 3. 多线程保证线程安全一般有几种方式？（来*科技、北京*信天*）123456789类似问题：&gt; 如何解决其线程安全问题，并且说明为什么这样子去解决？（北京联合**）&gt; 请说出你所知道的线程同步的方法。（天*伟业）&gt; 哪些方法实现线程安全？（阿*） &gt; 同步有几种实现方法，都是什么? （锐*企业管理咨询）&gt; 你在实际编码过程中如何避免线程安全问题？（*软国际）&gt; 如何让线程同步?（*手）&gt; 多线程下有什么同步措施（阿*校招）&gt; 同步有几种实现方法，都是什么？（海*科） 同步机制 Lock接口 4. 用什么关键字修饰同步方法?（上海驿*软件）synchronized 5. synchronized加在静态方法和普通方法区别（来*科技）同步监视器不同。静态：当前类本身 非静态：this 6. Java中synchronized和ReentrantLock有什么不同(三*重工)1234类似问题：&gt; 多线程安全机制中 synchronized和lock的区别（中*国际、*美、鸿*网络）&gt; 怎么实现线程安全，各个实现方法有什么区别？（美*、字*跳动）&gt; synchronized 和 lock 区别（阿*、*壳） 123synchronized不管是同步代码块还是同步方法，都需要在结束一对&#123;&#125;之后，释放对同步监视器的调用。Lock是通过两个方法控制需要被同步的代码，更灵活一些。Lock作为接口，提供了多种实现类，适合更多更复杂的场景，效率更高。 7. 当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?（鸿*网络）需要看其他方法是否使用synchronized修饰，同步监视器的this是否是同一个。 只有当使用了synchronized，且this是同一个的情况下，就不能访问了。 8. 线程同步与阻塞的关系？同步一定阻塞吗？阻塞一定同步吗？（阿*校招、西安*创佳*）同步一定阻塞；阻塞不一定同步。 2.5 死锁1. 什么是死锁，产生死锁的原因及必要条件（腾*、阿*）1234567891011121314151617181. 如何看待死锁？不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。我们编写程序时，要避免出现死锁。2. 诱发死锁的原因？- 互斥条件- 占用且等待- 不可抢夺（或不可抢占）- 循环等待以上4个条件，同时出现就会触发死锁。3. 如何避免死锁？针对条件1：互斥条件基本上无法被破坏。因为线程需要通过互斥解决安全问题。针对条件2：可以考虑一次性申请所有所需的资源，这样就不存在等待的问题。针对条件3：占用部分资源的线程在进一步申请其他资源时，如果申请不到，就主动释放掉已经占用的资源。针对条件4：可以将资源改为线性顺序。申请资源时，先申请序号较小的，这样避免循环等待问题。 2. 如何避免死锁？(阿*、北京*蓝、*手)见上。 2.6 线程通信1. Java中notify()和notifyAll()有什么区别(汇*天下)123notify():一旦执行此方法，就会唤醒被wait()的线程中优先级最高的那一个线程。（如果被wait()的多个线程的优先级相同，则 随机唤醒一个）。被唤醒的线程从当初被wait的位置继续执行。notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。 2. 为什么wait()和notify()方法要在同步块中调用(北京*智)因为调用者必须是同步监视器。 3. 多线程：生产者，消费者代码（同步、wait、notifly编程）（猫*娱乐）1234类似问题：&gt; 如何写代码来解决生产者消费者问题(上海明*物联网)&gt; 多线程中生产者和消费者如何保证同步（*为）&gt; 消费者生产者，写写伪代码（字*） 略 4. wait()和sleep()有什么区别？调用这两个函数后，线程状态分别作何改变？（字*、*东）1234类似问题：&gt; 线程中sleep()和wait()有什么区别？（外派*度）&gt; Java线程阻塞调用 wait 函数和 sleep 区别和联系（阿*）&gt; wait和sleep的区别，他们两个谁会释放锁（软*动力、*创） 1234567891011相同点：一旦执行，当前线程都会进入阻塞状态不同点：&gt; 声明的位置：wait():声明在Object类中 sleep():声明在Thread类中，静态的&gt; 使用的场景不同：wait():只能使用在同步代码块或同步方法中 sleep():可以在任何需要使用的场景&gt; 使用在同步代码块或同步方法中：wait():一旦执行，会释放同步监视器 sleep():一旦执行，不会释放同步监视器&gt; 结束阻塞的方式：wait(): 到达指定时间自动结束阻塞 或 通过被notify唤醒，结束阻塞 sleep(): 到达指定时间自动结束阻塞 2.7 单例模式（线程安全）1. 手写一个单例模式(Singleton)，还要安全的（*通快递、君*科技）饿汉式；安全的懒汉式；内部类； 2. 手写一个懒汉式的单例模式&amp;解决其线程安全问题，并且说明为什么这样子去解决（5*）12类似问题：&gt; 手写一个懒汉式的单例模式（北京联合**） 同上。 常用类与基础APIString类java.lang.String，字符串是常量，用双引号引起来表示。它们的值在创建之后不能更改 String的声明：final修饰、实现了Comparable接口 String的不可变性 当对字符串变量重新赋值时，需要重新指定一个字符串常量的位置进行赋值，不能在原有的位置修改 当对现有的字符串进行拼接或replace()操作时，需要重新开辟空间保存操作后的字符串，不能在原有的位置修改 String的两种定义方式：① 字面量的定义方式 String s &#x3D; “hello” ② new 的方式：String s &#x3D; new String(“hello”); String的内存解析：字符串常量池、堆内存的使用 String s &#x3D; new String(“hello”);在内存中创建的对象的个数。→ 创建了两个对象 String的连接操作：+ 常量 + 常量：结果仍然存储在字符串常量池中，返回此字面量地址，此时的常量可能是字面量，也可能是final修饰的变量 、变量 + 常量 or 变量 + 变量：都会通过new的方式创建一个新的字符串，返回堆空间中此字符串对象的地址、concat(String otherString)：调用完都返回一个新new的对象 String intern()：返回的是字符串常量池中字面量的地址 熟悉String的构造器、与其他结构之间的转换 字符串 –&gt; 基本数据类型、包装类 public static int parseInt(String s) 基本数据类型、包装类 –&gt; 字符串 public String valueOf(int n) 字符串 –&gt; 字符数组 public char[] toCharArray()：将字符串中的全部字符存放在一个字符数组中的方法。public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)：提供了将指定索引范围内的字符串存放到数组中的方法 字符数组 –&gt; 字符串 String 类的构造器 编码和解码 编码：字符、字符串 –&gt; 字节、字节数组。对应着编码集 解码：字节、字节数组 –&gt; 字符、字符串。对应着解码集 在utf-8字符集中，一个汉字占用3个字节，一个字母1个字节，在gbk字符集中，一个汉字占用2个字节，一个字母1个字节 均向下兼容ASCII码 规则：解码集必须使用当初编码时使用的编码集。只要不一致，就可能出现乱码！ String常用方法 boolean isEmpty()：字符串是否为空 int length()：返回字符串的长度 String concat(xx)：拼接 boolean equals(Object obj)：比较字符串是否相等，区分大小写 boolean equalsIgnoreCase(Object obj)：比较字符串是否相等，不区分大小写 int compareTo(String other)：比较字符串大小，区分大小写，按照 Unicode 编码值比较大小 int compareToIgnoreCase(String other)：比较字符串大小，不区分大小写 String toLowerCase()：将字符串中大写字母转为小写 String toUpperCase()：将字符串中小写字母转为大写 String trim()：去掉字符串前后空白符 public String intern()：结果在常量池中共享 boolean contains(xx)：是否包含 xx int indexOf(xx)：从前往后找当前字符串中 xx，即如果有返回第一次出现的下标，要是没有返回-1 int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始 int lastIndexOf(xx)：从后往前找当前字符串中 xx，即如果有返回最后一次出现的下标，要是没有返回-1 int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。 String substring(int beginIndex) ：返回一个新的字符串，它是此字符串的从 beginIndex 开始截取到最后的一个子字符串。 String substring(int beginIndex, int endIndex) ：返回一个新字符串，它是此字符串从 beginIndex 开始截取到 endIndex(不包含)的一个子字符串。 char charAt(index)：返回index位置的字符 char[] toCharArray()： 将此字符串转换为一个新的字符数组返回 static String valueOf(char[] data) ：返回指定数组中表示该字符序列的 String static String valueOf(char[] data, int offset, int count) ： 返回指定数组中表示该字符序列的 String static String copyValueOf(char[] data)： 返回指定数组中表示该字符序列的 String static String copyValueOf(char[] data, int offset, int count)：返回指定数组中表示该字符序列的 String boolean startsWith(xx)：测试此字符串是否以指定的前缀开始 boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始 boolean endsWith(xx)：测试此字符串是否以指定的后缀结束 String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 不支持正则。 String replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。 String replaceAll(String regex, String replacement)：使用给定的replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 String replaceFirst(String regex, String replacement)：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。 String相关的算法问题。 模拟一个 trim 方法，去除字符串两端的空格。 将一个字符串进行反转。将字符串中指定部分进行反转。比如“abcdefg”反转为”abfedcg” 获取一个字符串在另一个字符串中出现的次数。 比如：获取“ ab”在“abkkcadkabkebfkabkskab” 中出现的次数 获取两个字符串中最大相同子串。比如： str1 &#x3D; “abcwerthelloyuiodef”;str2 &#x3D; “cvhellobnm” 提示：将短的那个串进行长度依次递减的子串与较长的串比较。 对字符串中字符进行自然顺序排序。 提示： 1）字符串变成字符数组。 2）对数组排序，选择，冒泡，Arrays.sort(); 3）将排序后的数组变成字符串。 StringBuffer、StringBuilder类因为 String 对象是不可变对象，虽然可以共享常量对象，但是对于频繁字符串的修改和拼接操作，效率极低，空间消耗也比较高。因此，JDK 又在 java.lang包提供了可变字符序列 StringBuffer 和 StringBuilder 类型。 [面试题]String、StringBuffer、StringBuilder的区别 String:不可变的字符序列;底层使用char[] （jdk8及之前），底层使用byte[] （jdk9及之后）StringBuffer:可变的字符序列;JDK1.0声明，线程安全的，效率低;底层使用char[] （jdk8及之前），底层使用byte[] （jdk9及之后）StringBuilder:可变的字符序列;JDK5.0声明，线程不安全的,效率高;底层使用char[] （jdk8及之前），底层使用byte[] （jdk9及之后） 知道什么场景下使用StringBuffer、StringBuilder 如果开发中需要频繁的针对于字符串进行增、删、改等操作，建议使用StringBuffer或StringBuilder替换String.因为使用String效率低。如果开发中，不涉及到线程安全问题，建议使用StringBuilder替换StringBuffer。因为使用StringBuilder效率高如果开发中大体确定要操作的字符的个数，建议使用带int capacity参数的构造器。因为可以避免底层多次扩容操作，性能更高。 StringBuffer和StringBuilder中的常用方法增： append(xx)删： delete(int start, int end) deleteCharAt(int index)改： replace(int start, int end, String str) setCharAt(int index, char c)查： charAt(int index)插： insert(int index, xx)长度： length() 执行效率：StringBuilder &gt; StringBuffer &gt; String（从高到低） jdk8之前的日期、时间API System的currentTimeMillis() 两个Date的使用 java.util.Date:getTime(),toString(),很多过时的方法 java.sql.Date java.text.SimpleDateFormat,SimpleDateFormat类是一个不与语言环境有关的方式来格式化和解析日期的具体类 Calendar日历类的使用,使用 Calendar.getInstance()方法获取 Calendar 实例 public int get(int field)：返回给定日历字段的值 public void set(int field,int value) ：将给定的日历字段设置为指定的值 public void add(int field,int amount)：根据日历的规则，为给定的日历字段添加或者减去指定的时间量 public final Date getTime()：将 Calendar 转成 Date 对象 public final void setTime(Date date)：使用指定的 Date 对象重置 Calendar的时间 jdk8中新的日期、时间API之前API面临的问题： 可变性：像日期和时间这样的类应该是不可变的。 偏移性：Date 中的年份是从 1900 开始的，而月份都从 0 开始。 格式化：格式化只对 Date 有用，Calendar 则不行。 此外，它们也不是线程安全的；不能处理闰秒等。 LocalDate、LocalTime、LocalDateTime –&gt;类似于Calendar Instant –&gt;类似于Date DateTimeFormatter —&gt;类似于SimpleDateFormat 比较器(重点) 自然排序 涉及到java.lang.Comparable，实现 Comparable 的类必须实现 compareTo(Object obj)方法，两个对象即通过compareTo(Object obj) 方法的返回值来比较大小。如果当前对象 this 大于形参对象obj，则返回正整数，如果当前对象 this 小于形参对象 obj，则返回负整数，如果当前对象 this 等于形参对象 obj，则返回零。 实现 Comparable 接口的对象列表（和数组）可以通过 Collections.sort 或Arrays.sort 进行自动排序。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。 Comparable 的典型实现： String：按照字符串中字符的 Unicode 值进行比较 Character：按照字符的 Unicode 值来进行比较 数值类型对应的包装类以及 BigInteger、BigDecimal：按照它们对应的数值大小进行比较 Boolean：true 对应的包装类实例大于 false 对应的包装类实例 Date、Time 等：后面的日期时间比前面的日期时间大 定制排序场景： 当元素的类型没有实现 java.lang.Comparable 接口而又不方便修改代码（例如：一些第三方的类，你只有.class 文件，没有源文件） 如果一个类，实现了 Comparable 接口，也指定了两个对象的比较大小的规则，但是此时此刻我不想按照它预定义的方法比较大小，但是我又不能随意修改，因为会影响其他地方的使用，怎么办？ 涉及到java.util.Comparator 重写 compare(Object o1,Object o2)方法，比较 o1 和 o2 的大小：如果方法返回正整数，则表示 o1 大于 o2；如果返回 0，表示相等；返回负整数，表示 o1 小于 o2。 可以将 Comparator 传递给 sort 方法（如 Collections.sort 或 Arrays.sort），从而允许在排序顺序上实现精确控制。 其它APIjava.lang.System 类 System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。 由于该类的构造器是private的，所以无法创建该类的对象。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。 成员变量 Scanner scan &#x3D; new Scanner(System.in); System类内部包含in、out和err三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。 成员方法 native long currentTimeMillis()：该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。 void exit(int status)：该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。 void gc()：该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。 String getProperty(String key)：该方法的作用是获得系统中属性名为key的属性对应的值。 java.lang.Runtime类每个 Java 应用程序都有一个 Runtime 类实例，使应用程序能够与其运行的环境相连接。 public static Runtime getRuntime()： 返回与当前 Java 应用程序相关的运行时对象。应用程序不能创建自己的 Runtime 类实例。 public long totalMemory()：返回 Java 虚拟机中初始化时的内存总量。此方法返回的值可能随时间的推移而变化，这取决于主机环境。默认为物理电脑内存的1&#x2F;64。 public long maxMemory()：返回 Java 虚拟机中最大程度能使用的内存总量。默认为物理电脑内存的1&#x2F;4。 public long freeMemory()：回 Java 虚拟机中的空闲内存量。调用 gc 方法可能导致 freeMemory 返回值的增加。 和数学相关的类 java.lang.Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具类，其所有方法均为静态方法，并且不会创建对象，调用起来非常简单。 public static double abs(double a) ：返回 double 值的绝对值。 12double d1 = Math.abs(-5); //d1的值为5double d2 = Math.abs(5); //d2的值为5 public static double ceil(double a) ：返回大于等于参数的最小的整数。 123double d1 = Math.ceil(3.3); //d1的值为 4.0double d2 = Math.ceil(-3.3); //d2的值为 -3.0double d3 = Math.ceil(5.1); //d3的值为 6.0 public static double floor(double a) ：返回小于等于参数最大的整数。 123double d1 = Math.floor(3.3); //d1的值为3.0double d2 = Math.floor(-3.3); //d2的值为-4.0double d3 = Math.floor(5.1); //d3的值为 5.0 public static long round(double a) ：返回最接近参数的 long。(相当于四舍五入方法) 1234long d1 = Math.round(5.5); //d1的值为6long d2 = Math.round(5.4); //d2的值为5long d3 = Math.round(-3.3); //d3的值为-3long d4 = Math.round(-3.8); //d4的值为-4 public static double pow(double a,double b)：返回a的b幂次方法 public static double sqrt(double a)：返回a的平方根 public static double random()：返回[0,1)的随机值 public static final double PI：返回圆周率 public static double max(double x, double y)：返回x,y中的最大值 public static double min(double x, double y)：返回x,y中的最小值 其它：acos,asin,atan,cos,sin,tan 三角函数 1234double result = Math.pow(2,31);double sqrt = Math.sqrt(256);double rand = Math.random();double pi = Math.PI; java.math包BigInteger Integer类作为int的包装类，能存储的最大整型值为2^31-1，Long类也是有限的，最大为2^63-1。如果要表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力，更不用说进行运算了。 java.math包的BigInteger可以表示不可变的任意精度的整数。BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。 构造器 BigInteger(String val)：根据字符串构建BigInteger对象 方法 public BigInteger abs()：返回此 BigInteger 的绝对值的 BigInteger。 BigInteger add(BigInteger val) ：返回其值为 (this + val) 的 BigInteger BigInteger subtract(BigInteger val) ：返回其值为 (this - val) 的 BigInteger BigInteger multiply(BigInteger val) ：返回其值为 (this * val) 的 BigInteger BigInteger divide(BigInteger val) ：返回其值为 (this &#x2F; val) 的 BigInteger。整数相除只保留整数部分。 BigInteger remainder(BigInteger val) ：返回其值为 (this % val) 的 BigInteger。 BigInteger[] divideAndRemainder(BigInteger val)：返回包含 (this &#x2F; val) 后跟 (this % val) 的两个 BigInteger 的数组。 BigInteger pow(int exponent) ：返回其值为 (this^exponent) 的 BigInteger。 BigDecimal 一般的Float类和Double类可以用来做科学计算或工程计算，但在商业计算中，要求数字精度比较高，故用到java.math.BigDecimal类。 BigDecimal类支持不可变的、任意精度的有符号十进制定点数。 构造器 public BigDecimal(double val) public BigDecimal(String val) –&gt; 推荐 常用方法 public BigDecimal add(BigDecimal augend) public BigDecimal subtract(BigDecimal subtrahend) public BigDecimal multiply(BigDecimal multiplicand) public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)：divisor是除数，scale指明保留几位小数，roundingMode指明舍入模式（ROUND_UP :向上加1、ROUND_DOWN :直接舍去、ROUND_HALF_UP:四舍五入） java.util.Random用于产生随机数 boolean nextBoolean():返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的 boolean 值。 void nextBytes(byte[] bytes):生成随机字节并将其置于用户提供的 byte 数组中。 double nextDouble():返回下一个伪随机数，它是取自此随机数生成器序列的、在 0.0 和 1.0 之间均匀分布的 double 值。 float nextFloat():返回下一个伪随机数，它是取自此随机数生成器序列的、在 0.0 和 1.0 之间均匀分布的 float 值。 double nextGaussian():返回下一个伪随机数，它是取自此随机数生成器序列的、呈高斯（“正态”）分布的 double 值，其平均值是 0.0，标准差是 1.0。 int nextInt():返回下一个伪随机数，它是此随机数生成器的序列中均匀分布的 int 值。 int nextInt(int n):返回一个伪随机数，它是取自此随机数生成器序列的、在 0（包括）和指定值（不包括）之间均匀分布的 int 值。 long nextLong():返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的 long 值。 企业真题（十一）2.1 String1. 以下两种方式创建的String对象有什么不同？（*团）123String str = new String(&quot;test&quot;);String str = &quot;test&quot;; 略 2. String s &#x3D; new String(“xyz”);创建了几个String Object? （新*陆）两个 3. String a&#x3D;”abc” String b&#x3D;”a”+”bc” 问a&#x3D;&#x3D;b?（网*邮箱）是！ 4. String 中 “+” 怎样实现?（阿*）常量 + 常量 ：略 变量 + 常量 、变量+变量：创建一个StringBuilder的实例，通过append()添加字符串，最后调用toString()返回一个字符串。（toString()内部new 一个String的实例） 5. Java中String是不是final的？（凡*科技）1234类似问题：&gt; String被哪些类继承？（网*邮箱）&gt; 是否可以继承String类?（湖南*利软件）&gt; String 是否可以继承?（阿*） 是 6. String为啥不可变，在内存中的具体形态？（阿*）规定不可变。 String：提供字符串常量池。 7. String 可以在 switch中使用吗?(上海*睿)可以。从jdk7开始可以使用 8. String中有哪些方法?列举几个（闪*购）。。。 9. subString()到底做了什么?(银*数据)String str &#x3D; “hello”; String subStr &#x3D; str.subString(1,3); &#x2F;&#x2F;底层是new的方式返回一个subStr，实体内容是”el” 2.2 String、StringBuffer、StringBuilder1. Java中操作字符串有哪些类？他们之间有什么区别。（南*电网）1234类似问题：&gt; String 和 StringBuffer区别？(亿*国际、天*隆、*团)&gt; StringBuilder和StrignBuffer的区别？（平*金服）&gt; StringBuilder和StringBuffer的区别以及实现？（*为） 123&gt; String:不可变的字符序列;底层使用char[] （jdk8及之前），底层使用byte[] （jdk9及之后）&gt; StringBuffer:可变的字符序列;JDK1.0声明，线程安全的，效率低;底层使用char[] （jdk8及之前），底层使用byte[] （jdk9及之后）&gt; StringBuilder:可变的字符序列;JDK5.0声明，线程不安全的,效率高;底层使用char[] （jdk8及之前），底层使用byte[] （jdk9及之后） 2. String的线程安全问题（闪*购）线程不安全的 3. StringBuilder和StringBuffer的线程安全问题（润*软件）略 2.3 Comparator与Comparable1. 简单说说 Comparable 和 Comparator 的区别和场景？（软**力）略 2. Comparable 接口和 Comparator 接口实现比较（阿*）略 集合框架数组存储数据方面的特点和弊端123456789101112131415161718数组存储多个数据方面的特点：&gt; 数组一旦初始化，其长度就是确定的。&gt; 数组中的多个元素是依次紧密排列的，有序的，可重复的&gt; (优点) 数组一旦初始化完成，其元素的类型就是确定的。不是此类型的元素，就不能添加到此数组中。 int[] arr = new int[10]; arr[0] = 1; arr[1] = &quot;AA&quot;;//编译报错 Object[] arr1 = new Object[10]; arr1[0] = new String(); arr1[1] = new Date();&gt; (优点)元素的类型既可以是基本数据类型，也可以是引用数据类型。数组存储多个数据方面的弊端：&gt; 数组一旦初始化，其长度就不可变了。&gt; 数组中存储数据特点的单一性。对于无序的、不可重复的场景的多个数据就无能为力了。&gt; 数组中可用的方法、属性都极少。具体的需求，都需要自己来组织相关的代码逻辑。&gt; 针对于数组中元素的删除、插入操作，性能较差。 Java集合框架体系（java.util包下）12345678910java.util.Collection:存储一个一个的数据 |-----子接口：List:存储有序的、可重复的数据 (&quot;动态&quot;数组) |---- ArrayList(主要实现类)、LinkedList、Vector |-----子接口：Set:存储无序的、不可重复的数据(高中学习的集合) |---- HashSet(主要实现类)、LinkedHashSet、TreeSetjava.util.Map:存储一对一对的数据(key-value键值对，(x1,y1)、(x2,y2) --&gt; y=f(x),类似于高中的函数) |---- HashMap(主要实现类)、LinkedHashMap、TreeMap、Hashtable、Properties 12345学习的程度把握：层次1：针对于具体特点的多个数据，知道选择相应的适合的接口的主要实现类，会实例化，会调用常用的方法。层次2：区分接口中不同的实现类的区别。*****************层次3：① 针对于常用的实现类，需要熟悉底层的源码 ② 熟悉常见的数据结构 （第14章讲） Collection的常用方法常用方法123456789101112131415add(Object obj)addAll(Collection coll)clear()isEmpty()size()contains(Object obj)containsAll(Collection coll)retainAll(Collection coll)remove(Object obj)removeAll(Collection coll)hashCode()equals()toArray()**************iterator() ---&gt; 引出了迭代器接口 12向Collection中添加元素的要求：&gt; 要求元素所属的类一定要重写equals()! 123集合与数组的相互转换：集合 ---&gt; 数组：toArray()数组 ---&gt; 集合：调用Arrays的静态方法asList(Object ... objs)，返回一个List 迭代器接口 设计模式的一种 迭代器不负责数据的存储；负责对集合类的遍历 12345671. 如何获取迭代器(Iterator)对象？Iterator iterator = coll.iterator();2. 如何实现遍历(代码实现)while(iterator.hasNext())&#123; System.out.println(iterator.next()); //next():①指针下移 ② 将下移以后集合位置上的元素返回&#125; 增强for循环(foreach循环)的使用（jdk5.0新特性） 123for(要遍历的集合或数组元素的类型 临时变量 : 要遍历的集合或数组变量)&#123; 操作临时变量的输出&#125; 针对于集合来讲，增强for循环的底层仍然使用的是迭代器。增强for循环的执行过程中，是将集合或数组中的元素依次赋值给临时变量，注意，循环体中对临时变量的修改，可能不会导致原有集合或数组中元素的修改。 Collection的子接口：ListList接口中存储数据的特点：用于存储有序的、可以重复的数据。—&gt; 使用List替代数组，”动态”数组 常用方法 1234567891011121314151617181920小结： 增 add(Object obj) addAll(Collection coll) 删 remove(Object obj) remove(int index) 改 set(int index, Object ele) 查 get(int index) 插 add(int index, Object ele) addAll(int index, Collection eles) 长度 size() 遍历 iterator() ：使用迭代器进行遍历 增强for循环 一般的for循环 123456789List及其实现类特点java.util.Collection:存储一个一个的数据 |-----子接口：List:存储有序的、可重复的数据 (&quot;动态&quot;数组) |---- ArrayList:List的主要实现类；线程不安全的、效率高；底层使用Object[]数组存储 在添加数据、查找数据时，效率较高；在插入、删除数据时，效率较低 |---- LinkedList:底层使用双向链表的方式进行存储；在对集合中的数据进行频繁的删除、插入操作时，建议 使用此类在插入、删除数据时，效率较高；在添加数据、查找数据时，效率较低； |---- Vector:List的古老实现类；线程安全的、效率低；底层使用Object[]数组存储[面试题] ArrayList、Vector的区别？ ArrayList、LinkedList的区别？ Collection的子接口：Set Set中的常用的方法都是Collection中声明的方法，没有新增的方法 常见的实现类的对比 123456java.util.Collection:存储一个一个的数据 |-----子接口：Set:存储无序的、不可重复的数据(高中学习的集合) |---- HashSet：主要实现类；底层使用的是HashMap，即使用数组+单向链表+红黑树结构进行存储。（jdk8中） |---- LinkedHashSet：是HashSet的子类；在现有的数组+单向链表+红黑树结构的基础上，又添加了 一组双向链表，用于记录添加元素的先后顺序。即：我们可以按照添加元素的顺 序实现遍历。便于频繁的查询操作。 |---- TreeSet：底层使用红黑树存储。可以按照添加的元素的指定的属性的大小顺序进行遍历。 开发中的使用频率及场景： 较List、Map来说，Set使用的频率比较少。用来过滤重复数据 难点： Set中无序性、不可重复性的理解（以HashSet及其子类为例说明） 12345678&gt;无序性： != 随机性。 添加元素的顺序和遍历元素的顺序不一致,是不是就是无序性呢？ No! 到底什么是无序性？与添加的元素的位置有关，不像ArrayList一样是依次紧密排列的。 这里是根据添加的元素的哈希值，计算的其在数组中的存储位置。此位置不是依次排列的，表现为无序性。&gt;不可重复性：添加到Set中的元素是不能相同的。 比较的标准，需要判断hashCode()得到的哈希值以及equals()得到的boolean型的结果。 哈希值相同且equals()返回true，则认为元素是相同的。 123添加到HashSet/LinkedHashSet中元素的要求:&gt;要求元素所在的类要重写两个方法：equals() 和 hashCode()。&gt;同时，要求equals() 和 hashCode()要保持一致性！我们只需要在IDEA中自动生成两个方法的重写即可，即能保证两个方法的一致性。 TreeSet的使用 底层的数据结构：红黑树 添加数据后的特点：可以按照添加的元素的指定的属性的大小顺序进行遍历。 向TreeSet中添加的元素的要求： 要求添加到TreeSet中的元素必须是同一个类型的对象，否则会ClassCastException.添加的元素需要考虑排序：① 自然排序 ② 定制排序 判断数据是否相同的标准 不再是考虑hashCode()和equals()方法了，也就意味着添加到TreeSet中的元素所在的类不需要重写hashCode()和equals()方法了比较元素大小的或比较元素是否相等的标准就是考虑自然排序或定制排序中，compareTo()或compare()的返回值。如果compareTo()或compare()的返回值为0，则认为两个对象是相等的。由于TreeSet中不能存放相同的元素，则后一个相等的元素就不能添加到TreeSet中。 Map接口 常用的方法 12345678910111213141516增： put(Object key,Object value) putAll(Map m)删： Object remove(Object key)改： put(Object key,Object value) putAll(Map m)查： Object get(Object key)长度： size()遍历： 遍历key集：Set keySet() 遍历value集：Collection values() 遍历entry集：Set entrySet() 常用的实现类 123456789java.util.Map:存储一对一对的数据(key-value键值对，(x1,y1)、(x2,y2) --&gt; y=f(x),类似于高中的函数) |---- HashMap:主要实现类;线程不安全的，效率高;可以添加null的key和value值;底层使用数组+单向链表+红黑树结构存储（jdk8） |---- LinkedHashMap:是HashMap的子类；在HashMap使用的数据结构的基础上，增加了一对双向链表，用于记录添加的元素的先后顺序，进而我们在遍历元素时，就可以按照添加的顺序显示。开发中，对于频繁的遍历操作，建议使用此类。 |---- TreeMap:底层使用红黑树存储;可以按照添加的key-value中的key元素的指定的属性的大小顺序进行遍历。需要考虑使用①自然排序 ②定制排序。 |---- Hashtable:古老实现类;线程安全的，效率低;不可以添加null的key或value值;底层使用数组+单向链表结构存储（jdk8） |---- Properties:其key和value都是String类型。常用来处理属性文件。[面试题] 区别HashMap和Hashtable、区别HashMap和LinkedHashMap、HashMap的底层实现（① new HashMap() ② put(key,value)） 12345HashMap中元素的特点:&gt; HashMap中的所有的key彼此之间是不可重复的、无序的。所有的key就构成一个Set集合。---&gt;key所在的类要重写hashCode()和equals()&gt; HashMap中的所有的value彼此之间是可重复的、无序的。所有的value就构成一个Collection集合。---&gt;value所在的类要重写equals()&gt; HashMap中的一个key-value,就构成了一个entry。&gt; HashMap中的所有的entry彼此之间是不可重复的、无序的。所有的entry就构成了一个Set集合。 （了解）TreeMap的使用 底层使用红黑树存储;可以按照添加的key-value中的key元素的指定的属性的大小顺序进行遍历。需要考虑使用①自然排序 ②定制排序。要求:向TreeMap中添加的key必须是同一个类型的对象。 （重要）Properties的使用Properties:是Hashtable的子类，其key和value都是String类型的，常用来处理属性文件。 123456789101112131415161718192021222324252627282930public class PropertiesTest &#123; @Test public void test() throws IOException &#123; //注意：因为设计到流的操作，为了确保流能关闭，建议使用try-catch-finally //方式1：数据和代码耦合度高；如果修改的话，需要重写的编译代码、打包发布，繁琐 //数据// String name = &quot;Tom&quot;;// String password = &quot;abc123&quot;; //代码：用于操作name,password //... //方式2：将数据封装到具体的配置文件中，在程序中读取配置文件中的信息。实现了 //数据和代码的解耦；由于我们没有修改代码，就省去了重新编译和打包的过程。 File file = new File(&quot;info.properties&quot;); //注意，要提前创建好// System.out.println(file.getAbsolutePath()); FileInputStream fis = new FileInputStream(file); Properties pros = new Properties(); pros.load(fis); //加载流中的文件中的数据 //读取数据 String name = pros.getProperty(&quot;name&quot;); String pwd = pros.getProperty(&quot;password&quot;); System.out.println(name + &quot;:&quot; + pwd); fis.close(); &#125;&#125; Collections工具类的使用123区分Collection 和 CollectionsCollection：集合框架中的用于存储一个一个元素的接口，又分为List和Set等子接口。Collections：用于操作集合框架的一个工具类。此时的集合框架包括：Set、List、Map Collections中的常用方法 1234567891011121314151617181920212223242526排序操作：- reverse(List)：反转 List 中元素的顺序- shuffle(List)：对 List 集合元素进行随机排序- sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序- sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序- swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换查找- Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素- Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素- Object min(Collection)：根据元素的自然顺序，返回给定集合中的最小元素- Object min(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最小元素- int binarySearch(List list,T key)在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象，而且必须是可比较大小的，即支持自然排序的。而且集合也事先必须是有序的，否则结果不确定。- int binarySearch(List list,T key,Comparator c)在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象，而且集合也事先必须是按照c比较器规则进行排序过的，否则结果不确定。- int frequency(Collection c，Object o)：返回指定集合中指定元素的出现次数复制、替换- void copy(List dest,List src)：将src中的内容复制到dest中- boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值- 提供了多个unmodifiableXxx()方法，该方法返回指定 Xxx的不可修改的视图。添加- boolean addAll(Collection c,T... elements)将所有指定元素添加到指定 collection 中。同步- Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题 企业真题（十二）2.1 集合概述1. List，Set，Map是否继承自collection接口？（北京中*译咨询、思*贸易）Map不是。 2. 说说List,Set,Map三者的区别(民*银行)12类似问题：&gt; Map与Set、List的区别（纬*） 略 3. 写出list、map、set接口的实现类，并说出其特点（华**为）123类似问题：&gt; 集合有哪些， 各自有哪些特点， 各自的API有哪些？（湖**利软件）&gt; List Map Set三个接口在存储元素时个有什么特点（*软） 略 4. 常见集合类的区别和适用场景（饿**）略 5. 集合的父类是谁？哪些安全的？（北京中**信）略。 不安全：ArrayList、HashMap、HashSet ； 安全：Vector、Hashtable 6. 集合说一下哪些是线程不安全的（*科软）略 7. 遍历集合的方式有哪些？（恒*电子） 迭代器Iterator用来遍历Collection，不能用来遍历Map！ 增强for 一般的for：可以用来遍历List 2.2 List接口1. List下面有哪些实现（软**力）略 2. ArrayList与LinkedList区别？(O**O、滴*、汇*天下、拓*软件、博纳**软件、上海*进天下，北京永生**信息、*联、在*途游)12类似问题：&gt; ArrayList跟LinkedList的区别详细说出？（阿*校招、*东） 略。 补充上第14章中的源码（底层的数据结构） 3. ArrayList与Vector区别呢？为什么要用ArrayList取代Vector呢？(湖**利软件)Vector效率低。 4. Java.util.ArrayList常用的方法有哪些？（华**为）略 5. Arraylist 是有序还是无序？为什么？（蜜*信息）有序；底层使用数组：Object[] 2.3 Set接口1. Set集合有哪些实现类，分别有什么特点？（拓*软件）12类似问题：&gt; Set的实现类有哪些？（博*科技） 略 2. List集合和Set集合的区别？（亚*科技、*海*翼科技，*华电*系统，达*贷）略 3. Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用&#x3D;&#x3D;还是equals()? 它们有何区别?（鸿*网络）123类似问题：&gt; 1.HashSet如何检查重复(创*科技)&gt; 3.Set使用哪个区分不能重复的元素的？（北京创**荣信息） hashCode() 、 equals() 4. TreeSet两种排序方式在使用的时候怎么起作用？（拓*软件）在添加新的元素时，需要调用compareTo() 或 compare() 5. TreeSet的数据结构（*米）红黑树 2.4 Map接口1. 说一下Java的集合Map有哪些Map？（奥*医药）略 2. final怎么用，修饰Map可以继续添加数据吗？（*深蓝）final HashMap map &#x3D; new HashMap(); map.put(“AA”,123); 可以！ 3. Set和Map的比较（亚*科技）HashSet底层就是HashMap LinkedHashSet底层就是LinkedHashMap TreeSet底层就是TreeMap 4. HashMap说一下，线程安全吗？（*米）123类似问题：&gt; HashMap为什么线程不安全？（微*银行）&gt; HashMap是线程安全的吗？为什么不安全？（*团、*东、顺*） 不安全 5. HashMap和Hashbable的区别？(银*数据、阿**巴芝麻信用、*众银行、爱*信、杭州*智公司)12类似问题：&gt; HashMap 和 HashTable 有什么区别，以及如何使用，以及他的一些方法？（阿*校招、*东、*度校招、顺*） 略 6. Hashtable是怎么实现的，为什么线程安全？（迪*创新）数组+单向链表；底层方法使用synchronized修饰 7. HashMap和LinkedHashMap的区别（北京*晨阳光）略。 8. HashMap 和 TreeMap 的区别（*度，太极**、*线途游、阿*校招）底层的数据结构截然不同。 9. HashMap里面实际装的是什么？（惠*）JDK7：HashMap内部声明了Entry，实现了Map中的Entry接口。（key，value作为Entry的两个属性出现） JDK8：HashMap内部声明了Node，实现了Map中的Entry接口。（key，value作为Node的两个属性出现） 10. HashMap的key存储在哪里？和value存储在一起吗？那么value存储在哪里？说具体点？（湖**利软件、天*伟业）数组+链表+红黑树。 key、value作为Node的属性出现 11. 自定义类型可以作为Key么？（阿*）可以！ 要重写hashCode() 和equals() Collections1. 集合类的工具类是谁？用过工具类哪些方法？（顺*）Collections。略 2. Collection 和 Collections的区别？（平*金服、*软）略 3. ArrayList 如何实现排序（阿*）Collections.sort(list) 或 Collections.sort(list,comparator) 4. HashMap是否线程安全，怎样解决HashMap的线程不安全（中*卫星）12类似问题：&gt; 怎么实现HashMap线程安全？（*团、*东、顺*） 略 泛型泛型的理解 ，泛型参数，使用引用数据类型来赋值。 泛型在集合、比较器中的使用（重点） 在集合中使用泛型之前可能存在的问题问题1：类型不安全。因为add()的参数是Object类型，意味着任何类型的对象都可以添加成功问题2：需要使用强转操作，繁琐。还有可能导致ClassCastException异常。 集合：ArrayList、HashMap、Iterator 比较器：Comparable、Comparator 自定义泛型类&#x2F;泛型接口、泛型方法（熟悉） class Order{ } public 返回值类型 方法名(形参列表){} 具体的细节，见IDEA中的笔记。 泛型在继承上的体现123456781. 类SuperA是类A的父类，则G&lt;SuperA&gt; 与 G&lt;A&gt;的关系：G&lt;SuperA&gt; 和 G&lt;A&gt;是并列的两个类，没有任何子父类的关系。比如：ArrayList&lt;Object&gt; 、ArrayList&lt;String&gt;没有关系2. 类SuperA是类A的父类或接口，SuperA&lt;G&gt; 与 A&lt;G&gt;的关系：SuperA&lt;G&gt; 与A&lt;G&gt; 有继承或实现的关系。即A&lt;G&gt;的实例可以赋值给SuperA&lt;G&gt;类型的引用（或变量）比如：List&lt;String&gt; 与 ArrayList&lt;String&gt; 通配符的使用 ? 的使用 （重点） 以集合为例：可以读取数据、不能写入数据（例外：null） ? extends A 以集合为例：可以读取数据、不能写入数据（例外：null） ? super A 以集合为例：可以读取数据、可以写入A类型或A类型子类的数据（例外：null） 企业真题（十三）1. Java 的泛型是什么？有什么好处和优点？JDK 不同版本的泛型有什么区别？（软*动力）泛型，是程序中出现的不确定的类型。 以集合来举例：把一个集合中的内容限制为一个特定的数据类型，这就是generic背后的核心思想。 jdk7.0新特性： 1ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //类型推断 后续版本的新特性： 1Comparator&lt;Employee&gt; comparator = new Comparator&lt;&gt;()&#123;&#125; //类型推断 2. 说说你对泛型的了解（*软国际）略 数据结构与集合源码数据结构 概念：数据结构，就是一种程序设计优化的方法论，研究数据的逻辑结构和物理结构以及它们之间相互关系，并对这种结构定义相应的运算，目的是加快程序的执行速度、减少内存占用的空间。 数据结构的研究对象： ① 数据间的逻辑关系（集合关系、一对一、一对多、多对多） ② 数据的存储结构（或物理结构） 角度一：顺序结构、链式结构、索引结构、哈希结构 角度二：线性表（一维数组、链表、栈、队列）、树（二叉树、B+树）、图（多对多）、哈希表（HashMap、HashSet） ③ 相关运算 链表 逻辑结构：线性结构 物理结构：不要求连续的存储空间 存储特点：链表由一系列结点node（链表中每一个元素称为结点）组成，结点可以在代码执行过程中动态创建。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 常见的链表结构有如下的形式： 栈 栈（Stack）又称为堆栈或堆叠，是限制仅在表的一端进行插入和删除运算的线性表。 栈按照先进后出(FILO,first in last out)的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶。每次删除（退栈）的总是删除当前栈中最后插入（进栈）的元素，而最先插入的是被放在栈的底部，要到最后才能删除。 核心类库中的栈结构有Stack和LinkedList。 Stack就是顺序栈，它是Vector的子类。 LinkedList是链式栈。 体现栈结构的操作方法： peek()方法：查看栈顶元素，不弹出 pop()方法：弹出栈 push(E e)方法：压入栈 时间复杂度: 索引: O(n) 搜索: O(n) 插入: O(1) 移除: O(1) 图示： 队列 队列（Queue）是只允许在一端进行插入，而在另一端进行删除的运算受限的线性表。 队列是逻辑结构，其物理结构可以是数组，也可以是链表。 队列的修改原则：队列的修改是依先进先出（FIFO）的原则进行的。新来的成员总是加入队尾（即不允许”加塞”），每次离开的成员总是队列头上的（不允许中途离队），即当前”最老的”成员离队。 图示： 树与二叉树 树的理解 专有名词解释： 结点：树中的数据元素都称之为结点 根节点：最上面的结点称之为根，一颗树只有一个根且由根发展而来，从另外一个角度来说，每个结点都可以认为是其子树的根 父节点：结点的上层结点，如图中，结点K的父节点是E、结点L的父节点是G 子节点：节点的下层结点，如图中，节点E的子节点是K节点、节点G的子节点是L节点 兄弟节点：具有相同父节点的结点称为兄弟节点，图中F、G、H互为兄弟节点 结点的度数：每个结点所拥有的子树的个数称之为结点的度，如结点B的度为3 树叶：度数为0的结点，也叫作终端结点，图中D、K、F、L、H、I、J都是树叶 非终端节点（或分支节点）：树叶以外的节点，或度数不为0的节点。图中根、A、B、C、E、G都是 树的深度（或高度）：树中结点的最大层次数，图中树的深度为4 结点的层数：从根节点到树中某结点所经路径上的分支树称为该结点的层数，根节点的层数规定为1，其余结点的层数等于其父亲结点的层数+1 同代：在同一棵树中具有相同层数的节点 二叉树的基本概念 二叉树（Binary tree）是树形结构的一个重要类型。二叉树特点是每个结点最多只能有两棵子树，且有左右之分。许多实际问题抽象出来的数据结构往往是二叉树形式，二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。 二叉树的遍历 前序遍历：中左右（根左右） 即先访问根结点，再前序遍历左子树，最后再前序遍历右子 树。前序遍历运算访问二叉树各结点是以根、左、右的顺序进行访问的。 中序遍历：左中右（左根右） 即先中前序遍历左子树，然后再访问根结点，最后再中序遍 历右子树。中序遍历运算访问二叉树各结点是以左、根、右的顺序进行访问的。 后序遍历：左右中（左右根） 即先后序遍历左子树，然后再后序遍历右子树，最后访问根 结点。后序遍历运算访问二叉树各结点是以左、右、根的顺序进行访问的。 前序遍历：ABDHIECFG 中序遍历：HDIBEAFCG 后序遍历：HIDEBFGCA 经典二叉树 1、满二叉树： 除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树。 第n层的结点数是2的n-1次方，总的结点个数是2的n次方-1 2、完全二叉树： 叶结点只能出现在最底层的两层，且最底层叶结点均处于次底层叶结点的左侧。 3、二叉排序/查找/搜索树：即为BST (binary search&#x2F;sort tree)。满足如下性质：（1）若它的左子树不为空，则左子树上所有结点的值均小于它的根节点的值；（2）若它的右子树上所有结点的值均大于它的根节点的值；（3）它的左、右子树也分别为二叉排序&#x2F;查找&#x2F;搜索树。 对二叉查找树进行中序遍历，得到有序集合。便于检索。 4、平衡二叉树：（Self-balancing binary search tree，AVL）首先是二叉排序树，此外具有以下性质：（1）它是一棵空树或它的左右两个子树的高度差的绝对值不超过1（2）并且左右两个子树也都是一棵平衡二叉树（3）不要求非叶节点都有两个子结点 平衡二叉树的目的是为了减少二叉查找树的层次，提高查找速度。平衡二叉树的常用实现有红黑树、AVL、替罪羊树、Treap、伸展树等。 5、红黑树：即Red-Black Tree。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。 红黑树是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，它是在 1972 年由 Rudolf Bayer 发明的。红黑树是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的：它可以在 O(log n)时间内做查找，插入和删除， 这里的 n 是树中元素的数目。 红黑树的特性： 每个节点是红色或者黑色 根节点是黑色 每个叶子节点（NIL）是黑色。（注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点） 每个红色节点的两个子节点都是黑色的。(从每个叶子到根的所有路径上不能有两个连续的红色节点) 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点（确保没有一条路径会比其他路径长出2倍） 当我们插入或删除节点时，可能会破坏已有的红黑树，使得它不满足以上5个要求，那么此时就需要进行处理，使得它继续满足以上的5个要求： 1、recolor ：将某个节点变红或变黑 2、rotation ：将红黑树某些结点分支进行旋转（左旋或右旋） 红黑树可以通过红色节点和黑色节点尽可能的保证二叉树的平衡。主要是用它来存储有序的数据，它的时间复杂度是O(logN)，效率非常之高。 List接口下的实现类的源码剖析【面试题】ArrayList、Vector、LinkedList的三者的对比？ 层次1： 12345|-----子接口：List:存储有序的、可重复的数据 (&quot;动态&quot;数组) |---- ArrayList:List的主要实现类；线程不安全的、效率高；底层使用Object[]数组存储 在添加数据、查找数据时，效率较高；在插入、删除数据时，效率较低 |---- LinkedList:底层使用双向链表的方式进行存储；在对集合中的数据进行频繁的删除、插入操作时，建议使用此 类在插入、删除数据时，效率较高；在添加数据、查找数据时，效率较低； |---- Vector:List的古老实现类；线程安全的、效率低；底层使用Object[]数组存储 层次2：查看相关api的源码 ArrayList源码解析1234567891011121314151617181920212223241. jdk7版本：(以jdk1.7.0_07为例)//如下代码的执行：底层会初始化数组，数组的长度为10。Object[] elementData = new Object[10];ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;AA&quot;); //elementData[0] = &quot;AA&quot;;list.add(&quot;BB&quot;);//elementData[1] = &quot;BB&quot;;...当要添加第11个元素的时候，底层的elementData数组已满，则需要扩容。默认扩容为原来长度的1.5倍。并将原有数组中的元素复制到新的数组中。2. jdk8版本:(以jdk1.8.0_271为例)//如下代码的执行：底层会初始化数组，即：Object[] elementData = new Object[]&#123;&#125;;ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;AA&quot;); //首次添加元素时，会初始化数组elementData = new Object[10];elementData[0] = &quot;AA&quot;;list.add(&quot;BB&quot;);//elementData[1] = &quot;BB&quot;;...当要添加第11个元素的时候，底层的elementData数组已满，则需要扩容。默认扩容为原来长度的1.5倍。并将原有数组中的元素复制到新的数组中。小结：jdk1.7.0_07版本中：ArrayList类似于饿汉式jdk1.8.0_271版本中：ArrayList类似于懒汉式 Vector源码解析1234567Vector源码解析：(以jdk1.8.0_271为例)Vector v = new Vector(); //底层初始化数组，长度为10.Object[] elementData = new Object[10];v.add(&quot;AA&quot;); //elementData[0] = &quot;AA&quot;;v.add(&quot;BB&quot;);//elementData[1] = &quot;BB&quot;;...当添加第11个元素时，需要扩容。默认扩容为原来的2倍。 LinkedList源码解析12345678910111213141516LinkedList在jdk8中的源码解析：LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;(); //底层也没做啥list.add(&quot;AA&quot;); //将&quot;AA&quot;封装到一个Node对象1中，list对象的属性first、last都指向此Node对象1。list.add(&quot;BB&quot;); //将&quot;BB&quot;封装到一个Node对象2中，对象1和对象2构成一个双向链表，同时last指向此Node对象2...因为LinkedList使用的是双向链表，不需要考虑扩容问题。LinkedList内部声明：private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev;&#125; 启示与开发建议 Vector基本不使用了。 ArrayList底层使用数组结构，查找和添加（尾部添加）操作效率高，时间复杂度为O(1);删除和插入操作效率低，时间复杂度为O(n)LinkedList底层使用双向链表结构，删除和插入操作效率高，时间复杂度为O(1);查找和添加（尾部添加）操作效率高，时间复杂度为O(n) (有可能添加操作是O(1)) 在选择了ArrayList的前提下，new ArrayList() : 底层创建长度为10的数组。new ArrayList(int capacity):底层创建指定capacity长度的数组。如果开发中，大体确认数组的长度，则推荐使用ArrayList(int capacity)这个构造器，避免了底层的扩容、复制数组的操作。 Map接口下的实现类的源码剖析HashMap源码解析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758591. jdk7中创建对象和添加数据过程(以JDK1.7.0_07为例说明)：//创建对象的过程中，底层会初始化数组Entry[] table = new Entry[16];HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;();...map.put(&quot;AA&quot;,78); //&quot;AA&quot;和78封装到一个Entry对象中，考虑将此对象添加到table数组中。...添加/修改的过程：将(key1,value1)添加到当前的map中：首先，需要调用key1所在类的hashCode()方法，计算key1对应的哈希值1，此哈希值1经过某种算法(hash())之后，得到哈希值2。哈希值2再经过某种算法(indexFor())之后，就确定了(key1,value1)在数组table中的索引位置i。 1.1 如果此索引位置i的数组上没有元素，则(key1,value1)添加成功。 ----&gt;情况1 1.2 如果此索引位置i的数组上有元素(key2,value2),则需要继续比较key1和key2的哈希值2 ---&gt;哈希冲突 2.1 如果key1的哈希值2与key2的哈希值2不相同，则(key1,value1)添加成功。 ----&gt;情况2 2.2 如果key1的哈希值2与key2的哈希值2相同，则需要继续比较key1和key2的equals()。要调用key1所在类的equals(),将key2作为参数传递进去。 3.1 调用equals()，返回false: 则(key1,value1)添加成功。 ----&gt;情况3 3.2 调用equals()，返回true: 则认为key1和key2是相同的。默认情况下，value1替换原有的value2。说明：情况1：将(key1,value1)存放到数组的索引i的位置 情况2,情况3：(key1,value1)元素与现有的(key2,value2)构成单向链表结构，(key1,value1)指向(key2,value2)随着不断的添加元素，在满足如下的条件的情况下，会考虑扩容：(size &gt;= threshold) &amp;&amp; (null != table[i])当元素的个数达到临界值(-&gt; 数组的长度 * 加载因子)时，就考虑扩容。默认的临界值 = 16 * 0.75 --&gt; 12.默认扩容为原来的2倍。2. jdk8与jdk7的不同之处(以jdk1.8.0_271为例)：① 在jdk8中，当我们创建了HashMap实例以后，底层并没有初始化table数组。当首次添加(key,value)时，进行判断，如果发现table尚未初始化，则对数组进行初始化。② 在jdk8中，HashMap底层定义了Node内部类，替换jdk7中的Entry内部类。意味着，我们创建的数组是Node[]③ 在jdk8中，如果当前的(key,value)经过一系列判断之后，可以添加到当前的数组角标i中。如果此时角标i位置上有 元素。在jdk7中是将新的(key,value)指向已有的旧的元素（头插法），而在jdk8中是旧的元素指向新的 (key,value)元素（尾插法）。 &quot;七上八下&quot;④ jdk7:数组+单向链表 jk8:数组+单向链表 + 红黑树 什么时候会使用单向链表变为红黑树：如果数组索引i位置上的元素的个数达到8，并且数组的长度达到64时，我们就将此索引i位置上 的多个元素改为使用红黑树的结构进行存储。（为什么修改呢？红黑树进行put()/get()/remove() 操作的时间复杂度为O(logn)，比单向链表的时间复杂度O(n)的好。性能更高。 什么时候会使用红黑树变为单向链表：当使用红黑树的索引i位置上的元素的个数低于6的时候，就会将红黑树结构退化为单向链表。3. 属性/字段：static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // 默认的初始容量 16static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; //最大容量 1 &lt;&lt; 30static final float DEFAULT_LOAD_FACTOR = 0.75f; //默认加载因子static final int TREEIFY_THRESHOLD = 8; //默认树化阈值8，当链表的长度达到这个值后，要考虑树化static final int UNTREEIFY_THRESHOLD = 6;//默认反树化阈值6，当树中结点的个数达到此阈值后，要考虑变为链表//当单个的链表的结点个数达到8，并且table的长度达到64，才会树化。//当单个的链表的结点个数达到8，但是table的长度未达到64，会先扩容static final int MIN_TREEIFY_CAPACITY = 64; //最小树化容量64transient Node&lt;K,V&gt;[] table; //数组transient int size; //记录有效映射关系的对数，也是Entry对象的个数int threshold; //阈值，当size达到阈值时，考虑扩容final float loadFactor; //加载因子，影响扩容的频率 LinkedHashMap12345678910111213141516171819201. LinkedHashMap 与 HashMap 的关系:&gt; LinkedHashMap 是 HashMap的子类。&gt; LinkedHashMap在HashMap使用的数组+单向链表+红黑树的基础上，又增加了一对双向链表，记录添加的(key,value)的先后顺序。便于我们遍历所有的key-value。LinkedHashMap重写了HashMap的如下方法：Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e); linkNodeLast(p); return p;&#125;2. 底层结构：LinkedHashMap内部定义了一个Entrystatic class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; //增加的一对双向链表 Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125;&#125; HashSet和LinkedHashSet的源码分析 HashSet底层使用的是HashMapLinkedHashSet底层使用的是LinkedHashMap 企业真题（十四）数据结构相关1. 链表和数组有什么区别？（腾*）略 2. 栈是如何运行的？(西*信息技术)先进后出。属于ADT(abstract data type)，可以使用数组、链表实现栈结构 List集合源码相关1. ArrayList的默认大小是多少，以及扩容机制（顺*、凡*科技）1234类似问题：&gt; 说说ArrayList的扩容机制吧(国*电网)&gt; 讲一下ArrayList的扩容机制（*实在）&gt; ArrayList的扩容机制，为什么是10，为什么是1.5倍（*软国际） 略 2. ArrayList的底层是怎么实现的?（腾*）123类似问题：集合类的ArrayList底层（安全不安全，扩容，初始大小，添加删除查询是怎么操作的，底层是什么组成的）（湖**利软件、汇*云通、猎*、苏州***动、上海*进天下、北京博*软件、*科软、大连*点科技、中*亿达、德*物流、天*伟业、猫*娱乐） 略。 建议：ArrayList(int capacity){} 3. 在ArrayList中remove后面几个元素该怎么做?（惠*、中*亿达）前移。 4. ArrayList1.7和1.8的区别（拓*思）类似于饿汉式、懒汉式 5. 数组和 ArrayList 的区别（阿*、*科软） ArrayList看做是对数组的常见操作的封装。 6. 什么是线程安全的List？(平*金服)Vector：线程安全的。 ArrayList：线程不安全。—-&gt; 使用同步机制处理。 12HashMap:线程不安全。 ----&gt; 使用同步机制处理。 -----&gt; JUC:ConcurrentHashMap HashMap集合源码相关1. 说说HahMap底层实现(新*股份、顺*、猫*娱乐)123456789101112类似问题：&gt; HashMap的实现讲一下？（腾*，上海**网络）&gt; 说说HashMap的底层执行原理？（滴*，纬*软件，上海*想，*昂，*蝶**云，宇*科技，*东数科，猎*网）&gt; 详细说一下 HashMap 的 put 过程（*度）&gt; Java中的HashMap的工作原理是什么？（北京中**译咨询）&gt; 集合类的HashMap底层（安全不安全，扩容，初始大小，添加删除查询是怎么操作的，底层是什么组成的）（湖**利软件）&gt; HashMap 的存储过程（爱*信、杭州*智）&gt; Hashmap底层实现及构造（汇**通、猎*、苏州博*讯动、上海*进天下、北京博*软件、*科软、大连*点科技、中*亿达、德*物流、天*伟业、猫*娱乐）&gt; HashMap的实现原理（腾*、阿*）&gt; HaspMap底层讲一讲（*米）&gt; 说一下HashMap的实现，扩容机制？（*节）&gt; 讲一下 HashMap 中 put 方法过程？（阿*） 略。建议以JDK8为主说明。 2. HashMap初始值16，临界值12是怎么算的（软**力）16从底层源码的构造器中看到的。 12：threshold，使用数组的长度*加载因子(loadFactor) 3. HashMap长度为什么是2的幂次方(国*时代)为了方便计算要添加的元素的底层的索引i。 4. HashMap怎么计算哈希值和索引？扩容机制？怎么解决hash冲突？（*软国际、中软*腾）1234类似问题：&gt; HashMap key的哈希冲突了怎么做（新*股份）&gt; HashMap的默认大小是多少，以及扩容机制（顺*、凡*科技）&gt; 讲一下HashMap的扩容机制？（好实*） 略 5. HashMap底层是数组+链表，有数组很快了，为什么加链表？（润*软件）因为产生了哈希冲突。解决方案，使用链表的方式。保证要添加的元素仍然在索引i的位置上。 6. HashMap为什么长度达到一定的长度要转化为红黑树（*度）12类似问题：&gt; HashMap为什么用红黑树（*软国际） 红黑树的常用操作的时间复杂度O(logn)，比单向链表的O(n)效率高。 7. HashMap什么时候扩充为红黑树，什么时候又返回到链表？（汉*）1234类似问题：&gt; HashMap什么时候转换为红黑树（杭州*智公司）&gt; 当HashMap中相同hashcode值的数据超过多少时会转变成红黑树？（百*云创）&gt; 什么时候是数据+链表，什么时候是红黑树（*软国际） 索引i的位置的链表长度超过8且数组长度达到64，需要索引i位置要变成红黑树。 当索引i的位置元素的个数低于6时，要红黑树结构转为单向链表。为什么？节省空间。 8. 在 JDK1.8中，HashMap的数据结构与1.7相比有什么变化，这些变化的好处在哪里？（海*科）123456789101112① 在jdk8中，当我们创建了HashMap实例以后，底层并没有初始化table数组。当首次添加(key,value)时，进行判断，如果发现table尚未初始化，则对数组进行初始化。② 在jdk8中，HashMap底层定义了Node内部类，替换jdk7中的Entry内部类。意味着，我们创建的数组是Node[]③ 在jdk8中，如果当前的(key,value)经过一系列判断之后，可以添加到当前的数组角标i中。如果此时角标i位置上有 元素。在jdk7中是将新的(key,value)指向已有的旧的元素（头插法），而在jdk8中是旧的元素指向新的 (key,value)元素（尾插法）。 &quot;七上八下&quot;④ jdk7:数组+单向链表 jk8:数组+单向链表 + 红黑树 什么时候会使用单向链表变为红黑树：如果数组索引i位置上的元素的个数达到8，并且数组的长度达到64时，我们就将此索引i位置上 的多个元素改为使用红黑树的结构进行存储。（为什么修改呢？红黑树进行put()/get()/remove() 操作的时间复杂度为O(logn)，比单向链表的时间复杂度O(n)的好。性能更高。 什么时候会使用红黑树变为单向链表：当使用红黑树的索引i位置上的元素的个数低于6的时候，就会将红黑树结构退化为单向链表。 9. HashMap的get()方法的原理?（顺*）参考put() hashCode和equals1. hashcode和equals区别？（海*供应链管理）略 2. hashCode() 与 equals() 生成算法、方法怎么重写？（阿*校招）进行equals()判断使用的属性，通常也都会参与到hashCode()的计算中。 尽量保证hashCode()的一致性。（使用IDEA自动生成，hashCode()自动使用相关的算法。 3. 说一下equals和&#x3D;&#x3D;的区别，然后问equals相等hash值一定相等吗？hash值相等equals一定相等吗？（南*电网、上海*智网络）equals相等hash值一定相等吗? 是 hash值相等equals一定相等吗？不一定 Set集合源码相关1. HashSet存放数据的方式？（拓*软件）底层使用HashMap。说一下HashMap 2. Set是如何实现元素的唯一性？（湖**利软件）略 3. 用哪两种方式来实现集合的排序（凡*科技）12类似问题：&gt; 集合怎么排序？（北京中**信科技） 自然排序、定制排序。 File类与IO流File类的使用 位于java.io包下 File类的一个实例对应着磁盘上的一个文件或文件目录。 —-&gt; “万事万物皆对象” （熟悉）File的实例化、常用的方法 123456789101112131415161718192021222324252627282930构造器 * public File(String pathname) ：以 pathname 为路径创建 File 对象，可以是绝对路径或者相对路径，如果 pathname 是相对路径，则默认的当前路径在系统属性user.dir 中存储。 * public File(String parent, String child) ：以 parent 为父路径，child 为子路径创建 File 对象。 * public File(File parent, String child) ：根据一个父 File 对象和子文件路径创建 File 对象。 获取文件和目录基本信息 * public String getName() ：获取名称 * public String getPath() ：获取路径 * public String getAbsolutePath()：获取绝对路径 * public File getAbsoluteFile()：获取绝对路径表示的文件 * public String getParent()：获取上层文件目录路径。若无，返回null * public long length() ：获取文件长度（即：字节数）。不能获取目录的长度。 * public long lastModified() ：获取最后一次的修改时间，毫秒值列出目录的下一级 * public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。 * public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。File类的重命名功能 * public boolean renameTo(File dest):把文件重命名为指定的文件路径。判断功能的方法 * public boolean exists() ：此File表示的文件或目录是否实际存在。 * public boolean isDirectory() ：此File表示的是否为目录。 * public boolean isFile() ：此File表示的是否为文件。 * public boolean canRead() ：判断是否可读 * public boolean canWrite() ：判断是否可写 * public boolean isHidden() ：判断是否隐藏创建、删除功能 * public boolean createNewFile() ：创建文件。若文件存在，则不创建，返回false。 * public boolean mkdir() ：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。 * public boolean mkdirs() ：创建文件目录。如果上层文件目录不存在，一并创建。 * public boolean delete() ：删除文件或者文件夹 删除注意事项：① Java中的删除不走回收站。② 要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录。 File类中声明了新建、删除、获取名称、重命名等方法，并没有涉及到文件内容的读写操作。要想实现文件内容的读写，我们就需要使用io流。 File类的对象，通常是作为io流操作的文件的端点出现的。代码层面，将File类的对象作为参数传递到IO流相关类的构造器中。 IO流的概述 IO流的分类 流向：输入流、输出流 处理数据单位：字节流、字符流 流的角色：节点流、处理流 IO的4个抽象基类：InputStream \\ OutputStream \\ Reader \\ Writer 节点流之一：文件流 FileInputStream \\ FileOutputStream \\ FileReader \\ FileWriter 执行步骤： 第1步：创建读取或写出的File类的对象 第2步：创建输入流或输出流 第3步：具体的读入或写出的过程。 读入：read(char[] cbuffer) 写出：write(String str) &#x2F; write(char[] cbuffer,0,len) 第4步：关闭流资源，避免内存泄漏 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 /* * 需求：复制一份hello.txt文件，命名为hello_copy.txt * */ @Test public void test5() &#123; FileReader fr = null; FileWriter fw = null; try &#123; //1. 创建File类的对象 File srcFile = new File(&quot;hello.txt&quot;); File destFile = new File(&quot;hello_copy.txt&quot;); //2. 创建输入流、输出流 fr = new FileReader(srcFile); fw = new FileWriter(destFile); //3. 数据的读入和写出的过程 char[] cbuffer = new char[5]; int len;//记录每次读入到cbuffer中的字符的个数 while ((len = fr.read(cbuffer)) != -1) &#123; //write(char[] cbuffer,int fromIndex,int len) fw.write(cbuffer, 0, len); //正确的// fw.write(cbuffer); //错误的 &#125; System.out.println(&quot;复制成功&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //4. 关闭流资源 //方式1：// try &#123; //if (fw != null)// fw.close();// &#125; catch (IOException e) &#123;// e.printStackTrace();// &#125;finally &#123;//// try &#123; //if (fr != null)// fr.close();// &#125; catch (IOException e) &#123;// e.printStackTrace();// &#125;// &#125; //方式2： try &#123; if (fw != null) fw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (fr != null) fr.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 注意点：① 因为涉及到流资源的关闭操作，所以出现异常的话，需要使用try-catch-finally的方式来处理异常② 对于输入流来讲，要求File类的对象对应的物理磁盘上的文件必须存在。否则，会报FileNotFoundException 对于输出流来讲，File类的对象对应的物理磁盘上的文件可以不存在。 &gt; 如果此文件不存在，则在输出的过程中，会自动创建此文件，并写出数据到此文件中。 &gt; 如果此文件存在，使用 FileWriter(File file) 或 FileWriter(File file,false): 输出数据过程中，会新建同名的文件对现有的文件进行覆盖。 FileWriter(File file,true) : 输出数据过程中，会在现有的文件的末尾追加写出内容。 处理流之一：缓冲流 BufferedInputStream \\ BufferedOutputStream \\ BufferedReader \\ BufferedWriter 作用：实现更高效的读写数据的操作 处理流之二：转换流 层次1：熟悉转换流的使用 InputStreamReader、OutputStreamWriter： InputStreamReader:将一个输入型的字节流转换为输入型的字符流。 OutputStreamWriter:将一个输出型的字符流转换为输出型的字节流。 层次2：（掌握）字符的编码和解码的过程、常用的字符集 解决相关的问题：读写字符出现乱码！本质问题：使用的解码集与编码集不一致。 处理流之三：对象流 层次1：熟悉对象流的使用 ObjectInputStream:反序列化时需要使用的api，将文件中的数据或网络传输过来的数据还原为内存中的Java对象 ObjectOutputStream:序列化时需要使用的api，将内存中的Java对象保存在文件中或通过网络传输出去 层次2：对象的序列化机制 对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。&#x2F;&#x2F;当其它程序获取了这种二进制流，就可以恢复成原来的Java对象。 自定义类要想实现序列化机制，需要满足：① 自定义类需要实现接口：Serializable② 要求自定义类声明一个全局常量： static final long serialVersionUID &#x3D; 42234234L;用来唯一的标识当前的类。③ 要求自定义类的各个属性也必须是可序列化的。 对于基本数据类型的属性：默认就是可以序列化的对于引用数据类型的属性：要求实现Serializable接口 其它流的使用 了解：数据流：DataInputStream 、DataOutputStream 了解：标准的输入流、标准的输出流：System.in 、System.out 了解：打印流：PrintStream、PrintWriter 企业真题（十五）IO流概述1. 谈谈Java IO里面的常用类，字节流，字符流(银*数据)略 2. Java 中有几种类型的流？JDK为每种类型的流提供一些抽象类以供继承，请说出他们分别是哪些类？（上海*厦*联网、极*科技）InputStream \\ OutputStream \\ Reader \\ Writer 3. 流一般需不需要关闭？如果关闭的话用什么方法？处理流是怎么关闭的？(银*数据)需要。close() 处理流在关闭过程中，也会关闭内部的流。 4. OutputStream里面的write()是什么意思?(君*科技)数据写出的意思。 缓冲流1. BufferedReader属于哪种流？他主要是用来做什么的？(国*电网)略 2. 什么是缓冲区？有什么作用？(北京中油**)内部提供了一个数组，将读取或要写出的数据，现在此数组中缓存。达到一定程度时，集中性的写出。 作用：减少与磁盘的交互，进而提升读写效率。 转换流1. 字节流和字符流是什么？怎么转换？(北京蓝*、*海*供应链管理） 序列化1. 什么是Java序列化，如何实现(君*科技、上海*厦物联网)12对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。//当其它程序获取了这种二进制流，就可以恢复成原来的Java对象。 2. Java有些类中为什么需要实现Serializable接口？（阿*校招）便于此类的对象实现序列化操作。 网络编程网络编程概述 计算机网络：把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模大、功能强的网络系统，从而使众多的计算机可以方便地互相传递信息、共享硬件、软件、数据信息等资源。 网络编程的目的：直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯。 需要解决的三个问题： 问题1：如何准确地定位网络上一台或多台主机 问题2：如何定位主机上的特定的应用 问题3：找到主机后，如何可靠、高效地进行数据传输 要素1：IP地址 使用具体的一个ip地址对应具体的一个互联网上的主机 IP分类： 角度一：IPv4(占用4个字节)、IPv6(占用16个字节) 角度二：公网地址、私网地址（或局域网,以192.168开头) 域名:便捷的记录ip地址 使用InetAddress类表示IP地址 实例化：getByName(String host) 、getLocalHost() 常用方法：getHostName() 、getHostAddress() 要素2：端口号 用于区分同一台主机上的不同的进程，可以唯一标识主机中的进程（应用程序） 不同的进程分配不同的端口号 范围：0-65535 要素3：网络通信协议为了实现可靠而高效的数据传输。 这里有两套参考模型 OSI参考模型：将网络分为7层，模型过于理想化，未能在因特网上进行广泛推广 TCP&#x2F;IP参考模型(或TCP&#x2F;IP协议)：将网络分为4层：应用层、传输层、网络层、物理+数据链路层，事实上的国际标准。 在传输层中涉及到两个协议：TCP、UDP。二者的对比 TCP：可靠的连接（发送数据前，需要三次握手、四次挥手），进行大数据量的传输，效率低。 UDP：不可靠的连接（发送前，不需要确认对方是否在）、使用数据报传输（限制在64kb以内）、效率高。 TCP的三次握手、四次挥手 TCP 协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。第一次握手，客户端向服务器端发起 TCP 连接的请求；第二次握手，服务器端发送针对客户端 TCP 连接请求的确认；第三次握手，客户端发送确认的确认。 TCP 协议中，在发送数据结束后，释放连接时需要经过四次挥手。第一次挥手：客户端向服务器端提出结束连接，让服务器做最后的准备工作。此时，客户端处于半关闭状态，即表示不再向服务器发送数据了，但是还可以接受数据；第二次挥手：服务器接收到客户端释放连接的请求后，会将最后的数据发给客户端。并告知上层的应用进程不再接收数据；第三次挥手：服务器发送完数据后，会给客户端发送一个释放连接的报文。那么客户端接收后就知道可以正式释放连接了；第四次挥手：客户端接收到服务器最后的释放连接报文后，要回复一个彻底断开的报文。这样服务器收到后才会彻底释放连接。这里客户端，发送完最后的报文后，会等待 2MSL，因为有可能服务器没有收到最后的报文，那么服务器迟迟没收到，就会再次给客户端发送释放连接的报文，此时客户端在等待时间范围内接收到，会重新发送最后的报文，并重新计时。如果等待 2MSL 后，没有收到，那么彻底断开。 TCP网络编程开发步骤： 客户端程序： 创建 Socket ：根据指定服务端的 IP 地址或端口号构造 Socket 类对象。若服务器端响应，则建立客户端到服务器的通信线路。若连接失败，会出现异常。 打开连接到 Socket 的输入&#x2F; 出流： 使用 getInputStream()方法获得输入流，使用getOutputStream()方法获得输出流，进行数据传输 按照一定的协议对 Socket 进行读&#x2F; 写操作：通过输入流读取服务器放入线路的信息（但不能读取自己放入线路的信息），通过输出流将信息写入线路。 关闭 Socket ：断开客户端到服务器的连接，释放线路 1234567891011121314151617181920212223242526272829303132333435//客户端 @Test public void client() &#123; Socket socket = null; OutputStream os = null; try &#123; //1. 创建一个Socket InetAddress inetAddress = InetAddress.getByName(&quot;192.168.21.107&quot;); //声明对方的ip地址 int port = 8989;//声明对方的端口号 socket = new Socket(inetAddress, port); //2. 发送数据 os = socket.getOutputStream(); os.write(&quot;你好，我是客户端，请多多关照&quot;.getBytes()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //3. 关闭socket、关闭流 try &#123; if (socket != null) socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (os != null) &#123; os.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 服务器端程序： 调用 ServerSocket(int port) ：创建一个服务器端套接字，并绑定到指定端口上。用于监听客户端的请求。 调用 accept() ：监听连接请求，如果客户端请求连接，则接受连接，返回通信套接字对象。 调用 该 Socket 类对象的 getOutputStream() 和 getInputStream () ：获取输出流和输入流，开始网络数据的发送和接收。 关闭 Socket 对象：客户端访问结束，关闭通信套接字。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//服务端 @Test public void server() &#123; ServerSocket serverSocket = null; Socket socket = null; //阻塞式的方法 InputStream is = null; try &#123; //1. 创建一个ServerSocket int port = 8989; serverSocket = new ServerSocket(port); //2. 调用accept()，接收客户端的Socket socket = serverSocket.accept(); System.out.println(&quot;服务器端已开启&quot;); System.out.println(&quot;收到了来自于&quot; + socket.getInetAddress().getHostAddress() + &quot;的连接&quot;); //3. 接收数据 is = socket.getInputStream(); byte[] buffer = new byte[5]; int len; ByteArrayOutputStream baos = new ByteArrayOutputStream(); //内部维护了一个byte[] while ((len = is.read(buffer)) != -1) &#123; //错误的，可能会出现乱码。// String str = new String(buffer, 0, len);// System.out.print(str); //正确的 baos.write(buffer,0,len); &#125; System.out.println(baos.toString()); System.out.println(&quot;\\n数据接收完毕&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //4. 关闭Socket、ServerSocket、流 try &#123; if (socket != null) &#123; socket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (serverSocket != null) &#123; serverSocket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (is != null) &#123; is.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 聊天室案例（与多线程结合） UDP网络编程开发步骤： 发送端程序： 创建 DatagramSocket ：默认使用系统随机分配端口号。 创建 DatagramPacket：将要发送的数据用字节数组表示，并指定要发送的数据长度，接收方的 IP 地址和端口号。 调用 该 DatagramSocket 类对象的 send 方法 ：发送数据报 DatagramPacket 对象。 关闭 DatagramSocket 对象：发送端程序结束，关闭通信套接字。 接收端程序： 创建 DatagramSocket ：指定监听的端口号。 创建 DatagramPacket：指定接收数据用的字节数组，起到临时数据缓冲区的效果，并指定最大可以接收的数据长度。 调用 该 DatagramSocket 类对象的 receive 方法 ：接收数据报 DatagramPacket 对象。 关闭 DatagramSocket ：接收端程序结束，关闭通信套接字。 URL编程 Java后台：将写好的Java程序部署在Tomcat服务器。启动Tomcat服务器。 前台：使用浏览器进行访问。需要使用url。（HTML+CSS+JavaScript） URL的作用：定位互联网上某一资源的地址。 URL的格式： 12http://192.168.21.107:8080/examples/abcd.jpg?name=Tom ---&gt; &quot;万事万物皆对象&quot;应用层协议 ip地址 端口号 资源地址 参数列表 使用URL实现数据的下载（了解） 企业真题（十六）1. TCP协议和UDP协议的区别（华**为）略 2. 简单说说TCP协议的三次握手与四次挥手机制 （*科软）略 反射机制反射的概述通过使用反射前后的例子的对比，回答： 面向对象中创建对象，调用指定结构（属性、方法）等功能，可以不使用反射，也可以使用反射。请问有什么区别？ 不使用反射，我们需要考虑封装性。比如：出了Person类之后，就不能调用Person类中私有的结构使用反射，我们可以调用运行时类中任意的构造器、属性、方法。包括了私有的属性、方法、构造器。 以前创建对象并调用方法的方式，与现在通过反射创建对象并调用方法的方式对比的话，哪种用的多？场景是什么？ 从我们作为程序员开发者的角度来讲，我们开发中主要是完成业务代码，对于相关的对象、方法的调用都是确定的。 所以，我们使用非反射的方式多一些。 因为反射体现了动态性（可以在运行时动态的获取对象所属的类，动态的调用相关的方法），所以我们在设计框架的时候， 会大量的使用反射。意味着，如果大家需要学习框架源码，那么就需要学习反射。 框架 &#x3D; 注解 + 反射 + 设计模式 单例模式的饿汉式和懒汉式中，私有化类的构造器了！ 此时通过反射，可以创建单例模式中类的多个对象吗？ 是的！ 通过反射，可以调用类中私有的结构，是否与面向对象的封装性有冲突？是不是Java语言设计存在Bug？ 不存在bug! 封装性：体现的是是否建议我们调用内部api的问题。比如，private声明的结构，意味着不建议调用。反射：体现的是我们能否调用的问题。因为类的完整结构都加载到了内存中，所有我们就有能力进行调用。 Java给我们提供了一套API，使用这套API我们可以在运行时动态的获取指定对象所属的类，创建运行时类的对象，调用指定的结构（属性、方法）等。 API： java.lang.Class：代表一个类 java.lang.reflect.Method：代表类的方法 java.lang.reflect.Field：代表类的成员变量 java.lang.reflect.Constructor：代表类的构造器 … … 反射的优点和缺点 优点： 提高了Java程序的灵活性和扩展性，降低了耦合性，提高自适应能力 允许程序创建和控制任何类的对象，无需提前硬编码目标类 缺点： 反射的性能较低。 反射机制主要应用在对灵活性和扩展性要求很高的系统框架上 反射会模糊程序内部逻辑，可读性较差。 反射，平时开发中，我们使用并不多。主要是在框架的底层使用。 Class:反射的源头 Class的理解 （掌握） 12针对于编写好的.java源文件进行编译(使用javac.exe)，会生成一个或多个.class字节码文件。接着，我们使用java.exe命令对指定的.class文件进行解释运行。这个解释运行的过程中，我们需要将.class字节码文件加载(使用类的加载器)到内存中(存放在方法区)。加载到内存中的.class文件对应的结构即为Class的一个实例。 获取Class的实例的几种方式（前三种） 类.class 对象.getClass() （使用较多）Class调用静态方法forName(String className) (了解)使用ClassLoader的方法loadClass(String className) 12345678910111213141516171819 //1.调用运行时类的静态属性：classClass clazz1 = User.class;//2. 调用运行时类的对象的getClass()User u1 = new User();Class clazz2 = u1.getClass();//3. 调用Class的静态方法forName(String className)String className = &quot;com.atguigu02._class.User&quot;; //全类名Class clazz3 = Class.forName(className);System.out.println(clazz1 == clazz2);//trueSystem.out.println(clazz1 == clazz3);//true//4. 使用类的加载器的方式 (了解)Class clazz4 = ClassLoader.getSystemClassLoader().loadClass(&quot;com.atguigu02._class.User&quot;);System.out.println(clazz1 == clazz4);//true Class 可以指向哪些结构。 12345678简言之，所有Java类型！（1）class：外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类（2）interface：接口（3）[]：数组（4）enum：枚举（5）annotation：注解@interface（6）primitive type：基本数据类型（7）void 类的加载过程、类的加载器（理解） 类的加载过程 1234567891011过程1：类的装载(loading)将类的class文件读入内存，并为之创建一个java.lang.Class对象。此过程由类加载器完成过程2：链接(linking)&gt; 验证(Verify):确保加载的类信息符合JVM规范，例如：以cafebabe开头，没有安全方面的问题。&gt; 准备(Prepare):正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。&gt; 解析(Resolve):虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。过程3：初始化(initialization)执行类构造器&lt;clinit&gt;()方法的过程。类构造器&lt;clinit&gt;()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。 类的加载器 1234567891011121314作用：负责类的加载，并对应于一个Class的实例。分类（分为两种）：&gt; BootstrapClassLoader:引导类加载器、启动类加载器 &gt; 使用C/C++语言编写的，不能通过Java代码获取其实例 &gt; 负责加载Java的核心库（JAVA_HOME/jre/lib/rt.jar或sun.boot.class.path路径下的内容）&gt; 继承于ClassLoader的类加载器 &gt; ExtensionClassLoader:扩展类加载器 &gt; 负责加载从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录下加载类库 &gt; SystemClassLoader/ApplicationClassLoader:系统类加载器、应用程序类加载器 &gt; 我们自定义的类，默认使用的类的加载器。 &gt; 用户自定义类的加载器 &gt; 实现应用的隔离（同一个类在一个应用程序中可以加载多份）；数据的加密。 使用类的加载器获取流，并读取配置文件信息: 123456789101112131415161718/** 需求：通过ClassLoader加载指定的配置文件* */@Testpublic void test3() throws IOException &#123; Properties pros = new Properties(); //其他方式读取的文件的默认路径为：当前的module //通过类的加载器读取的文件的默认的路径为：当前module下的src下 InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;info1.properties&quot;); pros.load(is); String name = pros.getProperty(&quot;name&quot;); String pwd = pros.getProperty(&quot;password&quot;); System.out.println(name + &quot;:&quot; +pwd);&#125; 反射的应用1：创建运行时类的对象（重点）123456Class clazz = Person.class;//创建Person类的实例Person per = (Person) clazz.newInstance();System.out.println(per); 123要想创建对象成功，需要满足：条件1：要求运行时类中必须提供一个空参的构造器条件2：要求提供的空参的构造器的权限要足够。 反射的应用2：获取运行时类所有的结构1234567891011121314151617181920212223（了解）获取运行时类的内部结构1：所有属性、所有方法、所有构造器 · getFields():获取到运行时类本身及其所有的父类中声明为public权限的属性 · getDeclaredFields():获取当前运行时类中声明的所有属性 · getMethods():获取到运行时类本身及其所有的父类中声明为public权限的方法 · getDeclaredMethods():获取当前运行时类中声明的所有方法（熟悉）获取运行时类的内部结构2：父类、接口们、包、带泛型的父类、父类的泛型等 1. 获取运行时类的父类 getSuperclass() 2. 获取运行时类实现的接口 getInterfaces() 3. 获取运行时类所在的包 getPackage() 4. 获取运行时类的带泛型的父类 getGenericSuperclass() 5. 获取运行时类的父类的泛型 @Test public void test5() throws ClassNotFoundException &#123; Class clazz = Class.forName(&quot;com.atguigu03.reflectapply.data.Person&quot;); //获取带泛型的父类（Type是一个接口，Class实现了此接口 Type superclass = clazz.getGenericSuperclass(); //如果父类是带泛型的，则可以强转为ParameterizedType ParameterizedType paramType = (ParameterizedType) superclass; //调用getActualTypeArguments()获取泛型的参数，结果是一个数组，因为可能有多个泛型参数。 Type[] arguments = paramType.getActualTypeArguments(); //获取泛型参数的名称 System.out.println(((Class)arguments[0]).getName()); &#125; 反射的应用3：调用指定的结构（重点）123451 调用指定的属性（步骤）步骤1.通过Class实例调用getDeclaredField(String fieldName)，获取运行时类指定名的属性步骤2. setAccessible(true)：确保此属性是可以访问的步骤3. 通过Filed类的实例调用get(Object obj) （获取的操作） 或 set(Object obj,Object value) （设置的操作）进行操作。 123456789101112131415161718@Testpublic void test2() throws Exception &#123; Class clazz = Person.class; // Person per = (Person) clazz.newInstance(); //1.通过Class实例调用getDeclaredField(String fieldName)，获取运行时类指定名的属性 Field nameField = clazz.getDeclaredField(&quot;name&quot;); //2. setAccessible(true)：确保此属性是可以访问的 nameField.setAccessible(true); //3. 通过Filed类的实例调用get(Object obj) （获取的操作） // 或 set(Object obj,Object value) （设置的操作）进行操作。 nameField.set(per,&quot;Tom&quot;); System.out.println(nameField.get(per));&#125; 1234562 调用指定的方法（步骤）步骤1.通过Class的实例调用getDeclaredMethod(String methodName,Class ... args),获取指定的方法步骤2. setAccessible(true)：确保此方法是可访问的步骤3.通过Method实例调用invoke(Object obj,Object ... objs),即为对Method对应的方法的调用。 invoke()的返回值即为Method对应的方法的返回值 特别的：如果Method对应的方法的返回值类型为void，则invoke()返回值为null 1234567891011121314151617181920@Testpublic void test4() throws Exception &#123; Class clazz = Person.class; Person per = (Person) clazz.newInstance(); //1.通过Class的实例调用getDeclaredMethod(String methodName,Class ... args),获取指定的方法 Method showNationMethod = clazz.getDeclaredMethod(&quot;showNation&quot;,String.class,int.class); //2. setAccessible(true)：确保此方法是可访问的 showNationMethod.setAccessible(true); //3.通过Method实例调用invoke(Object obj,Object ... objs),即为对Method对应的方法的调用。 //invoke()的返回值即为Method对应的方法的返回值 //特别的：如果Method对应的方法的返回值类型为void，则invoke()返回值为null Object returnValue = showNationMethod.invoke(per,&quot;CHN&quot;,10); System.out.println(returnValue);&#125; 12343 调用指定的构造器（步骤）步骤1.通过Class的实例调用getDeclaredConstructor(Class ... args)，获取指定参数类型的构造器步骤2.setAccessible(true)：确保此构造器是可以访问的步骤3.通过Constructor实例调用newInstance(Object ... objs),返回一个运行时类的实例。 1234567891011121314151617@Testpublic void test6() throws Exception &#123; Class clazz = Person.class; //1.通过Class的实例调用getDeclaredConstructor(Class ... args)，获取指定参数类型的构造器 Constructor constructor = clazz.getDeclaredConstructor(String.class, int.class); //2.setAccessible(true)：确保此构造器是可以访问的 constructor.setAccessible(true); //3.通过Constructor实例调用newInstance(Object ... objs),返回一个运行时类的实例。 Person per = (Person) constructor.newInstance(&quot;Tom&quot;, 12); System.out.println(per);&#125; 反射的应用4：注解的使用（了解）在框架中用的比较多。 体会：反射的动态性12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class ReflectTest &#123; //体会：静态性 public Person getInstance()&#123; return new Person(); &#125; //体会：反射的动态性 //举例1： public &lt;T&gt; T getInstance(String className) throws Exception &#123; Class clazz = Class.forName(className); Constructor con = clazz.getDeclaredConstructor(); con.setAccessible(true); return (T) con.newInstance(); &#125; @Test public void test1() throws Exception &#123; Person p1 = getInstance(); System.out.println(p1); String className = &quot;com.atguigu04.other.dynamic.Person&quot;; Person per1 = getInstance(className); System.out.println(per1); String className1 = &quot;java.util.Date&quot;; Date date1 = getInstance(className1); System.out.println(date1); &#125; //体会：反射的动态性 //举例2： public Object invoke(String className,String methodName) throws Exception &#123; //1. 创建全类名对应的运行时类的对象 Class clazz = Class.forName(className); Constructor con = clazz.getDeclaredConstructor(); con.setAccessible(true); Object obj = con.newInstance(); //2. 获取运行时类中指定的方法，并调用 Method method = clazz.getDeclaredMethod(methodName); method.setAccessible(true); return method.invoke(obj); &#125; @Test public void test2() throws Exception &#123; String className = &quot;com.atguigu04.other.dynamic.Person&quot;; String methodName = &quot;show&quot;; Object returnValue = invoke(className,methodName); System.out.println(returnValue); &#125;&#125; 企业真题（十七）反射概述1. 对反射了解吗？反射有什么好处？为什么需要反射？（微*银行）1234类似问题：&gt; Java反射的作用是什么？(三*重工、上海*和网络)&gt; Java反射机制的作用有什么？(上海明*物联网)&gt; 反射的具体用途？（阿***芝*信用项目组） 略 2. 反射的使用场合和作用、及其优缺点（*软国际）123类似问题：&gt; 反射机制的优缺点(君*科技)&gt; Java反射你怎么用的？（吉*航空） 略 3. 实现Java反射的类有什么？(君*科技)12类似问题：&gt; Java反射 API 有几类？(北京*蓝) 问API。 4. 反射是怎么实现的？（上海立*网络）从Class说起。 Class的理解1. Class类的作用？生成Class对象的方法有哪些？(顺*)反射的源头。 主要有三种。 2. Class.forName(“全路径”) 会调用哪些方法 ？ 会调用构造方法吗？加载的类会放在哪？（上*银行外包）Class.forName() 会执行执行类构造器()方法。 不会调用构造方法 加载的类放在方法区。 类的加载1. 类加载流程（汇**通、同*顺、凡*科技）略 创建对象1. 说一下创建对象的几种方法？（华油***集团、*科软、凡*科技）12类似问题：&gt; 除了使用new创建对象之外，还可以用什么方法创建对象？(*云网络) 2. 如何找到对象实际类的？（*度）对象.getClass(); 123Object obj = new Date();obj.getClass();// 获取到的是Date。 3. Java反射创建对象效率高还是通过new创建对象的效率高？(三*重工)new 的方式。 调用属性、方法1. 如何利用反射机制来访问一个类的方法？（神州**软件）123456调用指定的方法（步骤）步骤1.通过Class的实例调用getDeclaredMethod(String methodName,Class ... args),获取指定的方法步骤2. setAccessible(true)：确保此方法是可访问的步骤3.通过Method实例调用invoke(Object obj,Object ... objs),即为对Method对应的方法的调用。 invoke()的返回值即为Method对应的方法的返回值 特别的：如果Method对应的方法的返回值类型为void，则invoke()返回值为null 2. 说一下Java反射获取私有属性，如何改变值？（阿****麻信用项目组）12345调用指定的属性（步骤）步骤1.通过Class实例调用getDeclaredField(String fieldName)，获取运行时类指定名的属性步骤2. setAccessible(true)：确保此属性是可以访问的步骤3. 通过Filed类的实例调用get(Object obj) （获取的操作） 或 set(Object obj,Object value) （设置的操作）进行操作。 1针对于核心源码的api，内部的私有的结构在jdk17中就不可以通过反射调用了。 JDK8-17新特性Java版本迭代概述 发行版本 发行时间 备注 Java 1.0 1996.01.23 Sun公司发布了Java的第一个开发工具包 Java 5.0 2004.09.30 ①版本号从1.4直接更新至5.0；②平台更名为JavaSE、JavaEE、JavaME Java 8.0 2014.03.18 此版本是继Java 5.0以来变化最大的版本。是长期支持版本（LTS） Java 9.0 2017.09.22 此版本开始，每半年更新一次 Java 10.0 2018.03.21 Java 11.0 2018.09.25 JDK安装包取消独立JRE安装包，是长期支持版本（LTS） Java 12.0 2019.03.19 … … Java17.0 2021.09 发布Java 17.0，版本号也称为21.9，是长期支持版本（LTS） … … Java19.0 2022.09 发布Java19.0，版本号也称为22.9。 从Java 9 这个版本开始，Java 的计划发布周期是 6个月。 这意味着Java的更新从传统的以特性驱动的发布周期，转变为以时间驱动的发布模式，并且承诺不会跳票。通过这样的方式，开发团队可以把一些关键特性尽早合并到 JDK 之中，以快速得到开发者反馈，在一定程度上避免出现像 Java 9 两次被迫延迟发布的窘况。 针对企业客户的需求，Oracle 将以三年为周期发布长期支持版本（long term support）。 Oracle 的官方观点认为：与 Java 7-&gt;8-&gt;9 相比，Java 9-&gt;10-&gt;11的升级和 8-&gt;8u20-&gt;8u40 更相似。 新模式下的 Java 版本发布都会包含许多变更，包括语言变更和 JVM 变更，这两者都会对 IDE、字节码库和框架产生重大影响。此外，不仅会新增其他 API，还会有 API被删除（这在 Java 8 之前没有发生过）。 各版本介绍 jdk 9Java 9 提供了超过150项新功能特性，包括备受期待的模块化系统、可交互的 REPL 工具：jshell，JDK 编译工具，Java 公共 API 和私有代码，以及安全增强、扩展提升、性能管理改善等。 特性太多，查看链接： https://openjdk.java.net/projects/jdk9/ jdk 10https://openjdk.java.net/projects/jdk/10/ 286: Local-Variable Type Inference 局部变量类型推断 296: Consolidate the JDK Forest into a Single Repository JDK库的合并 304: Garbage-Collector Interface 统一的垃圾回收接口 307: Parallel Full GC for G1 为G1提供并行的Full GC 310: Application Class-Data Sharing 应用程序类数据（AppCDS）共享 312: Thread-Local Handshakes ThreadLocal握手交互 313: Remove the Native-Header Generation Tool (javah) 移除JDK中附带的javah工具 314: Additional Unicode Language-Tag Extensions 使用附加的Unicode语言标记扩展 316: Heap Allocation on Alternative Memory Devices 能将堆内存占用分配给用户指定的备用内存设备 317: Experimental Java-Based JIT Compiler 使用Graal基于Java的编译器 319: Root Certificates 根证书 322: Time-Based Release Versioning 基于时间定于的发布版本 jdk 11https://openjdk.java.net/projects/jdk/11/ 181: Nest-Based Access Control 基于嵌套的访问控制309: Dynamic Class-File Constants 动态类文件常量315: Improve Aarch64 Intrinsics 改进 Aarch64 Intrinsics318: Epsilon: A No-Op Garbage Collector Epsilon — 一个No-Op（无操作）的垃圾收集器320: Remove the Java EE and CORBA Modules 删除 Java EE 和 CORBA 模块321: HTTP Client (Standard) HTTPClient API323: Local-Variable Syntax for Lambda Parameters 用于 Lambda 参数的局部变量语法324: Key Agreement with Curve25519 and Curve448 Curve25519 和 Curve448 算法的密钥协议327: Unicode 10328: Flight Recorder 飞行记录仪329: ChaCha20 and Poly1305 Cryptographic Algorithms ChaCha20 和 Poly1305 加密算法330: Launch Single-File Source-Code Programs 启动单一文件的源代码程序331: Low-Overhead Heap Profiling 低开销的 Heap Profiling332: Transport Layer Security (TLS) 1.3 支持 TLS 1.3333: ZGC: A Scalable Low-Latency Garbage Collector (Experimental) 可伸缩低延迟垃圾收集器335: Deprecate the Nashorn JavaScript Engine 弃用 Nashorn JavaScript 引擎336: Deprecate the Pack200 Tools and API 弃用 Pack200 工具和 API jdk 12https://openjdk.java.net/projects/jdk/12/ 189：Shenandoah: A Low-Pause-Time Garbage Collector (Experimental) 低暂停时间的GC230: Microbenchmark Suite 微基准测试套件325: Switch Expressions (Preview) switch表达式334: JVM Constants API JVM常量API340: One AArch64 Port, Not Two 只保留一个AArch64实现341: Default CDS Archives 默认类数据共享归档文件344: Abortable Mixed Collections for G1 可中止的G1 Mixed GC346: Promptly Return Unused Committed Memory from G1 G1及时返回未使用的已分配内存 jdk 13https://openjdk.java.net/projects/jdk/13/ 350: Dynamic CDS Archives 动态CDS档案351: ZGC: Uncommit Unused Memory ZGC:取消使用未使用的内存353: Reimplement the Legacy Socket API 重新实现旧版套接字API354: Switch Expressions (Preview) switch表达式（预览）355: Text Blocks (Preview) 文本块（预览） jdk 14https://openjdk.java.net/projects/jdk/14/ 305: Pattern Matching for instanceof (Preview) instanceof的模式匹配343: Packaging Tool (Incubator) 打包工具345: NUMA-Aware Memory Allocation for G1 G1的NUMA-Aware内存分配349: JFR Event Streaming JFR事件流352: Non-Volatile Mapped Byte Buffers 非易失性映射字节缓冲区358: Helpful NullPointerExceptions 实用的NullPointerExceptions359: Records (Preview)361: Switch Expressions (Standard) Switch表达式362: Deprecate the Solaris and SPARC Ports 弃用Solaris和SPARC端口363: Remove the Concurrent Mark Sweep (CMS) Garbage Collector 删除并发标记扫描（CMS）垃圾回收器364: ZGC on macOS365: ZGC on Windows366: Deprecate the ParallelScavenge + SerialOld GC Combination 弃用ParallelScavenge + SerialOld GC组合367: Remove the Pack200 Tools and API 删除Pack200工具和API368: Text Blocks (Second Preview) 文本块370: Foreign-Memory Access API (Incubator) 外部存储器访问API jdk 15https://openjdk.java.net/projects/jdk/15/ 339: Edwards-Curve Digital Signature Algorithm (EdDSA) EdDSA 数字签名算法360: Sealed Classes (Preview) 密封类（预览）371: Hidden Classes 隐藏类372: Remove the Nashorn JavaScript Engine 移除 Nashorn JavaScript 引擎373: Reimplement the Legacy DatagramSocket API 重新实现 Legacy DatagramSocket API374: Disable and Deprecate Biased Locking 禁用偏向锁定375: Pattern Matching for instanceof (Second Preview) instanceof 模式匹配（第二次预览）377: ZGC: A Scalable Low-Latency Garbage Collector ZGC：一个可扩展的低延迟垃圾收集器378: Text Blocks 文本块379: Shenandoah: A Low-Pause-Time Garbage Collector Shenandoah:低暂停时间垃圾收集器381: Remove the Solaris and SPARC Ports 移除 Solaris 和 SPARC 端口383: Foreign-Memory Access API (Second Incubator) 外部存储器访问 API（第二次孵化版）384: Records (Second Preview) Records（第二次预览）385: Deprecate RMI Activation for Removal 废弃 RMI 激活机制 jdk 16https://openjdk.java.net/projects/jdk/16/ 338: Vector API (Incubator) Vector API（孵化器）347: Enable C++14 Language Features JDK C++的源码中允许使用C++14的语言特性357: Migrate from Mercurial to Git OpenJDK源码的版本控制从Mercurial (hg) 迁移到git369: Migrate to GitHub OpenJDK源码的版本控制迁移到github上376: ZGC: Concurrent Thread-Stack Processing ZGC：并发线程处理380: Unix-Domain Socket Channels Unix域套接字通道386: Alpine Linux Port 将glibc的jdk移植到使用musl的alpine linux上387: Elastic Metaspace 弹性元空间388: Windows&#x2F;AArch64 Port 移植JDK到Windows&#x2F;AArch64389: Foreign Linker API (Incubator) 提供jdk.incubator.foreign来简化native code的调用390: Warnings for Value-Based Classes 提供基于值的类的警告392: Packaging Tool jpackage打包工具转正393: Foreign-Memory Access API (Third Incubator)394: Pattern Matching for instanceof Instanceof的模式匹配转正395: Records Records转正396: Strongly Encapsulate JDK Internals by Default 默认情况下，封装了JDK内部构件397: Sealed Classes (Second Preview) 密封类 jdk 17https://openjdk.java.net/projects/jdk/17/ 306: Restore Always-Strict Floating-Point Semantics 恢复始终严格的浮点语义 356: Enhanced Pseudo-Random Number Generators 增强型伪随机数生成器 382: New macOS Rendering Pipeline 新的macOS渲染管道 391: macOS&#x2F;AArch64 Port macOS&#x2F;AArch64端口 398: Deprecate the Applet API for Removal 弃用Applet API后续将进行删除 403: Strongly Encapsulate JDK Internals 强封装JDK的内部API 406: Pattern Matching for switch (Preview) switch模式匹配（预览） 407: Remove RMI Activation 删除RMI激活机制 409: Sealed Classes 密封类转正 410: Remove the Experimental AOT and JIT Compiler 删除实验性的AOT和JIT编译器 411: Deprecate the Security Manager for Removal 弃用即将删除的安全管理器 412: Foreign Function &amp; Memory API (Incubator) 外部函数和内存API（孵化特性） 414: Vector API (Second Incubator) Vector API（第二次孵化特性） 415: Context-Specific Deserialization Filters 上下文特定的反序列化过滤器 Java8新特性：Lambda表达式场景冗余的匿名内部类：当需要启动一个线程去完成任务时，通常会通过java.lang.Runnable接口来定义任务内容，并使用java.lang.Thread类来启动该线程。代码如下： 123456789101112package com.atguigu.fp;public class UseFunctionalProgramming &#123; public static void main(String[] args) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;多线程任务执行！&quot;); &#125; &#125;).start(); // 启动线程 &#125;&#125; 本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个Runnable接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。 代码分析： 对于Runnable的匿名内部类用法，可以分析出几点内容： Thread类需要Runnable接口作为参数，其中的抽象run方法是用来指定线程任务内容的核心； 为了指定run的方法体，不得不需要Runnable接口的实现类； 为了省去定义一个RunnableImpl实现类的麻烦，不得不使用匿名内部类； 必须覆盖重写抽象run方法，所以方法名称、方法参数、方法返回值不得不再写一遍，且不能写错； 而实际上，似乎只有方法体才是关键所在。 Lambda 及其语法Lambda 是一个匿名函数，我们可以把 Lambda 表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升 Lambda 表达式：在Java 8 语言中引入的一种新的语法元素和操作符。这个操作符为 “-&gt;” ， 该操作符被称为 Lambda 操作符或箭头操作符。它将 Lambda 分为两个部分： 左侧：指定了 Lambda 表达式需要的参数列表 右侧：指定了 Lambda 体，是抽象方法的实现逻辑，也即 Lambda 表达式要执行的功能。 语法格式一：无参，无返回值 123456789101112131415161718192021@Testpublic void test1()&#123; //未使用Lambda表达式 Runnable r1 = new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;我爱北京天安门&quot;); &#125; &#125;; r1.run(); System.out.println(&quot;***********************&quot;); //使用Lambda表达式 Runnable r2 = () -&gt; &#123; System.out.println(&quot;我爱北京故宫&quot;); &#125;; r2.run();&#125; 语法格式二：Lambda 需要一个参数，但是没有返回值。 1234567891011121314151617181920@Testpublic void test2()&#123; //未使用Lambda表达式 Consumer&lt;String&gt; con = new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) &#123; System.out.println(s); &#125; &#125;; con.accept(&quot;谎言和誓言的区别是什么？&quot;); System.out.println(&quot;*******************&quot;); //使用Lambda表达式 Consumer&lt;String&gt; con1 = (String s) -&gt; &#123; System.out.println(s); &#125;; con1.accept(&quot;一个是听得人当真了，一个是说的人当真了&quot;);&#125; 语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断” 12345678910111213141516@Testpublic void test3()&#123; //语法格式三使用前 Consumer&lt;String&gt; con1 = (String s) -&gt; &#123; System.out.println(s); &#125;; con1.accept(&quot;一个是听得人当真了，一个是说的人当真了&quot;); System.out.println(&quot;*******************&quot;); //语法格式三使用后 Consumer&lt;String&gt; con2 = (s) -&gt; &#123; System.out.println(s); &#125;; con2.accept(&quot;一个是听得人当真了，一个是说的人当真了&quot;);&#125; 语法格式四：Lambda 若只需要一个参数时，参数的小括号可以省略 1234567891011121314151617@Testpublic void test4()&#123; //语法格式四使用前 Consumer&lt;String&gt; con1 = (s) -&gt; &#123; System.out.println(s); &#125;; con1.accept(&quot;一个是听得人当真了，一个是说的人当真了&quot;); System.out.println(&quot;*******************&quot;); //语法格式四使用后 Consumer&lt;String&gt; con2 = s -&gt; &#123; System.out.println(s); &#125;; con2.accept(&quot;一个是听得人当真了，一个是说的人当真了&quot;);&#125; 语法格式五：Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值 12345678910111213141516171819202122232425@Testpublic void test5()&#123; //语法格式五使用前 Comparator&lt;Integer&gt; com1 = new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; System.out.println(o1); System.out.println(o2); return o1.compareTo(o2); &#125; &#125;; System.out.println(com1.compare(12,21)); System.out.println(&quot;*****************************&quot;); //语法格式五使用后 Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; &#123; System.out.println(o1); System.out.println(o2); return o1.compareTo(o2); &#125;; System.out.println(com2.compare(12,6));&#125; 语法格式六：当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略 1234567891011121314151617181920212223242526272829303132@Testpublic void test6()&#123; //语法格式六使用前 Comparator&lt;Integer&gt; com1 = (o1,o2) -&gt; &#123; return o1.compareTo(o2); &#125;; System.out.println(com1.compare(12,6)); System.out.println(&quot;*****************************&quot;); //语法格式六使用后 Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; o1.compareTo(o2); System.out.println(com2.compare(12,21));&#125;@Testpublic void test7()&#123; //语法格式六使用前 Consumer&lt;String&gt; con1 = s -&gt; &#123; System.out.println(s); &#125;; con1.accept(&quot;一个是听得人当真了，一个是说的人当真了&quot;); System.out.println(&quot;*****************************&quot;); //语法格式六使用后 Consumer&lt;String&gt; con2 = s -&gt; System.out.println(s); con2.accept(&quot;一个是听得人当真了，一个是说的人当真了&quot;);&#125; Java8新特性：函数式(Functional)接口什么是函数式接口 只包含一个抽象方法（Single Abstract Method，简称SAM）的接口，称为函数式接口。当然该接口可以包含其他非抽象方法。 你可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda 表达式抛出一个受检异常(即：非运行时异常)，那么该异常需要在目标接口的抽象方法上进行声明）。 我们可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。 在java.util.function包下定义了Java 8 的丰富的函数式接口 如何理解函数式接口 简单的说，在Java8中，Lambda表达式就是一个函数式接口的实例。这就是Lambda表达式和函数式接口的关系。也就是说，只要一个对象是函数式接口的实例，那么该对象就可以用Lambda表达式来表示。 Java 内置函数式接口 java.lang.Runnable public void run() java.lang.Iterable public Iterator iterate() java.lang.Comparable public int compareTo(T t) java.util.Comparator public int compare(T t1, T t2) 函数式接口 称谓 参数类型 用途 Consumer&lt;T&gt; 消费型接口 T 对类型为T的对象应用操作，包含方法： void accept(T t) Supplier&lt;T&gt; 供给型接口 无 返回类型为T的对象，包含方法：T get() Function&lt;T, R&gt; 函数型接口 T 对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：R apply(T t) Predicate&lt;T&gt; 判断型接口 T 确定类型为T的对象是否满足某约束，并返回 boolean 值。包含方法：boolean test(T t) 其他接口： 类型1：消费型接口 消费型接口的抽象方法特点：有形参，但是返回值类型是void 接口名 抽象方法 描述 BiConsumer&lt;T,U&gt; void accept(T t, U u) 接收两个对象用于完成功能 DoubleConsumer void accept(double value) 接收一个double值 IntConsumer void accept(int value) 接收一个int值 LongConsumer void accept(long value) 接收一个long值 ObjDoubleConsumer void accept(T t, double value) 接收一个对象和一个double值 ObjIntConsumer void accept(T t, int value) 接收一个对象和一个int值 ObjLongConsumer void accept(T t, long value) 接收一个对象和一个long值 类型2：供给型接口 这类接口的抽象方法特点：无参，但是有返回值 接口名 抽象方法 描述 BooleanSupplier boolean getAsBoolean() 返回一个boolean值 DoubleSupplier double getAsDouble() 返回一个double值 IntSupplier int getAsInt() 返回一个int值 LongSupplier long getAsLong() 返回一个long值 类型3：函数型接口 这类接口的抽象方法特点：既有参数又有返回值 接口名 抽象方法 描述 UnaryOperator T apply(T t) 接收一个T类型对象，返回一个T类型对象结果 DoubleFunction R apply(double value) 接收一个double值，返回一个R类型对象 IntFunction R apply(int value) 接收一个int值，返回一个R类型对象 LongFunction R apply(long value) 接收一个long值，返回一个R类型对象 ToDoubleFunction double applyAsDouble(T value) 接收一个T类型对象，返回一个double ToIntFunction int applyAsInt(T value) 接收一个T类型对象，返回一个int ToLongFunction long applyAsLong(T value) 接收一个T类型对象，返回一个long DoubleToIntFunction int applyAsInt(double value) 接收一个double值，返回一个int结果 DoubleToLongFunction long applyAsLong(double value) 接收一个double值，返回一个long结果 IntToDoubleFunction double applyAsDouble(int value) 接收一个int值，返回一个double结果 IntToLongFunction long applyAsLong(int value) 接收一个int值，返回一个long结果 LongToDoubleFunction double applyAsDouble(long value) 接收一个long值，返回一个double结果 LongToIntFunction int applyAsInt(long value) 接收一个long值，返回一个int结果 DoubleUnaryOperator double applyAsDouble(double operand) 接收一个double值，返回一个double IntUnaryOperator int applyAsInt(int operand) 接收一个int值，返回一个int结果 LongUnaryOperator long applyAsLong(long operand) 接收一个long值，返回一个long结果 BiFunction&lt;T,U,R&gt; R apply(T t, U u) 接收一个T类型和一个U类型对象，返回一个R类型对象结果 BinaryOperator T apply(T t, T u) 接收两个T类型对象，返回一个T类型对象结果 ToDoubleBiFunction&lt;T,U&gt; double applyAsDouble(T t, U u) 接收一个T类型和一个U类型对象，返回一个double ToIntBiFunction&lt;T,U&gt; int applyAsInt(T t, U u) 接收一个T类型和一个U类型对象，返回一个int ToLongBiFunction&lt;T,U&gt; long applyAsLong(T t, U u) 接收一个T类型和一个U类型对象，返回一个long DoubleBinaryOperator double applyAsDouble(double left, double right) 接收两个double值，返回一个double结果 IntBinaryOperator int applyAsInt(int left, int right) 接收两个int值，返回一个int结果 LongBinaryOperator long applyAsLong(long left, long right) 接收两个long值，返回一个long结果 类型4：判断型接口 这类接口的抽象方法特点：有参，但是返回值类型是boolean结果。 接口名 抽象方法 描述 BiPredicate&lt;T,U&gt; boolean test(T t, U u) 接收两个对象 DoublePredicate boolean test(double value) 接收一个double值 IntPredicate boolean test(int value) 接收一个int值 LongPredicate boolean test(long value) 接收一个long值 练习练习1：无参无返回值形式 假如有自定义函数式接口Call如下： 123public interface Call &#123; void shout();&#125; 在测试类中声明一个如下方法： 123public static void callSomething(Call call)&#123; call.shout();&#125; 在测试类的main方法中调用callSomething方法，并用Lambda表达式为形参call赋值，可以喊出任意你想说的话。 1234567891011121314public class TestLambda &#123; public static void main(String[] args) &#123; callSomething(()-&gt;System.out.println(&quot;回家吃饭&quot;)); callSomething(()-&gt;System.out.println(&quot;我爱你&quot;)); callSomething(()-&gt;System.out.println(&quot;滚蛋&quot;)); callSomething(()-&gt;System.out.println(&quot;回来&quot;)); &#125; public static void callSomething(Call call)&#123; call.shout(); &#125;&#125;interface Call &#123; void shout();&#125; 练习2：消费型接口 代码示例：Consumer接口 在JDK1.8中Collection集合接口的父接口Iterable接口中增加了一个默认方法： public default void forEach(Consumer&lt;? super T&gt; action) 遍历Collection集合的每个元素，执行“xxx消费型”操作。 在JDK1.8中Map集合接口中增加了一个默认方法： public default void forEach(BiConsumer&lt;? super K,? super V&gt; action)遍历Map集合的每对映射关系，执行“xxx消费型”操作。 案例： （1）创建一个Collection系列的集合，添加一些字符串，调用forEach方法遍历查看 （2）创建一个Map系列的集合，添加一些(key,value)键值对，调用forEach方法遍历查看 示例代码： 1234567891011121314@Testpublic void test1()&#123; List&lt;String&gt; list = Arrays.asList(&quot;hello&quot;,&quot;java&quot;,&quot;lambda&quot;,&quot;atguigu&quot;); list.forEach(s -&gt; System.out.println(s)); &#125;@Testpublic void test2()&#123; HashMap&lt;Integer,String&gt; map = new HashMap&lt;&gt;(); map.put(1, &quot;hello&quot;); map.put(2, &quot;java&quot;); map.put(3, &quot;lambda&quot;); map.put(4, &quot;atguigu&quot;); map.forEach((k,v) -&gt; System.out.println(k+&quot;-&gt;&quot;+v));&#125; 练习3：供给型接口 代码示例：Supplier接口 在JDK1.8中增加了StreamAPI，java.util.stream.Stream是一个数据流。这个类型有一个静态方法： public static &lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)可以创建Stream的对象。而又包含一个forEach方法可以遍历流中的元素：public void forEach(Consumer&lt;? super T&gt; action)。 案例： 现在请调用Stream的generate方法，来产生一个流对象，并调用Math.random()方法来产生数据，为Supplier函数式接口的形参赋值。最后调用forEach方法遍历流中的数据查看结果。 1234@Testpublic void test2()&#123; Stream.generate(() -&gt; Math.random()).forEach(num -&gt; System.out.println(num));&#125; 练习4：功能型接口 代码示例：Function&lt;T,R&gt;接口 在JDK1.8时Map接口增加了很多方法，例如： public default void replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; function) 按照function指定的操作替换map中的value。 public default void forEach(BiConsumer&lt;? super K,? super V&gt; action)遍历Map集合的每对映射关系，执行“xxx消费型”操作。 案例： （1）声明一个Employee员工类型，包含编号、姓名、薪资。 （2）添加n个员工对象到一个HashMap&lt;Integer,Employee&gt;集合中，其中员工编号为key，员工对象为value。 （3）调用Map的forEach遍历集合 （4）调用Map的replaceAll方法，将其中薪资低于10000元的，薪资设置为10000。 （5）再次调用Map的forEach遍历集合查看结果 Employee类： 12345678910111213141516171819202122232425262728293031323334353637class Employee&#123; private int id; private String name; private double salary; public Employee(int id, String name, double salary) &#123; super(); this.id = id; this.name = name; this.salary = salary; &#125; public Employee() &#123; super(); &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125; @Override public String toString() &#123; return &quot;Employee [id=&quot; + id + &quot;, name=&quot; + name + &quot;, salary=&quot; + salary + &quot;]&quot;; &#125; &#125; 测试类： 1234567891011121314151617181920212223242526272829import java.util.HashMap;public class TestLambda &#123; public static void main(String[] args) &#123; HashMap&lt;Integer,Employee&gt; map = new HashMap&lt;&gt;(); Employee e1 = new Employee(1, &quot;张三&quot;, 8000); Employee e2 = new Employee(2, &quot;李四&quot;, 9000); Employee e3 = new Employee(3, &quot;王五&quot;, 10000); Employee e4 = new Employee(4, &quot;赵六&quot;, 11000); Employee e5 = new Employee(5, &quot;钱七&quot;, 12000); map.put(e1.getId(), e1); map.put(e2.getId(), e2); map.put(e3.getId(), e3); map.put(e4.getId(), e4); map.put(e5.getId(), e5); map.forEach((k,v) -&gt; System.out.println(k+&quot;=&quot;+v)); System.out.println(); map.replaceAll((k,v)-&gt;&#123; if(v.getSalary()&lt;10000)&#123; v.setSalary(10000); &#125; return v; &#125;); map.forEach((k,v) -&gt; System.out.println(k+&quot;=&quot;+v)); &#125;&#125; 练习5：判断型接口 代码示例：Predicate接口 JDK1.8时，Collecton接口增加了一下方法，其中一个如下： public default boolean removeIf(Predicate&lt;? super E&gt; filter) 用于删除集合中满足filter指定的条件判断的。 public default void forEach(Consumer&lt;? super T&gt; action) 遍历Collection集合的每个元素，执行“xxx消费型”操作。 案例： （1）添加一些字符串到一个Collection集合中 （2）调用forEach遍历集合 （3）调用removeIf方法，删除其中字符串的长度&lt;5的 （4）再次调用forEach遍历集合 123456789101112131415161718import java.util.ArrayList;public class TestLambda &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;hello&quot;); list.add(&quot;java&quot;); list.add(&quot;atguigu&quot;); list.add(&quot;ok&quot;); list.add(&quot;yes&quot;); list.forEach(str-&gt;System.out.println(str)); System.out.println(); list.removeIf(str-&gt;str.length()&lt;5); list.forEach(str-&gt;System.out.println(str)); &#125;&#125; 练习6：判断型接口 案例： （1）声明一个Employee员工类型，包含编号、姓名、性别，年龄，薪资。 （2）声明一个EmployeeSerice员工管理类，包含一个ArrayList集合的属性all，在EmployeeSerice的构造器中，创建一些员工对象，为all集合初始化。 （3）在EmployeeSerice员工管理类中，声明一个方法：ArrayList get(Predicate p)，即将满足p指定的条件的员工，添加到一个新的ArrayList 集合中返回。 （4）在测试类中创建EmployeeSerice员工管理类的对象，并调用get方法，分别获取： 所有员工对象 所有年龄超过35的员工 所有薪资高于15000的女员工 所有编号是偶数的员工 名字是“张三”的员工 年龄超过25，薪资低于10000的男员工 示例代码： Employee类： 123456789101112131415161718192021222324252627282930313233343536373839404142public class Employee&#123; private int id; private String name; private char gender; private int age; private double salary; public Employee(int id, String name, char gender, int age, double salary) &#123; super(); this.id = id; this.name = name; this.gender = gender; this.age = age; this.salary = salary; &#125; public Employee() &#123; super(); &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125; @Override public String toString() &#123; return &quot;Employee [id=&quot; + id + &quot;, name=&quot; + name + &quot;, gender=&quot; + gender + &quot;, age=&quot; + age + &quot;, salary=&quot; + salary + &quot;]&quot;; &#125;&#125; 员工管理类： 123456789101112131415161718192021class EmployeeService&#123; private ArrayList&lt;Employee&gt; all; public EmployeeService()&#123; all = new ArrayList&lt;Employee&gt;(); all.add(new Employee(1, &quot;张三&quot;, &#x27;男&#x27;, 33, 8000)); all.add(new Employee(2, &quot;翠花&quot;, &#x27;女&#x27;, 23, 18000)); all.add(new Employee(3, &quot;无能&quot;, &#x27;男&#x27;, 46, 8000)); all.add(new Employee(4, &quot;李四&quot;, &#x27;女&#x27;, 23, 9000)); all.add(new Employee(5, &quot;老王&quot;, &#x27;男&#x27;, 23, 15000)); all.add(new Employee(6, &quot;大嘴&quot;, &#x27;男&#x27;, 23, 11000)); &#125; public ArrayList&lt;Employee&gt; get(Predicate&lt;Employee&gt; p)&#123; ArrayList&lt;Employee&gt; result = new ArrayList&lt;Employee&gt;(); for (Employee emp : result) &#123; if(p.test(emp))&#123; result.add(emp); &#125; &#125; return result; &#125;&#125; 测试类： 1234567891011121314151617public class TestLambda &#123; public static void main(String[] args) &#123; EmployeeService es = new EmployeeService(); es.get(e -&gt; true).forEach(e-&gt;System.out.println(e)); System.out.println(); es.get(e -&gt; e.getAge()&gt;35).forEach(e-&gt;System.out.println(e)); System.out.println(); es.get(e -&gt; e.getSalary()&gt;15000 &amp;&amp; e.getGender()==&#x27;女&#x27;).forEach(e-&gt;System.out.println(e)); System.out.println(); es.get(e -&gt; e.getId()%2==0).forEach(e-&gt;System.out.println(e)); System.out.println(); es.get(e -&gt; &quot;张三&quot;.equals(e.getName())).forEach(e-&gt;System.out.println(e)); System.out.println(); es.get(e -&gt; e.getAge()&gt;25 &amp;&amp; e.getSalary()&lt;10000 &amp;&amp; e.getGender()==&#x27;男&#x27;).forEach(e-&gt;System.out.println(e)); &#125;&#125; Java8新特性：方法引用与构造器引用方法引用当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！ 方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。 语法糖（Syntactic sugar），也译为糖衣语法，是由英国计算机科学家彼得·约翰·兰达（Peter J. Landin）发明的一个术语，指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。 方法引用格式 格式：使用方法引用操作符 “::” 将类(或对象) 与 方法名分隔开来。 两个:中间不能有空格，而且必须英文状态下半角输入 如下三种主要使用情况： 情况1：对象 :: 实例方法名 情况2：类 :: 静态方法名 情况3：类 :: 实例方法名 方法引用使用前提要求1：Lambda体只有一句语句，并且是通过调用一个对象的&#x2F;类现有的方法来完成的 例如：System.out对象，调用println()方法来完成Lambda体 ​ Math类，调用random()静态方法来完成Lambda体 要求2： 针对情况1：函数式接口中的抽象方法a在被重写时使用了某一个对象的方法b。如果方法a的形参列表、返回值类型与方法b的形参列表、返回值类型都相同，则我们可以使用方法b实现对方法a的重写、替换。 对象 :: 实例方法 1234567//1Consumer&lt;String&gt; con1 = str -&gt; System.out.println(str);Consumer&lt;String&gt; con2 = System.out::println;//2Supplier&lt;String&gt; sup1 = () -&gt; emp.getName();Supplier&lt;String&gt; sup2 = emp::getName; 针对情况2：函数式接口中的抽象方法a在被重写时使用了某一个类的静态方法b。如果方法a的形参列表、返回值类型与方法b的形参列表、返回值类型都相同，则我们可以使用方法b实现对方法a的重写、替换。 类 :: 静态方法 1234567//1Comparator&lt;Integer&gt; com1 = (t1,t2) -&gt; Integer.compare(t1,t2);Comparator&lt;Integer&gt; com2 = Integer::compare;//2Function&lt;Double,Long&gt; func1 = d -&gt; Math.round(d);Function&lt;Double,Long&gt; func2 = Math::round; 针对情况3：函数式接口中的抽象方法a在被重写时使用了某一个对象的方法b。如果方法a的返回值类型与方法b的返回值类型相同，同时方法a的形参列表中有n个参数，方法b的形参列表有n-1个参数，且方法a的第1个参数作为方法b的调用者，且方法a的后n-1参数与方法b的n-1参数匹配（类型相同或满足多态场景也可以） 类 :: 实例方法 1234567891011//1Comparator&lt;String&gt; com1 = (s1,s2) -&gt; s1.compareTo(s2);Comparator&lt;String&gt; com2 = String :: compareTo;//2BiPredicate&lt;String,String&gt; pre1 = (s1,s2) -&gt; s1.equals(s2);BiPredicate&lt;String,String&gt; pre2 = String :: equals;//3Function&lt;Employee,String&gt; func1 = e -&gt; e.getName();Function&lt;Employee,String&gt; func2 = Employee::getName; 构造器引用当Lambda表达式是创建一个对象，并且满足Lambda表达式形参，正好是给创建这个对象的构造器的实参列表，就可以使用构造器引用。 格式：类名::new 123456789101112Supplier&lt;Employee&gt; sup = new Supplier&lt;Employee&gt;() &#123; @Override public Employee get() &#123; return new Employee(); &#125;&#125;;Supplier&lt;Employee&gt; sup1 = () -&gt; new Employee();Supplier&lt;Employee&gt; sup2 = Employee :: new; 数组构造引用当Lambda表达式是创建一个数组对象，并且满足Lambda表达式形参，正好是给创建这个数组对象的长度，就可以数组构造引用。 格式：数组类型名::new 12Function&lt;Integer,String[]&gt; func1 = length -&gt; new String[length];Function&lt;Integer,String[]&gt; func2 = String[] :: new; Java8新特性：强大的Stream API概述 Stream API ( java.util.stream) 把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为Stream API可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。 Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式。 为什么要使用Stream API：实际开发中，项目中多数数据源都来自于MySQL、Oracle等。但现在数据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据就需要Java层面去处理。 什么是Stream：Stream 是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。 Stream 和 Collection 集合的区别：Collection 是一种静态的内存数据结构，讲的是数据，而 Stream 是有关计算的，讲的是计算。前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算。 注意： ①Stream 自己不会存储元素。 ②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。 ③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。即一旦执行终止操作，就执行中间操作链，并产生结果。 ④ Stream一旦执行了终止操作，就不能再调用其它中间操作或终止操作了。 Stream的操作三个步骤1- 创建 Stream一个数据源（如：集合、数组），获取一个流 2- 中间操作每次处理都会返回一个持有结果的新Stream，即中间操作的方法返回值仍然是Stream类型的对象。因此中间操作可以是个操作链，可对数据源的数据进行n次处理，但是在终结操作前，并不会真正执行。 3- 终止操作(终端操作)终止操作的方法返回值类型就不再是Stream了，因此一旦执行终止操作，就结束整个Stream操作了。一旦执行终止操作，就执行中间操作链，最终产生结果并结束Stream。 创建Stream实例方式一：通过集合 Java8 中的 Collection 接口被扩展，提供了两个获取流的方法： default Stream stream() : 返回一个顺序流 default Stream parallelStream() : 返回一个并行流 1234567@Testpublic void test01()&#123; List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5); //JDK1.8中，Collection系列集合增加了方法 Stream&lt;Integer&gt; stream = list.stream();&#125; 方式二：通过数组 Java8 中的 Arrays 的静态方法 stream() 可以获取数组流： static Stream stream(T[] array): 返回一个流 public static IntStream stream(int[] array) public static LongStream stream(long[] array) public static DoubleStream stream(double[] array) 1234567891011@Testpublic void test02()&#123; String[] arr = &#123;&quot;hello&quot;,&quot;world&quot;&#125;; Stream&lt;String&gt; stream = Arrays.stream(arr); &#125;@Testpublic void test03()&#123; int[] arr = &#123;1,2,3,4,5&#125;; IntStream stream = Arrays.stream(arr);&#125; 方式三：通过Stream的of() 可以调用Stream类静态方法 of(), 通过显示值创建一个流。它可以接收任意数量的参数。 public static Stream of(T… values) : 返回一个流 12345@Testpublic void test04()&#123; Stream&lt;Integer&gt; stream = Stream.of(1,2,3,4,5); stream.forEach(System.out::println);&#125; 方式四：创建无限流(了解) 可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。 迭代public static Stream iterate(final T seed, final UnaryOperator f) 生成public static Stream generate(Supplier s) 123456789101112131415// 方式四：创建无限流@Testpublic void test05() &#123; // 迭代 // public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final // UnaryOperator&lt;T&gt; f) Stream&lt;Integer&gt; stream = Stream.iterate(0, x -&gt; x + 2); stream.limit(10).forEach(System.out::println); // 生成 // public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s) Stream&lt;Double&gt; stream1 = Stream.generate(Math::random); stream1.limit(10).forEach(System.out::println);&#125; 一系列中间操作多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。 1-筛选与切片 方 法 描 述 filter(Predicatep) 接收 Lambda ， 从流中排除某些元素 distinct() 筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素 limit(long maxSize) 截断流，使其元素不超过给定数量 skip(long n) 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补 2-映 射 方法 描述 map(Function f) 接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。 mapToDouble(ToDoubleFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 DoubleStream。 mapToInt(ToIntFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 IntStream。 mapToLong(ToLongFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 LongStream。 flatMap(Function f) 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流 3-排序 方法 描述 sorted() 产生一个新流，其中按自然顺序排序 sorted(Comparator com) 产生一个新流，其中按比较器顺序排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public class StreamMiddleOperate &#123; @Test public void test01()&#123; //1、创建Stream Stream&lt;Integer&gt; stream = Stream.of(1,2,3,4,5,6); //2、加工处理 //过滤：filter(Predicate p) //把里面的偶数拿出来 /* * filter(Predicate p) * Predicate是函数式接口，抽象方法：boolean test(T t) */ stream = stream.filter(t -&gt; t%2==0); //3、终结操作：例如：遍历 stream.forEach(System.out::println); &#125; @Test public void test02()&#123; Stream.of(1,2,3,4,5,6) .filter(t -&gt; t%2==0) .forEach(System.out::println); &#125; @Test public void test03()&#123; Stream.of(1,2,3,4,5,6,2,2,3,3,4,4,5) .distinct() .forEach(System.out::println); &#125; @Test public void test04()&#123; Stream.of(1,2,3,4,5,6,2,2,3,3,4,4,5) .limit(3) .forEach(System.out::println); &#125; @Test public void test05()&#123; Stream.of(1,2,2,3,3,4,4,5,2,3,4,5,6,7) .distinct() //(1,2,3,4,5,6,7) .filter(t -&gt; t%2!=0) //(1,3,5,7) .limit(3) .forEach(System.out::println); &#125; @Test public void test06()&#123; Stream.of(1,2,3,4,5,6,2,2,3,3,4,4,5) .skip(5) .forEach(System.out::println); &#125; @Test public void test07()&#123; Stream.of(1,2,3,4,5,6,2,2,3,3,4,4,5) .skip(5) .distinct() .filter(t -&gt; t%3==0) .forEach(System.out::println); &#125; @Test public void test08()&#123; long count = Stream.of(1,2,3,4,5,6,2,2,3,3,4,4,5) .distinct() .peek(System.out::println) //Consumer接口的抽象方法 void accept(T t) .count(); System.out.println(&quot;count=&quot;+count); &#125; @Test public void test09()&#123; //希望能够找出前三个最大值，前三名最大的，不重复 Stream.of(11,2,39,4,54,6,2,22,3,3,4,54,54) .distinct() .sorted((t1,t2) -&gt; -Integer.compare(t1, t2))//Comparator接口 int compare(T t1, T t2) .limit(3) .forEach(System.out::println); &#125; @Test public void test10()&#123; Stream.of(1,2,3,4,5) .map(t -&gt; t+=1)//Function&lt;T,R&gt;接口抽象方法 R apply(T t) .forEach(System.out::println); &#125; @Test public void test11()&#123; String[] arr = &#123;&quot;hello&quot;,&quot;world&quot;,&quot;java&quot;&#125;; Arrays.stream(arr) .map(t-&gt;t.toUpperCase()) .forEach(System.out::println); &#125; @Test public void test12()&#123; String[] arr = &#123;&quot;hello&quot;,&quot;world&quot;,&quot;java&quot;&#125;; Arrays.stream(arr) .flatMap(t -&gt; Stream.of(t.split(&quot;|&quot;)))//Function&lt;T,R&gt;接口抽象方法 R apply(T t) 现在的R是一个Stream .forEach(System.out::println); &#125; &#125; 终止操作 终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void 。 流进行了终止操作后，不能再次使用。 1-匹配与查找 方法 描述 allMatch(Predicate p) 检查是否匹配所有元素 anyMatch(Predicate p) 检查是否至少匹配一个元素 noneMatch(Predicate p) 检查是否没有匹配所有元素 findFirst() 返回第一个元素 findAny() 返回当前流中的任意元素 count() 返回流中元素总数 max(Comparator c) 返回流中最大值 min(Comparator c) 返回流中最小值 forEach(Consumer c) 内部迭代(使用 Collection 接口需要用户去做迭代，称为外部迭代。相反，Stream API 使用内部迭代——它帮你把迭代做了) 2-归约 方法 描述 reduce(T identity, BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。返回 T reduce(BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。返回 Optional 备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它来进行网络搜索而出名。 3-收集 方 法 描 述 collect(Collector c) 将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法 Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、Map)。 另外， Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表： 方法 返回类型 作用 toList Collector&lt;T, ?, List&gt; 把流中元素收集到List 1List&lt;Employee&gt; emps= list.stream().collect(Collectors.toList()); 方法 返回类型 作用 toSet Collector&lt;T, ?, Set&gt; 把流中元素收集到Set 1Set&lt;Employee&gt; emps= list.stream().collect(Collectors.toSet()); 方法 返回类型 作用 toCollection Collector&lt;T, ?, C&gt; 把流中元素收集到创建的集合 1Collection&lt;Employee&gt; emps =list.stream().collect(Collectors.toCollection(ArrayList::new)); 方法 返回类型 作用 counting Collector&lt;T, ?, Long&gt; 计算流中元素的个数 1long count = list.stream().collect(Collectors.counting()); 方法 返回类型 作用 summingInt Collector&lt;T, ?, Integer&gt; 对流中元素的整数属性求和 1int total=list.stream().collect(Collectors.summingInt(Employee::getSalary)); 方法 返回类型 作用 averagingInt Collector&lt;T, ?, Double&gt; 计算流中元素Integer属性的平均值 1double avg = list.stream().collect(Collectors.averagingInt(Employee::getSalary)); 方法 返回类型 作用 summarizingInt Collector&lt;T, ?, IntSummaryStatistics&gt; 收集流中Integer属性的统计值。如：平均值 1int SummaryStatisticsiss= list.stream().collect(Collectors.summarizingInt(Employee::getSalary)); 方法 返回类型 作用 joining Collector&lt;CharSequence, ?, String&gt; 连接流中每个字符串 1String str= list.stream().map(Employee::getName).collect(Collectors.joining()); 方法 返回类型 作用 maxBy Collector&lt;T, ?, Optional&gt; 根据比较器选择最大值 1Optional&lt;Emp&gt;max= list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary))); 方法 返回类型 作用 minBy Collector&lt;T, ?, Optional&gt; 根据比较器选择最小值 1Optional&lt;Emp&gt; min = list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary))); 方法 返回类型 作用 reducing Collector&lt;T, ?, Optional&gt; 从一个作为累加器的初始值开始，利用BinaryOperator与流中元素逐个结合，从而归约成单个值 1int total=list.stream().collect(Collectors.reducing(0, Employee::getSalar, Integer::sum)); 方法 返回类型 作用 collectingAndThen Collector&lt;T,A,RR&gt; 包裹另一个收集器，对其结果转换函数 1int how= list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size)); 方法 返回类型 作用 groupingBy Collector&lt;T, ?, Map&lt;K, List&gt;&gt; 根据某属性值对流分组，属性为K，结果为V 1Map&lt;Emp.Status, List&lt;Emp&gt;&gt; map= list.stream().collect(Collectors.groupingBy(Employee::getStatus)); 方法 返回类型 作用 partitioningBy Collector&lt;T, ?, Map&lt;Boolean, List&gt;&gt; 根据true或false进行分区 Java9新增API新增1：Stream实例化方法 ofNullable()的使用： Java 8 中 Stream 不能完全为null，否则会报空指针异常。而 Java 9 中的 ofNullable 方法允许我们创建一个单元素 Stream，可以包含一个非空元素，也可以创建一个空 Stream。 1234567891011121314151617181920//报NullPointerException//Stream&lt;Object&gt; stream1 = Stream.of(null);//System.out.println(stream1.count());//不报异常，允许通过Stream&lt;String&gt; stringStream = Stream.of(&quot;AA&quot;, &quot;BB&quot;, null);System.out.println(stringStream.count());//3//不报异常，允许通过List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;AA&quot;);list.add(null);System.out.println(list.stream().count());//2//ofNullable()：允许值为nullStream&lt;Object&gt; stream1 = Stream.ofNullable(null);System.out.println(stream1.count());//0Stream&lt;String&gt; stream = Stream.ofNullable(&quot;hello world&quot;);System.out.println(stream.count());//1 iterator()重载的使用： 123456//原来的控制终止方式：Stream.iterate(1,i -&gt; i + 1).limit(10).forEach(System.out::println);//现在的终止方式：Stream.iterate(1,i -&gt; i &lt; 100,i -&gt; i + 1).forEach(System.out::println); 新语法结构新的语法结构，为我们勾勒出了 Java 语法进化的一个趋势，将开发者从复杂、繁琐的低层次抽象中逐渐解放出来，以更高层次、更优雅的抽象，既降低代码量，又避免意外编程错误的出现，进而提高代码质量和开发效率。 Java的REPL工具： jShell命令利用jShell在没有创建类的情况下，在命令行里直接声明变量，计算表达式，执行语句。无需跟人解释”public static void main(String[] args)”这句”废话”。 异常处理之try-catch资源关闭在JDK7 之前，我们这样处理资源的关闭： 1234567891011121314151617181920212223242526272829@Testpublic void test01() &#123; FileWriter fw = null; BufferedWriter bw = null; try &#123; fw = new FileWriter(&quot;d:/1.txt&quot;); bw = new BufferedWriter(fw); bw.write(&quot;hello&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (bw != null) &#123; bw.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (fw != null) &#123; fw.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; JDK7的新特性 在try的后面可以增加一个()，在括号中可以声明流对象并初始化。try中的代码执行完毕，会自动把流对象释放，就不用写finally了。 格式： 1234567try(资源对象的声明和初始化)&#123; 业务逻辑代码,可能会产生异常&#125;catch(异常类型1 e)&#123; 处理异常代码&#125;catch(异常类型2 e)&#123; 处理异常代码&#125; 说明： 1、在try()中声明的资源，无论是否发生异常，无论是否处理异常，都会自动关闭资源对象，不用手动关闭了。 2、这些资源实现类必须实现AutoCloseable或Closeable接口，实现其中的close()方法。Closeable是AutoCloseable的子接口。Java7几乎把所有的“资源类”（包括文件IO的各种类、JDBC编程的Connection、Statement等接口…）都进行了改写，改写后资源类都实现了AutoCloseable或Closeable接口，并实现了close()方法。 3、写到try()中的资源类的变量默认是final声明的，不能修改。 举例： 12345678910111213141516171819202122232425262728293031323334353637//举例1@Testpublic void test02() &#123; try ( FileWriter fw = new FileWriter(&quot;d:/1.txt&quot;); BufferedWriter bw = new BufferedWriter(fw); ) &#123; bw.write(&quot;hello&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;//举例2@Testpublic void test03() &#123; //从d:/1.txt(utf-8)文件中，读取内容，写到项目根目录下1.txt(gbk)文件中 try ( FileInputStream fis = new FileInputStream(&quot;d:/1.txt&quot;); InputStreamReader isr = new InputStreamReader(fis, &quot;utf-8&quot;); BufferedReader br = new BufferedReader(isr); FileOutputStream fos = new FileOutputStream(&quot;1.txt&quot;); OutputStreamWriter osw = new OutputStreamWriter(fos, &quot;gbk&quot;); BufferedWriter bw = new BufferedWriter(osw); ) &#123; String str; while ((str = br.readLine()) != null) &#123; bw.write(str); bw.newLine(); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; JDK9的新特性 try的前面可以定义流对象，try后面的()中可以直接引用流对象的名称。在try代码执行完毕后，流对象也可以释放掉，也不用写finally了。 格式： 1234567A a = new A();B b = new B();try(a;b)&#123; 可能产生的异常代码&#125;catch(异常类名 变量名)&#123; 异常处理的逻辑&#125; 举例： 123456789101112@Testpublic void test04() &#123; InputStreamReader reader = new InputStreamReader(System.in); OutputStreamWriter writer = new OutputStreamWriter(System.out); try (reader; writer) &#123; //reader是final的，不可再被赋值 // reader = null; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 局部变量类型推断JDK 10的新特性 局部变量的显示类型声明，常常被认为是不必须的，给一个好听的名字反而可以很清楚的表达出下面应该怎样继续。本新特性允许开发人员省略通常不必要的局部变量类型声明，以增强Java语言的体验性、可读性。 使用举例 12345678910111213141516171819//1.局部变量的实例化var list = new ArrayList&lt;String&gt;();var set = new LinkedHashSet&lt;Integer&gt;();//2.增强for循环中的索引for (var v : list) &#123; System.out.println(v);&#125;//3.传统for循环中for (var i = 0; i &lt; 100; i++) &#123; System.out.println(i);&#125;//4. 返回值类型含复杂泛型结构var iterator = set.iterator();//Iterator&lt;Map.Entry&lt;Integer, Student&gt;&gt; iterator = set.iterator(); 不适用场景 声明一个成员变量 声明一个数组变量，并为数组静态初始化（省略new的情况下） 方法的返回值类型 方法的参数类型 没有初始化的方法内的局部变量声明 作为catch块中异常类型 Lambda表达式中函数式接口的类型 方法引用中函数式接口的类型 注意： var不是一个关键字，而是一个类型名，将它作为变量的类型。不能使用var作为类名。 这不是JavaScript。var并不会改变 Java是一门静态类型语言的事实。编译器负责推断出类型，并把结果写入字节码文件，就好像是开发人员自己敲入类型一样。 instanceof的模式匹配JDK14中预览特性： instanceof 模式匹配通过提供更为简便的语法，来提高生产力。有了该功能，可以减少Java程序中显式强制转换的数量，实现更精确、简洁的类型安全的代码。 Java 14之前旧写法： 123456if(obj instanceof String)&#123; String str = (String)obj; //需要强转 .. str.contains(..)..&#125;else&#123; ...&#125; Java 14新特性写法： 12345if(obj instanceof String str)&#123; .. str.contains(..)..&#125;else&#123; ...&#125; JDK15中第二次预览： 没有任何更改。 JDK16中转正特性： 在Java16中转正。 switch表达式传统switch声明语句的弊端： 匹配是自上而下的，如果忘记写break，后面的case语句不论匹配与否都会执行； —&gt;case穿透 所有的case语句共用一个块范围，在不同的case语句定义的变量名不能重复； 不能在一个case里写多个执行结果一致的条件； 整个switch不能作为表达式返回值； 1234567891011121314151617//常见错误实现switch(month)&#123; case 3|4|5://3|4|5 用了位运算符，11 | 100 | 101结果是 111是7 System.out.println(&quot;春季&quot;); break; case 6|7|8://6|7|8用了位运算符，110 | 111 | 1000结果是1111是15 System.out.println(&quot;夏季&quot;); break; case 9|10|11://9|10|11用了位运算符，1001 | 1010 | 1011结果是1011是11 System.out.println(&quot;秋季&quot;); break; case 12|1|2://12|1|2 用了位运算符，1100 | 1 | 10 结果是1111，是15 System.out.println(&quot;冬季&quot;); break; default: System.out.println(&quot;输入有误&quot;);&#125; JDK12中预览特性： Java 12将会对switch声明语句进行扩展，使用case L -&gt;来替代以前的break;，省去了 break 语句，避免了因少写 break 而出错。 同时将多个 case 合并到一行，显得简洁、清晰，也更加优雅的表达逻辑分支。 为了保持兼容性，case 条件语句中依然可以使用字符 : ，但是同一个 switch 结构里不能混用 -&gt; 和 : ，否则编译错误。 1234567891011public class SwitchTest1 &#123; public static void main(String[] args) &#123; Fruit fruit = Fruit.GRAPE; switch(fruit)&#123; case PEAR -&gt; System.out.println(4); case APPLE,MANGO,GRAPE -&gt; System.out.println(5); case ORANGE,PAPAYA -&gt; System.out.println(6); default -&gt; throw new IllegalStateException(&quot;No Such Fruit:&quot; + fruit); &#125;; &#125;&#125; 更进一步： 123456789101112public class SwitchTest2 &#123; public static void main(String[] args) &#123; Fruit fruit = Fruit.GRAPE; int numberOfLetters = switch(fruit)&#123; case PEAR -&gt; 4; case APPLE,MANGO,GRAPE -&gt; 5; case ORANGE,PAPAYA -&gt; 6; default -&gt; throw new IllegalStateException(&quot;No Such Fruit:&quot; + fruit); &#125;; System.out.println(numberOfLetters); &#125;&#125; JDK13中二次预览特性： JDK13中引入了yield语句，用于返回值。这意味着，switch表达式(返回值)应该使用yield，switch语句(不返回值)应该使用break。 yield和return的区别在于：return会直接跳出当前循环或者方法，而yield只会跳出当前switch块。 12345678910111213@Testpublic void testSwitch3() &#123; String x = &quot;3&quot;; int i = switch (x) &#123; case &quot;1&quot;: yield 1; case &quot;2&quot;: yield 2; default: yield 3; &#125;; System.out.println(i);&#125; JDK14中转正特性： 这是JDK 12和JDK 13中的预览特性，现在是正式特性了。 JDK17的预览特性：switch的模式匹配 旧写法： 12345678910111213static String formatter(Object o) &#123; String formatted = &quot;unknown&quot;; if (o instanceof Integer i) &#123; formatted = String.format(&quot;int %d&quot;, i); &#125; else if (o instanceof Long l) &#123; formatted = String.format(&quot;long %d&quot;, l); &#125; else if (o instanceof Double d) &#123; formatted = String.format(&quot;double %f&quot;, d); &#125; else if (o instanceof String s) &#123; formatted = String.format(&quot;String %s&quot;, s); &#125; return formatted;&#125; 模式匹配新写法： 123456789static String formatterPatternSwitch(Object o) &#123; return switch (o) &#123; case Integer i -&gt; String.format(&quot;int %d&quot;, i); case Long l -&gt; String.format(&quot;long %d&quot;, l); case Double d -&gt; String.format(&quot;double %f&quot;, d); case String s -&gt; String.format(&quot;String %s&quot;, s); default -&gt; o.toString(); &#125;;&#125; 直接在 switch 上支持 Object 类型，这就等于同时支持多种类型，使用模式匹配得到具体类型，大大简化了语法量，这个功能很实用。 文本块现实问题： 在Java中，通常需要使用String类型表达HTML，XML，SQL或JSON等格式的字符串，在进行字符串赋值时需要进行转义和连接操作，然后才能编译该代码，这种表达方式难以阅读并且难以维护。 JDK13的新特性 使用”””作为文本块的开始符和结束符，在其中就可以放置多行的字符串，不需要进行任何转义。因此，文本块将提高Java程序的可读性和可写性。 基本使用： 12345&quot;&quot;&quot;line1line2line3&quot;&quot;&quot; 相当于： 1&quot;line1\\nline2\\nline3\\n&quot; 或者一个连接的字符串： 123&quot;line1\\n&quot; +&quot;line2\\n&quot; +&quot;line3\\n&quot; 如果字符串末尾不需要行终止符，则结束分隔符可以放在最后一行内容上。例如： 1234&quot;&quot;&quot;line1line2line3&quot;&quot;&quot; 相当于 1&quot;line1\\nline2\\nline3&quot; 文本块可以表示空字符串，但不建议这样做，因为它需要两行源代码： 12String empty = &quot;&quot;&quot;&quot;&quot;&quot;; JDK14中二次预览特性 JDK14的版本主要增加了两个escape sequences，分别是 \\ &lt;line-terminator&gt;与\\s escape sequence。 :取消换行操作 \\s:表示一个空格 JDK15中功能转正 Record背景 早在2019年2月份，Java 语言架构师 Brian Goetz，曾写文抱怨“Java太啰嗦”或有太多的“繁文缛节”。他提到：开发人员想要创建纯数据载体类（plain data carriers）通常都必须编写大量低价值、重复的、容易出错的代码。如：构造函数、getter&#x2F;setter、equals()、hashCode()以及toString()等。 以至于很多人选择使用IDE的功能来自动生成这些代码。还有一些开发会选择使用一些第三方类库，如Lombok等来生成这些方法。 JDK14中预览特性：神说要用record，于是就有了。实现一个简单的数据载体类，为了避免编写：构造函数，访问器，equals()，hashCode () ，toString ()等，Java 14推出record。 record 是一种全新的类型，它本质上是一个 final 类，同时所有的属性都是 final 修饰，它会自动编译出 public get 、hashcode 、equals、toString、构造器等结构，减少了代码编写量。 具体来说：当你用record 声明一个类时，该类将自动拥有以下功能： 获取成员变量的简单方法，比如例题中的 name() 和 partner() 。注意区别于我们平常getter()的写法。 一个 equals 方法的实现，执行比较时会比较该类的所有成员属性。 重写 hashCode() 方法。 一个可以打印该类所有成员属性的 toString() 方法。 只有一个构造方法。 此外： 还可以在record声明的类中定义静态字段、静态方法、构造器或实例方法。 不能在record声明的类中定义实例字段；类不能声明为abstract；不能声明显式的父类等。 举例1（新写法）： 1record Point(int x, int y) &#123; &#125; JDK15中第二次预览特性 JDK16中转正特性 最终到JDK16中转正。 记录不适合哪些场景 record的设计目标是提供一种将数据建模为数据的好方法。它也不是 JavaBeans 的直接替代品，因为record的方法不符合 JavaBeans 的 get 标准。另外 JavaBeans 通常是可变的，而记录是不可变的。尽管它们的用途有点像，但记录并不会以某种方式取代 JavaBean。 密封类背景： 在 Java 中如果想让一个类不能被继承和修改，这时我们应该使用 final 关键字对类进行修饰。不过这种要么可以继承，要么不能继承的机制不够灵活，有些时候我们可能想让某个类可以被某些类型继承，但是又不能随意继承，是做不到的。Java 15 尝试解决这个问题，引入了 sealed 类，被 sealed 修饰的类可以指定子类。这样这个类就只能被指定的类继承。 JDK15的预览特性： 通过密封的类和接口来限制超类的使用，密封的类和接口限制其它可能继承或实现它们的其它类或接口。 具体使用： 使用修饰符sealed，可以将一个类声明为密封类。密封的类使用保留关键字permits列出可以直接扩展（即extends）它的类。 sealed 修饰的类的机制具有传递性，它的子类必须使用指定的关键字进行修饰，且只能是 final、sealed、non-sealed 三者之一。 JDK16二次预览特性 JDK17中转正特性 API的变化Optional 类JDK8的新特性 到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google在著名的Guava项目引入了Optional类，通过检查空值的方式避免空指针异常。受到Google的启发，Optional类已经成为Java 8类库的一部分。 Optional&lt;T&gt; 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。如果值存在，则isPresent()方法会返回true，调用get()方法会返回该对象。 Optional提供很多有用的方法，这样我们就不用显式进行空值检测。 创建Optional类对象的方法： static Optional empty() ：用来创建一个空的Optional实例 static Optional of(T value) ：用来创建一个Optional实例，value必须非空 static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value) ：用来创建一个Optional实例，value可能是空，也可能非空 判断Optional容器中是否包含对象： boolean isPresent() : 判断Optional容器中的值是否存在 void ifPresent(Consumer&lt;? super T&gt; consumer) ：判断Optional容器中的值是否存在，如果存在，就对它进行Consumer指定的操作，如果不存在就不做 获取Optional容器的对象： T get(): 如果调用对象包含值，返回该值。否则抛异常。T get()与of(T value)配合使用 T orElse(T other) ：orElse(T other) 与ofNullable(T value)配合使用，如果Optional容器中非空，就返回所包装值，如果为空，就用orElse(T other)other指定的默认值（备胎）代替 T orElseGet(Supplier&lt;? extends T&gt; other) ：如果Optional容器中非空，就返回所包装值，如果为空，就用Supplier接口的Lambda表达式提供的值代替 T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) ：如果Optional容器中非空，就返回所包装值，如果为空，就抛出你指定的异常类型代替原来的NoSuchElementException 这是JDK9-11的新特性 新增方法 描述 新增的版本 boolean isEmpty() 判断value是否为空 JDK 11 ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction) value非空，执行参数1功能；如果value为空，执行参数2功能 JDK 9 Optional or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier) value非空，返回对应的Optional；value为空，返回形参封装的Optional JDK 9 Stream stream() value非空，返回仅包含此value的Stream；否则，返回一个空的Stream JDK 9 T orElseThrow() value非空，返回value；否则抛异常NoSuchElementException JDK 10 String存储结构和API变更这是JDK9的新特性。 产生背景： MotivationThe current implementation of the String class stores characters in a char array, using two bytes (sixteen bits) for each character. Data gathered from many different applications indicates that strings are a major component of heap usage and, moreover, that most String objects contain only Latin-1 characters. Such characters require only one byte of storage, hence half of the space in the internal char arrays of such String objects is going unused. 使用说明： DescriptionWe propose to change the internal representation of the String class from a UTF-16 char array to a byte array plus an encoding-flag field. The new String class will store characters encoded either as ISO-8859-1&#x2F;Latin-1 (one byte per character), or as UTF-16 (two bytes per character), based upon the contents of the string. The encoding flag will indicate which encoding is used. 结论：String 再也不用 char[] 来存储啦，改成了 byte[] 加上编码标记，节约了一些空间。 123456public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; @Stable private final byte[] value; ...&#125; 拓展：StringBuffer 与 StringBuilder 那StringBuffer 和 StringBuilder 是否仍无动于衷呢？ String-related classes such as AbstractStringBuilder, StringBuilder, and StringBuffer will be updated to use the same representation, as will the HotSpot VM’s intrinsic string operations. JDK11新特性：新增了一系列字符串处理方法 描述 举例 判断字符串是否为空白 “ “.isBlank(); &#x2F;&#x2F; true 去除首尾空白 “ Javastack “.strip(); &#x2F;&#x2F; “Javastack” 去除尾部空格 “ Javastack “.stripTrailing(); &#x2F;&#x2F; “ Javastack” 去除首部空格 “ Javastack “.stripLeading(); &#x2F;&#x2F; “Javastack “ 复制字符串 “Java”.repeat(3);&#x2F;&#x2F; “JavaJavaJava” 行数统计 “A\\nB\\nC”.lines().count(); &#x2F;&#x2F; 3 JDK12新特性：String 实现了 Constable 接口 String源码： 1public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence,Constable, ConstantDesc &#123; java.lang.constant.Constable接口定义了抽象方法： 123public interface Constable &#123; Optional&lt;? extends ConstantDesc&gt; describeConstable();&#125; Java 12 String 的实现源码： 1234567891011/** * Returns an &#123;@link Optional&#125; containing the nominal descriptor for this * instance, which is the instance itself. * * @return an &#123;@link Optional&#125; describing the &#123;@linkplain String&#125; instance * @since 12 */@Overridepublic Optional&lt;String&gt; describeConstable() &#123; return Optional.of(this);&#125; 很简单，其实就是调用 Optional.of 方法返回一个 Optional 类型。 举例： 12345private static void testDescribeConstable() &#123; String name = &quot;尚硅谷Java高级工程师&quot;; Optional&lt;String&gt; optional = name.describeConstable(); System.out.println(optional.get());&#125; 结果输出： 1尚硅谷Java高级工程师 JDK12新特性：String新增方法 String的transform(Function) 12var result = &quot;foo&quot;.transform(input -&gt; input + &quot; bar&quot;);System.out.println(result); //foo bar 或者 12var result = &quot;foo&quot;.transform(input -&gt; input + &quot; bar&quot;).transform(String::toUpperCase)System.out.println(result); //FOO BAR 对应的源码： 123456789/*** This method allows the application of a function to &#123;@code this&#125;* string. The function should expect a single String argument* and produce an &#123;@code R&#125; result.* @since 12*/public &lt;R&gt; R transform(Function&lt;? super String, ? extends R&gt; f) &#123; return f.apply(this);&#125; 在某种情况下，该方法应该被称为map()。 举例： 12345678910private static void testTransform() &#123; System.out.println(&quot;======test java 12 transform======&quot;); List&lt;String&gt; list1 = List.of(&quot;Java&quot;, &quot; Python&quot;, &quot; C++ &quot;); List&lt;String&gt; list2 = new ArrayList&lt;&gt;(); list1.forEach(element -&gt; list2.add(element.transform(String::strip) .transform(String::toUpperCase) .transform((e) -&gt; &quot;Hi,&quot; + e)) ); list2.forEach(System.out::println);&#125; 结果输出： 1234======test java 12 transform======Hi,JAVAHi,PYTHONHi,C++ 如果使用Java 8的Stream特性，可以如下实现： 12345678private static void testTransform1() &#123; System.out.println(&quot;======test before java 12 ======&quot;); List&lt;String&gt; list1 = List.of(&quot;Java &quot;, &quot; Python&quot;, &quot; C++ &quot;); Stream&lt;String&gt; stringStream = list1.stream().map(element -&gt; element.strip()).map(String::toUpperCase).map(element -&gt; &quot;Hello,&quot; + element); List&lt;String&gt; list2 = stringStream.collect(Collectors.toList()); list2.forEach(System.out::println); &#125; JDK17：标记删除Applet APIApplet API 提供了一种将 Java AWT&#x2F;Swing 控件嵌入到浏览器网页中的方法。不过，目前 Applet 已经被淘汰。大部分人可能压根就没有用过 Applet。 Applet API 实际上是无用的，因为所有 Web 浏览器供应商都已删除或透露计划放弃对 Java 浏览器插件的支持。Java 9 的时候，Applet API 已经被标记为过时，Java 17 的时候终于标记为删除了。 具体如下： 123456java.applet.Appletjava.applet.AppletStubjava.applet.AppletContextjava.applet.AudioClipjavax.swing.JAppletjava.beans.AppletInitializer 其它结构变化JDK9：UnderScore(下划线)使用的限制在java 8 中，标识符可以独立使用“_”来命名： 12String _ = &quot;hello&quot;;System.out.println(_); 但是，在java 9 中规定“_”不再可以单独命名标识符了，如果使用，会报错 JDK11：更简化的编译运行程序看下面的代码。 12345// 编译javac JavaStack.java// 运行java JavaStack 我们的认知里，要运行一个 Java 源代码必须先编译，再运行。而在 Java 11 版本中，通过一个 java 命令就直接搞定了，如下所示： 1java JavaStack.java 注意点： 执行源文件中的第一个类，第一个类必须包含主方法。 GC方面新特性GC是Java主要优势之一。 然而，当GC停顿太长，就会开始影响应用的响应时间。随着现代系统中内存不断增长，用户和程序员希望JVM能够以高效的方式充分利用这些内存， 并且无需长时间的GC暂停时间。 G1 GCJDK9以后默认的垃圾回收器是G1GC。 JDK10 : 为G1提供并行的Full GC G1最大的亮点就是可以尽量的避免full gc。但毕竟是“尽量”，在有些情况下，G1就要进行full gc了，比如如果它无法足够快的回收内存的时候，它就会强制停止所有的应用线程然后清理。 在Java10之前，一个单线程版的标记-清除-压缩算法被用于full gc。为了尽量减少full gc带来的影响，在Java10中，就把之前的那个单线程版的标记-清除-压缩的full gc算法改成了支持多个线程同时full gc。这样也算是减少了full gc所带来的停顿，从而提高性能。 你可以通过-XX:ParallelGCThreads参数来指定用于并行GC的线程数。 JDK12：可中断的 G1 Mixed GC JDK12：增强G1，自动返回未用堆内存给操作系统 Shenandoah GCJDK12：Shenandoah GC：低停顿时间的GC Shenandoah 垃圾回收器是 Red Hat 在 2014 年宣布进行的一项垃圾收集器研究项目 Pauseless GC 的实现，旨在针对 JVM 上的内存收回实现低停顿的需求。 据 Red Hat 研发 Shenandoah 团队对外宣称，Shenandoah 垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为 200 MB 还是 200 GB，都将拥有一致的系统暂停时间，不过实际使用性能将取决于实际工作堆的大小和工作负载。 Shenandoah GC 主要目标是 99.9% 的暂停小于 10ms，暂停与堆大小无关等。 这是一个实验性功能，不包含在默认（Oracle）的OpenJDK版本中。 Shenandoah开发团队在实际应用中的测试数据： JDK15：Shenandoah垃圾回收算法转正 Shenandoah垃圾回收算法终于从实验特性转变为产品特性，这是一个从 JDK 12 引入的回收算法，该算法通过与正在运行的 Java 线程同时进行疏散工作来减少 GC 暂停时间。Shenandoah 的暂停时间与堆大小无关，无论堆栈是 200 MB 还是 200 GB，都具有相同的一致暂停时间。 Shenandoah在JDK12被作为experimental引入，在JDK15变为Production；之前需要通过-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC来启用，现在只需要-XX:+UseShenandoahGC即可启用 革命性的 ZGCJDK11：引入革命性的 ZGC ZGC，这应该是JDK11最为瞩目的特性，没有之一。 ZGC是一个并发、基于region、压缩型的垃圾收集器。 ZGC的设计目标是：支持TB级内存容量，暂停时间低（&lt;10ms），对整个程序吞吐量的影响小于15%。 将来还可以扩展实现机制，以支持不少令人兴奋的功能，例如多层堆（即热对象置于DRAM和冷对象置于NVMe闪存），或压缩堆。 JDK13：ZGC:将未使用的堆内存归还给操作系统 JDK14：ZGC on macOS和windows JDK14之前，ZGC仅Linux才支持。现在mac或Windows上也能使用ZGC了，示例如下： 1-XX:+UnlockExperimentalVMOptions -XX:+UseZGC ZGC与Shenandoah目标高度相似，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。 JDK15：ZGC 功能转正 ZGC是Java 11引入的新的垃圾收集器，经过了多个实验阶段，自此终于成为正式特性。 但是这并不是替换默认的GC，默认的GC仍然还是G1；之前需要通过-XX:+UnlockExperimentalVMOptions、 -XX:+UseZGC来启用ZGC，现在只需要-XX:+UseZGC就可以。相信不久的将来它必将成为默认的垃圾回收器。 ZGC的性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。未来将成为服务端、大内存、低延迟应用的首选垃圾收集器。 怎么形容Shenandoah和ZGC的关系呢？异同点大概如下： 相同点：性能几乎可认为是相同的 不同点：ZGC是Oracle JDK的，根正苗红。而Shenandoah只存在于OpenJDK中，因此使用时需注意你的JDK版本 JDK16：ZGC 并发线程处理 在线程的堆栈处理过程中，总有一个制约因素就是safepoints。在safepoints这个点，Java的线程是要暂停执行的，从而限制了GC的效率。 回顾： 我们都知道，在之前，需要 GC 的时候，为了进行垃圾回收，需要所有的线程都暂停下来，这个暂停的时间我们称为 Stop The World。 而为了实现 STW 这个操作， JVM 需要为每个线程选择一个点停止运行，这个点就叫做安全点（Safepoints）。 而ZGC的并发线程堆栈处理可以保证Java线程可以在GC safepoints的同时可以并发执行。它有助于提高所开发的Java软件应用程序的性能和效率。 企业真题（十八）1. JDK新特性的概述 几个重要的版本 jdk 5.0 &#x2F; jdk 8.0 ：里程碑式的版本 jdk9.0 开始每6个月发布一个新的版本 LTS : jdk8 、 jdk 11 、 jdk 17 如何学习新特性 1234567&gt; 角度1：新的语法规则 （多关注） 自动装箱、自动拆箱、注解、enum、Lambda表达式、方法引用、switch表达式、try-catch变化、record等&gt; 角度2：增加、过时、删除API StringBuilder、ArrayList、新的日期时间的API、Optional等&gt; 角度3：底层的优化、JVM参数的调整、GC的变化、内存结构（永久代---&gt;元空间） 2. JDK8:lambda表达式2.1 什么情况下可以使用lambda表达式 在给函数式接口提供实例时，都可以考虑使用lambda表达式。 基本语法的使用（重要） 2.2 函数式接口 常见的函数式接口。Comparator \\ Runnable \\ java.util.function下定义的丰富的函数式接口 1234消费型接口：Consumer&lt;T&gt; void accept(T t)供给型接口：Supplier&lt;T&gt; T get()函数型接口：Function&lt;T,R&gt; R apply(T t)判断型接口：Predicate&lt;T&gt; boolean test(T t) 2.3 方法引用、构造器引用、数组引用 方法引用、构造器引用、数组引用：看做是lambda表达式的进一步刻画、表达。 （掌握）方法引用、构造器引用、数组引用的使用场景。 3. JDK8:Stream API的使用 Stream关注于内存中的多个数据的运算。 使用步骤：① Stream 的实例化 ② 一系列的中间操作 ③ 终止操作 4. JDK8之后的新特性：语法层面 jShell工具 try-catch结构的变化。try(…){ } 局部变量的类型推断：var instanceof的模式匹配 switch表达式、switch的模式匹配 文本块的使用：”””文本块””” 新的引用数据类型：record (记录) 密封类：sealed class 5. JDK8之后的新特性：其它 Optional类的使用 其他：了解 二、企业真题JDK8新特性1. 谈谈java8新特性(京*旗下、时代*宇，信必*、招*信诺，中*外包，金*软件、阿**巴)123类似问题&gt; JDK1.8相较于JDK1.7有什么不一样？（惠*）&gt; JDK1.8的新特性有哪些？Stream API + Lambda表达式，还有吗？（久*国际物流） lambda表达式、Stream API jdk7的对比：元空间、HashMap、新的日期时间API、接口变化等。 2. JDK1.8在数据结构上发生了哪些变化 ？（银*数据） 使用元空间替代永久代。 （方法区：jvm规范中提到的结构。 HotSpot来讲，jdk7：方法区的落地体现：永久代。 jdk8：方法区的落地体现：元空间。 HashMap底层结构 3. 你说的了解 Java的新特性 ，你说说JDK8改进的地方？（银*科技）略 4. JDK1.8用的是哪个垃圾回收器？（O**O）Parallel GC –&gt; jdk9：默认使用G1GC –&gt; ZGC （低延迟） Lambda表达式1. Lambda表达式有了解吗，说说如何使用的（O**O）12类似问题：&gt; Lambda的理解（国*） 略 2. 什么是函数式接口？有几种函数式接口（阿**巴）略。 java.util.function包下定义了丰富的好函数式接口。有4类基础的函数式接口： 消费型接口：Consumer void accept(T t)供给型接口：Supplier T get()函数型接口：Function&lt;T,R&gt; R apply(T t)判断型接口：Predicate boolean test(T t) Stream API1. 创建Stream的方式（阿**巴）三种。 2. 你讲讲stream表达式是咋用的，干啥的？（中*国际，上海**网络）123&gt; Stream API 关注的是多个数据的计算（排序、查找、过滤、映射、遍历等），面向CPU的。 集合关注的数据的存储，面向内存的。&gt; Stream API 之于集合，类似于SQL之于数据表的查询。 3. 集合用Stream流怎么实现过滤？（润*软件）filter(Predicate predicate) 4. 用Stream怎么选出List里想要的数据？（惠*）略 其它版本新特性1. 说说JDK15、JDK16、JDK17中的新特性都有什么？(银*数据)略 IDEA的日常快捷键和Debug第1组：通用型 说明 快捷键 复制代码-copy ctrl + c 粘贴-paste ctrl + v 剪切-cut ctrl + x 撤销-undo ctrl + z 反撤销-redo ctrl + shift + z 保存-save all ctrl + s 全选-select all ctrl + a 第2组：提高编写速度（上） 说明 快捷键 智能提示-edit alt + enter 提示代码模板-insert live template ctrl+j 使用xx块环绕-surround with … ctrl+alt+t 调出生成getter&#x2F;setter&#x2F;构造器等结构-generate … alt+insert 自动生成返回值变量-introduce variable … ctrl+alt+v 复制指定行的代码-duplicate line or selection ctrl+d 删除指定行的代码-delete line ctrl+y 切换到下一行代码空位-start new line shift + enter 切换到上一行代码空位-start new line before current ctrl +alt+ enter 向上移动代码-move statement up ctrl+shift+↑ 向下移动代码-move statement down ctrl+shift+↓ 向上移动一行-move line up alt+shift+↑ 向下移动一行-move line down alt+shift+↓ 方法的形参列表提醒-parameter info ctrl+p 第3组：提高编写速度（下） 说明 快捷键 批量修改指定的变量名、方法名、类名等-rename shift+f6 抽取代码重构方法-extract method … ctrl+alt+m 重写父类的方法-override methods … ctrl+o 实现接口的方法-implements methods … ctrl+i 选中的结构的大小写的切换-toggle case ctrl+shift+u 批量导包-optimize imports ctrl+alt+o 第4组：类结构、查找和查看源码 说明 快捷键 如何查看源码-go to class… ctrl + 选中指定的结构 或 ctrl+n 显示当前类结构，支持搜索指定的方法、属性等-file structure ctrl+f12 退回到前一个编辑的页面-back ctrl+alt+← 进入到下一个编辑的页面-forward ctrl+alt+→ 打开的类文件之间切换-select previous&#x2F;next tab alt+←&#x2F;→ 光标选中指定的类，查看继承树结构-Type Hierarchy ctrl+h 查看方法文档-quick documentation ctrl+q 类的UML关系图-show uml popup ctrl+alt+u 定位某行-go to line&#x2F;column ctrl+g 回溯变量或方法的来源-go to implementation(s) ctrl+alt+b 折叠方法实现-collapse all ctrl+shift+ - 展开方法实现-expand all ctrl+shift+ + 第5组：查找、替换与关闭 说明 快捷键 查找指定的结构 ctlr+f 快速查找：选中的Word快速定位到下一个-find next ctrl+l 查找与替换-replace ctrl+r 直接定位到当前行的首位-move caret to line start home 直接定位到当前行的末位 -move caret to line end end 查询当前元素在当前文件中的引用，然后按 F3 可以选择 ctrl+f7 全项目搜索文本-find in path … ctrl+shift+f 关闭当前窗口-close ctrl+f4 第6组：调整格式 说明 快捷键 格式化代码-reformat code ctrl+alt+l 使用单行注释-comment with line comment ctrl + &#x2F; 使用&#x2F;取消多行注释-comment with block comment ctrl + shift + &#x2F; 选中数行，整体往后移动-tab tab 选中数行，整体往前移动-prev tab shift + tab Debug快捷键 说明 快捷键 单步调试（不进入函数内部）- step over F8 单步调试（进入函数内部）- step into F7 强制单步调试（进入函数内部） - force step into alt+shift+f7 选择要进入的函数 - smart step into shift + F7 跳出函数 - step out shift + F8 运行到断点 - run to cursor alt + F9 继续执行，进入下一个断点或执行完程序 - resume program F9 停止 - stop Ctrl+F2 查看断点 - view breakpoints Ctrl+Shift+F8 关闭 - close Ctrl+F4","tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"offer---JUC","date":"2023-04-10T10:30:06.000Z","path":"2023/04/10/offer-JUC/","text":"JAVA并发编程—JUC-基础篇 (java.util.concurrent)JUC概述 进程与线程的区别 线程的状态（New新建，Runnable准备就绪，Blocked阻塞，Waiting不见不散，Timed_waiting过时不候） wait和sleep的区别： sleep是Thread的静态方法，wait是Object的方法，任何对象实例都能调用。 sleep不会释放锁，它也不需要占用锁。wait会释放锁，但调用它的前提是当前线程占有锁（即代码要在synchronized中）。 它们都可以被interrupted方法中断。 并发和并行的区别：同一时刻多个线程在访问同一个资源，多个线程对一个点（春运抢票）；多项工作一起执行，之后再汇总（泡面的例子）。 管程、用户线程和守护线程 管程Monitor监视器，锁，是一种同步机制，保证同一个时间，只有一个线程访问被保护数据或者代码。JVM同步基于进入和退出，使用管程对象实现的。 用户线程和守护线程 用户线程：自定义线程（主线程结束了，用户线程还在运行，JVM存活） 守护线程：默默执行在后台的线程，比如垃圾回收（没有用户线程了，都是守护线程，JVM结束） Lock接口Synchronized关键字同步锁。 修饰一个代码块； 修饰一个方法； 修饰一个静态方法； 修改一个类。 多线程编程的步骤：1. 创建资源类，在资源类中创建属性和操作方法；2. 在资源类操作方法，判断，干活，通知；3. 创建多个线程，调用资源类的操作方法； 卖票示例： 123456789101112131415161718192021222324252627282930313233343536373839404142class Ticket &#123; private int number = 30; public synchronized void sale()&#123; if (number &gt; 0)&#123; System.out.println(Thread.currentThread().getName() + &quot;: 卖出 :&quot; + (number--) + &quot;剩下:&quot; + number); &#125; &#125;&#125;public class SaleTicket &#123; public static void main(String[] args) &#123; Ticket ticket = new Ticket(); new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 40; i++) &#123; ticket.sale(); &#125; &#125; &#125;,&quot;aa&quot;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 40; i++) &#123; ticket.sale(); &#125; &#125; &#125;,&quot;bb&quot;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 40; i++) &#123; ticket.sale(); &#125; &#125; &#125;,&quot;cc&quot;).start(); &#125;&#125; 什么是Lock接口手动实现上锁、释放锁。 可重入锁 123456789101112131415161718192021class LockTicket &#123; private int number = 30; //创建可重入锁 private final ReentrantLock lock = new ReentrantLock(); public void sale() &#123; //上锁 lock.lock(); try &#123; if (number &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + &quot;: 卖出 :&quot; + (number--) + &quot;剩下:&quot; + number); &#125; &#125;finally &#123; //解锁 lock.unlock(); &#125; &#125;&#125; Lock和synchronized的不同： Lock是一个接口，而synchronized是Java中的关键字； synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unlock()去释放锁，则很可能造成死锁现象，这也是为什么需要在finally块中释放锁； Lock可以让等待锁的线程响应中断，而synchronized缺不行，等待的线程会一直等待下去，不能够响应中断； 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到； Lock可以提高多个线程进行读操作的效率。 进程间通信 判断； 干活； 通知； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Share &#123; private int number = 0; public synchronized void incr() throws InterruptedException &#123; //判断 if改成while if (number != 0)&#123; this.wait(); &#125; number++; System.out.println(Thread.currentThread().getName()+ &quot;:&quot; +number); //通知其他线程 this.notifyAll(); &#125; public synchronized void decr() throws InterruptedException &#123; //判断 if (number != 1)&#123; this.wait(); &#125; number--; System.out.println(Thread.currentThread().getName()+ &quot;:&quot; +number); //通知其他线程 this.notifyAll(); &#125;&#125;public class ThreadTest &#123; public static void main(String[] args) &#123; Share share = new Share(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; share.incr(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,&quot;INCR&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; share.decr(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,&quot;DECR&quot;).start(); &#125;&#125; 虚假唤醒问题：wait()方法特点，在哪里睡，在哪里醒，就会导致if判断失效。所以解决方法是把if改成while。 Lock实现： 12345678910111213141516171819202122232425262728293031323334class LockShare&#123; private int number = 0; private final ReentrantLock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); public void incr() throws InterruptedException &#123; lock.lock(); try &#123; while (number!=0)&#123; condition.await(); &#125; number++; System.out.println(Thread.currentThread().getName()+ &quot;:&quot; +number); condition.signalAll(); &#125;finally &#123; lock.unlock(); &#125; &#125; public void decr() throws InterruptedException &#123; lock.lock(); try &#123; while (number!=1)&#123; condition.await(); &#125; number--; System.out.println(Thread.currentThread().getName()+ &quot;:&quot; +number); condition.signalAll(); &#125;finally &#123; lock.unlock(); &#125; &#125;&#125; 进程间定制化通信：启动三个线程，按照“AA打印5次，BB打印10次，CC打印15次”进行十轮 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283class CustomShare&#123; private int flag = 1; private Lock lock = new ReentrantLock(); private Condition conditionA = lock.newCondition(); public void print5(int loop) throws InterruptedException &#123; lock.lock(); try &#123; while (flag != 1) &#123; conditionA.await(); &#125; for (int i = 0; i &lt; 5 ; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (i+1) + &quot;:轮数:&quot; + loop); &#125; flag = 2; conditionA.signal(); &#125;finally &#123; lock.unlock(); &#125; &#125; public void print10(int loop) throws InterruptedException &#123; lock.lock(); try &#123; while (flag != 2) &#123; conditionA.await(); &#125; for (int i = 0; i &lt; 10 ; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (i+1) + &quot;:轮数:&quot; + loop); &#125; flag = 3; conditionA.signal(); &#125;finally &#123; lock.unlock(); &#125; &#125; public void print15(int loop) throws InterruptedException &#123; lock.lock(); try &#123; while (flag != 3) &#123; conditionA.await(); &#125; for (int i = 0; i &lt; 15 ; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (i+1) + &quot;:轮数:&quot; + loop); &#125; flag = 1; conditionA.signal(); &#125;finally &#123; lock.unlock(); &#125; &#125;&#125;public class LockCustomThread &#123; public static void main(String[] args) &#123; CustomShare customShare = new CustomShare(); new Thread(()-&gt;&#123; try &#123; customShare.print5(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;,&quot;AA&quot;).start(); new Thread(()-&gt;&#123; try &#123; customShare.print10(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;,&quot;BB&quot;).start(); new Thread(()-&gt;&#123; try &#123; customShare.print15(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;,&quot;CC&quot;).start(); &#125;&#125; 集合线程安全 List 示例： 12345678910111213public class ListThread &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; new Thread(()-&gt;&#123; list.add(UUID.randomUUID().toString().substring(0,8)); // 报错位置 System.out.println(list); &#125;,String.valueOf(i)).start(); &#125; &#125;&#125; 报异常：java.util.ConcurrentModificationException 原因是List.add()方法没有synchronized关键字修饰 解决方案（一）：vector List list &#x3D; new Vector&lt;&gt;(); &#x2F;&#x2F; JDK 1.0 Vector类中的方法有synchronized关键字修饰 解决方案（二）：Collection工具类 List list &#x3D; Collections.synchronizedList(new ArrayList&lt;&gt;()); &#x2F;&#x2F; Collections.synchronizedList返回同步列表 解决方案（三）：CopyOnWriteArrayList List list &#x3D; new CopyOnWriteArrayList(); &#x2F;&#x2F; 写时复制技术，并发读、复制一份新内容，独立写 12345678910111213141516 public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125;&#125; HashSet解决方案：CopyOnWriteArraySet HashMap解决方案：ConcurrentHashMap 多线程锁锁的范围案例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 对应8class Phone &#123; public static synchronized void sendSMS() throws Exception &#123; TimeUnit.SECONDS.sleep(4); System.out.println(&quot;====endSMS&quot;); &#125; public synchronized void sendEmail() throws Exception &#123; System.out.println(&quot;====endEmail&quot;); &#125; public void getHello() &#123; System.out.println(&quot;====getHello&quot;); &#125;&#125;public class EmailSMSThread &#123; public static void main(String[] args) throws InterruptedException &#123; Phone phone1 = new Phone(); Phone phone2 = new Phone(); new Thread(()-&gt;&#123; try &#123; phone1.sendSMS();; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;,&quot;AA&quot;).start(); Thread.sleep(100); new Thread(()-&gt;&#123; try &#123; phone2.sendEmail(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;,&quot;BB&quot;).start(); &#125;&#125;/*** 8锁1. 标准访问，先打印短信还是邮件；====endSMS====endEmail2. 停4秒在短信方法内，先打印短信还是邮件；====endSMS====endEmail3. 新增普通的hello方法，先打印短信还是hello；====getHello====endSMS4. 现在有两部手机，先打短信还是邮件；====endEmail====endSMS5. 两个静态同步方法，一部手机，先打印短信还是邮件；====endSMS====endEmail6. 两个静态同步方法，两部手机，先打印短信还是邮件；====endSMS====endEmail7. 一个静态同步方法，一个普通同步方法，一部手机，先打印短信还是邮件；====endEmail====endSMS8. 一个静态同步方法，一个普通同步方法，两部手机，先打印短信还是邮件；====endEmail====endSMS*/ 1、2锁的是当前对象；3新增的普通方法与锁无关，所以先执行；4有两个对象，两把锁，各锁各的；5、6锁的范围是类Class；7、8一个锁的是对象，一个锁的是类。 总结：synchronized实现同步的基础是Java中的每一个对象都可以作为锁。 对于普通同步方法，锁是当前实例对象。 对于静态同步方法，锁是当前类的Class对象。 对于同步方法块，锁是Synchronized括号里配置的对象。 公平锁和非公平锁卖票案例中，三个线程，可能只有一个线程卖了全部的票，导致其他线程饿死，这是非公平锁的情况。 非公平锁：线程饿死、效率高； 公平锁：阳光普照、效率相对低。 可重入锁 又叫递归锁，synchronized（隐式）和Lock（显式）都是可重入锁（一把锁可进入各个区域）。 12345678910111213141516171819202122232425public class SyncLock &#123; public synchronized void add()&#123; add(); &#125; public static void main(String[] args) &#123; Object o = new Object(); new Thread(()-&gt;&#123; synchronized (o)&#123; System.out.println(Thread.currentThread().getName()+&quot;外层&quot;); synchronized (o)&#123; System.out.println(Thread.currentThread().getName()+&quot;中层&quot;); synchronized (o)&#123; System.out.println(Thread.currentThread().getName()+&quot;内层&quot;); &#125; &#125; &#125; &#125;,&quot;AA&quot;).start(); &#125;&#125;// 输出: 外层、中层、内层 死锁 两个或者两个以上进程在执行过程中，因为争夺资源而造成一种互相等待的现象。如果没有外力干涉，它们无法再执行下去。 原因：1. 系统资源不足 2. 进程运行推进顺序不合适 3. 资源分配不当 12345678910111213141516171819202122232425public class DeadLock &#123; static Object a = new Object(); static Object b = new Object(); public static void main(String[] args) &#123; new Thread(()-&gt;&#123; synchronized (a)&#123; System.out.println(Thread.currentThread().getName()+&quot;持有锁a，试图获取锁b&quot;); synchronized (b)&#123; System.out.println(Thread.currentThread().getName()+&quot;持有锁b&quot;); &#125; &#125; &#125;,&quot;A&quot;).start(); new Thread(()-&gt;&#123; synchronized (b)&#123; System.out.println(Thread.currentThread().getName()+&quot;持有锁b，试图获取锁a&quot;); synchronized (a)&#123; System.out.println(Thread.currentThread().getName()+&quot;持有锁a&quot;); &#125; &#125; &#125;,&quot;B&quot;).start(); &#125;&#125; 验证是否是死锁 jps -l类似linux ps -ef；先获取当前运行程序的进程号 jstack jvm自带的堆栈跟踪工具，根据进程号查询。 Callable接口创建线程的多种方式 继承Thread类； 实现Runnable接口； 实现Callable接口； 线程池的方式。 Runnable和Callable接口的区别（1）是否有返回值：无；有（2）是否抛出异常：无；有（3）实现方法名称：run()；call() 1234567891011121314151617181920212223242526272829303132333435363738394041class MyThread1 implements Runnable&#123; @Override public void run() &#123; &#125;&#125;class MyThread2 implements Callable &#123; @Override public Integer call() throws Exception &#123; System.out.println(Thread.currentThread().getName() + &quot;come in callable&quot;); return 20; &#125;&#125;public class CallableDemo &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; // Runnable接口创建 new Thread(new MyThread1(),&quot;AA&quot;).start(); // Callable接口，报错 // new Thread(new MyThread2(),&quot;BB&quot;).start(); // FutureTask：一个可取消的异步计算 FutureTask&lt;Integer&gt; futureTask1 = new FutureTask&lt;&gt;(new MyThread2()); FutureTask&lt;Integer&gt; futureTask2 = new FutureTask&lt;&gt;(()-&gt;&#123; System.out.println(Thread.currentThread().getName() + &quot;come in callable&quot;); return 1024; &#125;); //创建一个线程 new Thread(futureTask1,&quot;jack&quot;).start(); new Thread(futureTask2,&quot;lucy&quot;).start(); System.out.println(futureTask1.get()); System.out.println(futureTask2.get()); &#125;&#125; 辅助类CountDownLatch 减法计数器；countDown()用来减一，该线程不会阻塞；当一个或多个线程调用await()方法时，这些线程会阻塞；当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行。 示例： 1234567891011121314151617 class CountDownDemo &#123; // 六个同学陆续离开教室之后，班长才可以锁门 public static void main(String[] args) throws InterruptedException &#123; CountDownLatch countDownLatch =new CountDownLatch(6); for (int i = 1; i &lt;= 6; i++) &#123; new Thread(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+&quot; 同学离开了教室&quot;); countDownLatch.countDown(); &#125;,String.valueOf(i)).start(); &#125; countDownLatch.await(); System.out.println(Thread.currentThread().getName()+&quot;班长锁门走人了&quot;); &#125;&#125; CyclicBarrier 循环栅栏，加法计数器 示例： 12345678910111213141516171819202122232425public class CyclicBarrierDemo &#123; //创建固定值 public static final int NUMBER = 7; public static void main(String[] args) &#123; CyclicBarrier cyclicBarrier = new CyclicBarrier(NUMBER,()-&gt;&#123; System.out.println(&quot;集齐7颗，召唤神龙&quot;); &#125;); for (int i = 1; i &lt;= 7; i++) &#123; new Thread(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+&quot;星龙被收集了&quot;); //等待 try &#123; cyclicBarrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;,String.valueOf(i)).start(); &#125; &#125;&#125; Semaphore 计数信号量；信号量维护了一个许可集，如有必要，在许可可用前会阻塞每一个acquire()，然后再获取该许可。每个release()添加一个许可，从而可能释放一个正在阻塞的获取者。一个场景就是控制并发量。 示例： 12345678910111213141516171819202122232425262728public class SemaphoreDemo &#123; // 6辆车，停3个车位 public static void main(String[] args) &#123; //创建Semaphore，设置许可数量 Semaphore semaphore = new Semaphore(3); // 6辆车 for (int i = 1; i &lt;= 6; i++) &#123; new Thread(()-&gt;&#123; try &#123; //抢占 semaphore.acquire(); System.out.println(Thread.currentThread().getName() + &quot;抢到了车位&quot;); //设置随机停车时间 TimeUnit.SECONDS.sleep(new Random().nextInt(5)); System.out.println(Thread.currentThread().getName() + &quot;离开了车位&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; //释放 semaphore.release(); &#125; &#125;,String.valueOf(i)).start(); &#125; &#125;&#125; 读写锁悲观锁和乐观锁悲观锁：不支持并发操作，频繁地上锁、释放锁，效率低。乐观锁：支持并发，版本号控制，适用于多读的应用类型，这样可以提高吞吐量。 乐观锁的缺点： ABA 问题 如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 “ABA”问题。 JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。 循环时间长开销大 自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。 只能保证一个共享变量的原子操作 CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。 表锁和行锁 行锁（Row Lock）： a. 锁定范围： 行锁是对表中的一行数据进行锁定，而不是锁定整个表。这意味着其他事务仍然可以访问表中的其他行，不受锁定行的影响。 b. 适用场景： 适用于高并发读写的情况，允许多个事务同时访问表的不同行，降低了锁的争用。 表锁（Table Lock）： a. 锁定范围： 表锁是对整个表进行锁定，当一个事务获取了对表的锁时，其他事务无法同时访问该表，即使它们要访问的是不同的行。 b. 适用场景： 适用于需要保证整个表的一致性的场景，例如在对整个表进行大批量更新或者维护操作时。 粒度： a. 行锁： 锁定的粒度更细，只影响到实际需要修改的行，不会对表的其他部分产生影响。 b. 表锁： 锁定的粒度更大，会阻塞对整个表的访问，可能导致并发性能下降。 性能： a. 行锁： 在高并发读写的场景中性能较好，因为允许多个事务同时访问表的不同行。 b. 表锁： 在高并发写入的场景中可能会导致性能问题，因为需要等待对整个表的锁释放。 死锁风险： a. 行锁： 会死锁；锁定粒度小，发生锁冲突的概率较低。 b. 表锁： 无死锁；锁定粒度大，发生锁冲突的概率最高。 读锁和写锁 读锁：共享锁，会死锁。如1修改要等2读之后，2修改要等1读之后。 写锁：独占锁，会死锁。读写锁：一个资源可以被多个读线程访问，或者可以被一个写线程访问，但是不能同时存在读写进程，读写互斥，读读共享的。 无锁，多线程抢断资源； 添加锁，使用synchronized和ReentrantLock，都是独占的，每次只能来一个操作； 读写锁，读读可以共享，提升性能，同时多人进行读操作，缺点（1造成锁饥饿，一直读没有写；2读时候，不能写，只有读完成之后，才可以写，写操作可以读） 锁降级：将写入锁降级为读锁，读锁不能升级为写锁 读写锁案例1234567891011121314151617181920212223242526272829303132333435363738394041424344class MyCache&#123; private volatile Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); private ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); // 放数据 public void put(String key,Object value)&#123; readWriteLock.writeLock().lock(); System.out.println(Thread.currentThread().getName()+&quot;正在写操作&quot; +key); map.put(key,value); System.out.println(Thread.currentThread().getName()+&quot;写完了&quot; +key); readWriteLock.writeLock().unlock(); &#125; // 取数据 public Object get(String key)&#123; readWriteLock.readLock().lock(); Object result = null; System.out.println(Thread.currentThread().getName()+&quot;正在读操作&quot; +key); result = map.get(key); System.out.println(Thread.currentThread().getName()+&quot;读完了&quot; +key); readWriteLock.readLock().unlock(); return result; &#125;&#125;public class ReadWriteLockDemo &#123; public static void main(String[] args) &#123; MyCache myCache = new MyCache(); for (int i = 1; i &lt;= 5; i++) &#123; final int num = i; new Thread(()-&gt;&#123; myCache.put(num+&quot;&quot;,num+&quot;&quot;); &#125;,String.valueOf(i)).start(); &#125; for (int i = 1; i &lt;= 5; i++) &#123; final int num = i; new Thread(()-&gt;&#123; myCache.get(num+&quot;&quot;); &#125;,String.valueOf(i)).start(); &#125; &#125;&#125; 阻塞队列通过一个共享的队列，使数据由队列的一端输入，从另外一端输出；当队列空时，获取元素的线程会被阻塞；当队列满时，添加元素的线程会被阻塞。 为什么需要BlockingQueue？ 好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，BlockingQueue一手包办。 BlockingQueue的实现类： ArrayBlockingQueue 由数组结构组成的有界阻塞队列 LinkedBlockingQueue 由链表结构组成的有界（integer.MAX_VALUE）阻塞队列 DelayQueue 使用优先级队列实现的延迟无界阻塞队列 PriorityBlockingQueue 支持优先级排序的无界阻塞队列 SynchronousQueue 不存储元素的阻塞队列，也即单个元素的队列 LinkedTransferQueue 由链表结构组成的无界阻塞队列 LinkedBlockingDeque 由链表结构组成的双向阻塞队列 核心方法： 线程池优势：线程池做的工作只是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。特点： 降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗； 提高响应速度：当任务到达时，任务可以不需要等待线程创建就能立即执行； 提高线程的可管理性：利用线程池进行统一的分配，调优和监控。 线程池的使用方式 Executors.newFixedThreadPool(int) 一池N线程 Executors.newSingleThreadExecutor() 一个任务一个任务执行，一池一线程 Executors.newCachedThreadPool() 线程池根据需求创建线程，可扩容 ThreadPoolExecutor的七个参数 int corePoolSize 常驻线程数量 int maximumPoolSize 最大线程数量 long KeepAliveTime, TimeUnit unit 线程存活时间 BlockingQueue workQueue 阻塞队列 ThreadFactory threadFactory 线程工厂 RejectedExecutionHandler handle 拒绝策略 线程池的工作流程： JDK内置的拒绝策略： 自定义线程池一般情况下，不允许使用Executors创建线程池，而是通过自定义ThreadPoolExecutor的方式，以规避资源耗尽的风险。 1234567891011ExecutorService threadPool = new ThreadPoolExecutor( 2,5,2L,TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(3), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy());threadPool.execute(()-&gt;&#123; ...&#125;); Fork&#x2F;JoinFork：把一个复杂任务进行分拆，大事化小Join：把分拆任务的结果进行合并 12345678910111213141516171819202122232425262728293031323334353637383940414243class ForkJoinSumCalculate extends RecursiveTask&lt;Long&gt;&#123; private static final long serialVersionUID = -259195479995561737L; private long start; private long end; private static final long THURSHOLD = 10000L; //临界值 public ForkJoinSumCalculate(long start, long end) &#123; this.start = start; this.end = end; &#125; @Override protected Long compute() &#123; long length = end - start; if(length &lt;= THURSHOLD)&#123; long sum = 0L; for (long i = start; i &lt;= end; i++) &#123; sum += i; &#125; return sum; &#125;else&#123; long middle = (start + end) / 2; ForkJoinSumCalculate left = new ForkJoinSumCalculate(start, middle); left.fork(); //进行拆分，同时压入线程队列 ForkJoinSumCalculate right = new ForkJoinSumCalculate(middle+1, end); right.fork(); // return left.join() + right.join(); &#125; &#125; &#125; 异步回调CompletableFuture 无返回值的异步调用 1234567CompletableFuture&lt;Void&gt; cf = CompletableFuture.runAsync(()-&gt;&#123; // ... &#125;);cf.get(); 有返回值的异步调用 123456789CompletableFuture&lt;Integer&gt; cf = CompletableFuture.supplyAsync(()-&gt;&#123; return 1024; &#125;);cf.whenComplete((u,t)-&gt;&#123; // u 返回值；t 异常信息 &#125;).get(); 面试题1. 并发和并行并发：一台机器上“同时”处理多个任务，但同一时刻只有一个在发生；并行：在同一时刻，在多台处理器上同时处理多个任务。 2. 进程、线程、管程进程：应用程序的一次执行过程，动态的，包括进程从创建、运行和消亡的过程。系统运行程序的基本单元。线程：轻量级线程。同类的线程共享进程的堆和方法区，每个线程有自己的程序计数器、虚拟机栈和本地方法栈；操作系统调度的基本单元。管程：Monitor，锁，一种同步机制。JVM同步基于管程，底层由C++实现。当JVM对象被用作同步锁时，JVM会为该对象关联一个Monitor；而该对象不再被用作同步锁或对象被垃圾回收时，Monitor可能会被JVM内部释放或重新利用。 3. 线程的分类1） 用户线程；2）守护线程：为其他线程服务的。thread.setDaemon(true)。没有用户线程，JVM结束。 4. Future接口（FutureTask实现类） —JDK5特点：多线程，有返回值，异步任务优点：和线程池异步多线程任务配合使用效率高；缺点：get() 阻塞；isDone()轮询耗费CPU资源。 5. CompletableFuture —JDK8 出现的原因：1）针对Future的缺点；2）传入回调参数，实现复杂功能，以观察者模式。 接口CompletionStage和类CompletableFuture 静态构造方法：1）runAsyn无返回值；2）supplyAsyn有返回值。 Executor参数说明：若未指定，则使用默认的ForkJoinPoolCommonPool()；自定义线程池为非守护线程，所以就会继续执行。用ForkJoinPool是守护线程，可能会出现main线程结束后，JVM也结束了。 CompletableFuture可传入回调对象，当异步任务完成或发生异常时，自动调用回调对象。 6. 函数式接口 接口名称 方法名称 参数 返回值 Runnable run 无 无 Function apply 1 有 Consume accept 1 无 Supplier get 无 有 BiConsumer accept 2 无 7. CompletableFuture常用方法 获取结果和主动触发计算： get()； get(long timeout, TimeUnit unit)； join() 和get一样用，只是不抛出异常； getNow(T valuelfAbsent) —&gt;计算完成就返回正常值，否则返回备胎值（传入的参数），立即获取结果不阻塞 complete(T value) —-&gt;是否打断get方法立即返回括号值 对计算结果进行处理： thenApply：计算结果存在依赖关系，串行化，有异常叫停 handle：有异常也往下走 thenAccept：接受任务的处理结果，并消费处理，无返回结果 如果执行第一个任务传入了自定义线程池，thenRun执行第二个任务，则共用同一个线程池；若用thenRunAsync则各用各的。 原因：带Async的方法底层调用uniRunStage(asyncPool, action)更改线程池为默认的，而不是自定义的。 对计算速度进行选用： playA.applyToEither(playB, f -&gt; { return f + “ is winner”; }); 对计算结果进行了合并： 两个CompletableStage任务都完成后，最终能把两个任务的结果一起交给thenCombine来处理；先完成的先等着，等待其他分支任务。 8. 悲观锁和乐观锁悲观锁：synchronized和Lock的实现类，适合写操作多的场景；乐观锁：版本号机制Version，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。适合读操作多的场景。 9. synchronized线程8锁问题 对于普通同步方法，锁的是当前实例对象，通常指this，所有的同步方法用的都是同一把锁—&gt;实例对象本身 对于静态同步方法，锁的时当前类的Class对象 对于同步方法块，锁的时synchronized括号内的对象 10. 从字节码角度分析synchronized实现 synchronized同步代码块：实现使用的是monitorenter和monitorexit指令；一般是一个enter两个exit，一个正常情况退出锁，一个异常情况退出锁。 synchronized普通同步方法：ACC_SYNCHRONIZED访问标志。 synchronized静态同步方法：ACC_STATIC、ACC_SYNCHRONIZED访问标志。 为什么任何一个对象都可以成为一个锁？C++源码：ObjectMonitor.java—&gt;ObjectMonitor.cpp—&gt;ObjectMonitor.hpp每个对象天生都带着一个对象监视器，每一个被锁住的对象都会和Monitor关联起来。 11. 公平锁与非公平锁 为什么会有公平锁&#x2F;非公平锁的设计？为什么默认非公平？ 非公平锁能更充分地利用CPU的时间片，尽量减少CPU空闲状态时间。减少线程切换的开销。可能产生线程饥饿。 什么时候用公平？什么时候用非公平？ 如果为了更高的吞吐量，很显然非公平锁是比较合适的，因为节省了很多线程切换的时间，吞吐量自然就上去了；否则就用公平锁，大家公平使用。 12. 可重入锁 隐式锁（即synchronized关键字使用的锁）； 显式锁（即Lock）也有ReentrantLock这样的可重入锁；Objectmonitor底层会维护一个计数器每lock一次就+1，每unlock一次-1，0表示没有线程占用。(因此lock和unlock要成对出现) 13. 死锁及排查死锁产生原因： - 系统资源不足 - 进程运行推进顺序不合适 - 系统资源分配不当 排查： jps -l + jstack 进程编号 jconsole图形化 14. 线程中断 一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止，所以，Thread.stop,Thread.suspend,Thread.resume都已经被废弃了 Java中没有办法立即停止一条线程，Java提供了一种用于停止线程的协商机制—-中断，中断的过程完全需要程序员自行实现。 三个方法： public void interrupt() 仅仅是设置线程的中断状态为true，发起一个协商而不会立刻停止线程 public static boolean interrupted() 判断线程是否被中断并清除当前中断状态，重新设置为false public boolean isInterrupted() 判断当前线程是否被中断（通过检查中断标志位） 如何停止终端运行中的线程？ 通过一个volatile变量实现 12345678910new Thread(() -&gt; &#123; while (true) &#123; if (isStop) &#123; System.out.println(Thread.currentThread().getName() + &quot; isStop的值被改为true，t1程序停止&quot;); break; &#125; System.out.println(&quot;-----------hello volatile&quot;); &#125;&#125;, &quot;t1&quot;).start(); 通过AutomicBoolean 通过Thread类自带的中断API实例方法实现—-在需要中断的线程中不断监听中断状态，一旦发生中断，就执行相应的中断处理业务逻辑stop线程。 当前线程的中断标识为true，是不是线程就立刻停止？ 如果线程处于正常活动状态，那么会将该线程的中断标志设置为true，仅此而已，被设置中断标志的线程将继续正常运行，不受影响，所以interrupt()并不能真正的中断线程，需要被调用的线程自己进行配合才行，对于不活动的线程没有任何影响。 如果线程处于阻塞状态（例如sleep,wait,join状态等），在别的线程中调用当前线程对象的interrupt方法，那么线程将立即退出被阻塞状态（interrupt状态也将被清除），并抛出一个InterruptedException异常。 静态方法Thread.interrupted()，谈谈你的理解？中断标识被清空，如果该方法连续被调用两次，第二次调用将返回false；除非当前线程在第一次调用和第二次调用该方法之间再次被interrupt。 15. LockSupportLockSupport是用来创建锁和其他同步类的基本线程阻塞原语，其中park()和unpack()而作用分别是阻塞线程和解除阻塞线程。 三种让线程等待和唤醒的方法 使用Object中的wait()方法让线程等待，使用Object中的notify()方法唤醒线程 使用JUC包中的Condition的await()方法让线程等待，使用signal()方法唤醒线程 LockSupport类可以阻塞当前线程以及唤醒指定被阻塞的线程 LockSupport类中的park等待和unpark唤醒 LockSupport类使用了一种名为Permit（许可）的概念来做到阻塞和唤醒线程的功能，每个线程都有一个许可（Permit），许可证只能有一个，累加上限是1。 park&#x2F;park(Object blocker)——-阻塞当前线程&#x2F;阻塞传入的具体线程； unpark(Thread thread)——唤醒处于阻塞状态的指定线程 为什么要有LockSupport wait和notify方法必须要在同步代码块或者方法里面，且成对出现使用，先wait再notify才ok。 Condition中的线程等待和唤醒方法，需要先获取锁；一定要先await后signal。 因为unpark获得了一个凭证，之后再调用park方法，就可以名正言顺的凭证消费，故不会阻塞，先发放了凭证后续可以畅通无阻。 为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程？因为凭证的数量最多为1，连续调用两次unpark和调用一次unpark效果一样，只会增加一个凭证，而调用两次park却需要消费两个凭证，证不够，不能放行。 16. Java内存模型之JMM你知道什么是Java内存模型JMM吗？JMM（Java内存模型Java Memory Model）本身是一种抽象的概念并不真实存在，它仅仅描述的是一组约定或规范。通过这组规范定义了程序中（尤其是多线程）各个变量的读写访问方式并决定一个线程对共享变量的写入以及如何变成对另一个线程可见，关键技术点都是围绕多线程的原子性、可见性和有序性展开的。 为什么要有JMM，它为什么出现？作用和功能是什么？CPU的运行并不是直接操作内存而是先把内存里面的数据读到缓存，而内存的读和写操作的时候会造成不一致的问题。通过JMM来实现线程和主内存之间的抽象关系（线程之间的共享变量存储在主内存中，每个线程都有一个自己的本地工作内存，本地工作内存中存储了该线程用来读写共享变量的副本），屏蔽各个硬件平台和操作系统的内存访问差异以实现让Java程序在各种平台下都能达到一致性的内存访问效果。 JMM没有哪些特征或者它的三大特征是什么？ 可见性：是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道该变更，JMM规定了所有的变量都存储在主内存中。 原子性：指一个操作是不可被打断的，即多线程环境下，操作不能被其他线程干扰。 有序性：为了提升性能，编译器和处理器通常会对指令序列进行重新排序。Java规范规定JVM线程内部维持顺序化语义，即只要程序的最终结果与它顺序话执行的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。指令重排可以保证串行语义一致，但没有义务保证多线程的语义也一致（可能产生“脏读”）。 JMM和volatile他们两个之间的关系？volatile关键字：1、可见性；2、不保证原子性；3、禁止指令重排。 happens-before先行原则你有了解过吗？ 在JVM中，如果一个操作执行的结果需要对另一个操作可见或者代码重排序，那么这两个操作之间必须存在happens-before（先行发生）原则，逻辑上的先后关系。包含可见性和有序性的约束。 八条规则： 次序规则：一个线程内，按照代码的顺序，写在前面的操作先行发生于写在后面的操作； 锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作； volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作； 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C； 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作； 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生； 线程终止规则：线程中的所有操作都优先发生于对此线程的终止检测； 对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。 17. volatile与JMM被volatile修饰的变量有什么特点？ 可见性和有序性，但不保证原子性； 当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值立即刷新回主内存中； 当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，重新回到主内存中读取最新共享变量的值； volatile凭什么可以保证可见性和有序性？——&gt; 内存屏障Memory Barrier 系统底层确认变量的ACC_VOLATILE标识标志在相应的位置加入内存屏障。 内存屏障是什么？内存屏障（也称内存栅栏，屏障指令等）是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作，避免代码重排序。 内存屏障的分类粗分两种： 读屏障（Load Barrier）：在读指令之前插入读屏障，让工作内存或CPU高速缓存 当中的缓存数据失效，重新回到主内存中获取最新数据。 写屏障（Store Barrier）：在写指令之后插入写屏障，强制把缓冲区的数据刷回到主内存中。 细分四种： 屏障类型 指令示例 说明 LoadLoad Load1;LoadLoad;Load2 保证Load1的读取操作在Load2及后续读取操作之前执行 StoreStore Store1;StoreStore;Store2 在store2及其后的写操作执行前，保证Store1的写操作已经刷新到主内存 LoadStore Load1;LoadStore;Store2 在Store2及其后的写操作执行前，保证Load1的读操作已经结束 StoreLoad Store1;StoreLoad;Load2 保证Store1的写操作已经刷新到主内存后，Load2及其后的读操作才能执行 happens-before之volatile变量规则 当第一个操作为volatile读时，不论第二个操作是什么，都不能重排序，这个操作保证了volatile读之后的操作不会被重排到volatile读之前。 当第一个操作为volatile写时，第二个操作为volatile读时，不能重排。 当第二个操作为volatile写时，不论第一个操作是什么，都不能重排序，这个操作保证了volatile写之前的操作不会被重排到volatile写之后。 读屏障：在每个volatile读操作的后面插入一个LoadLoad屏障和LoadStore屏障。 写屏障：在每个volatile写操作的前面插入StoreStore屏障；在每个volatile写操作的后面插入StoreLoad屏障。 怎么理解volatile变量的复合操作不具有原子性对于voaltile变量具备可见性，JVM只是保证从主内存加载到线程工作内存的值是最新的，也仅仅是数据加载时是最新的。但是多线程环境下，“数据计算”和“数据赋值”操作可能多次出现，若数据在加载之后，若主内存volatile修饰变量发生修改之后，线程工作内存的操作将会作废去读主内存最新值，操作出现写丢失问题。即各线程私有内存和主内存公共内存中变量不同步，进而导致数据不一致。由此可见volatile解决的是变量读时的可见性问题，但无法保证原子性，对于多线程修改主内存共享变量的场景必须加锁同步。举例i++的例子； 如何正确使用volatile 单一赋值可以，但是含复合运算赋值不可以； 状态标志，判断业务是否结束； 开销较低的读，写锁策略；当读远多于写，结合使用内部锁和volatile变量来减少同步的开销； DCL双端锁的发布，多线程下的解决方案适合加volatile修饰。 123456789101112131415161718192021222324public class Singleton &#123; private volatile static Singleton uniqueInstance; private Singleton() &#123; &#125; public static Singleton getUniqueInstance() &#123; //先判断对象是否已经实例过，没有实例化过才进入加锁代码 if (uniqueInstance == null) &#123; //类对象加锁 synchronized (Singleton.class) &#123; if (uniqueInstance == null) &#123; // 隐患：多线程环境下，由于重排序，该对象可能未完成初始化就被其他线程读取。 // 1. 为 uniqueInstance 分配内存空间; 2. 初始化 uniqueInstance; 3. 将 uniqueInstance 指向分配的内存地址。 uniqueInstance = new Singleton(); &#125; &#125; &#125; return uniqueInstance; &#125;&#125; 18. CASCAS是什么？有什么缺点 没有CAS之前：多线程环境中使用valatile+synchronized保证线程安全i++； 使用CAS之后：多线程环境中使用原子类CAS保证线程安全i++，类似于乐观锁。CAS(compare and swap)，用于保证共享变量的原子性更新，它包含三个操作数—内存位置、预期原值与更新值。 缺点： 循环时间长开销大。底层getAndAddInt方法有一个do while，如果CAS失败，会一直进行尝试，如果CAS长时间一直不成功，可能会给CPU带来很大开销； ABA问题。可使用版本号时间戳原子引用AtomicStampedReference 。 CAS底层原理？谈谈对Unsafe类的理解？Unsafe类是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问，基于Unsafe类可以直接操作特定内存的数据。存在于sun.misc包中，Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的所有方法都直接调用操作系统底层资源执行相应任务。问题：我们知道i++是线程不安全的，那AtomicInteger.getAndIncrement()如何保证原子性？ AtomicInteger类主要利用CAS+volatile和native方法来保证原子操作，从而避免synchronized的高开销，执行效率大为提升；调用Unsafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令。这是一种完全依赖于硬件的功能，通过它实现了原子操作。 JDK提供的CAS机制，在汇编层级会禁止变量两侧的指令优化，然后使用compxchg指令比较并更新变量值（原子性）。 CAS与自旋锁CAS是实现自旋锁的基础，CAS利用CPU指令保证了操作的原子性，以达到锁的效果。自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁。好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。实现一个自旋锁，借鉴CAS思想： 1234567891011121314151617181920public class SpinLockDemo &#123; AtomicReference&lt;Thread&gt; atomicReference = new AtomicReference&lt;&gt;(); public void lock() &#123; Thread thread = Thread.currentThread(); System.out.println(Thread.currentThread().getName() + &quot;\\t --------come in&quot;); while (!atomicReference.compareAndSet(null, thread)) &#123; &#125; &#125; public void unLock() &#123; Thread thread = Thread.currentThread(); atomicReference.compareAndSet(thread, null); System.out.println(Thread.currentThread().getName() + &quot;\\t --------task over,unLock.........&quot;); &#125;&#125; 19. 原子操作类基本类型原子类： AtomicInteger 整型原子类 AtomicBoolean 布尔型原子类 AtomicLong 长整型原子类 数组类型原子类： AtomicIntegerArray 整型数组原子类 AtomicLongrArray 长整型数组原子类 AtomicReferenceArray 引用类型数组原子类 引用类型原子类： AtomicReference 引用类型原子类 AtomicStampedReference 原子更新带有版本号的引用类型，解决修改过几次 AtomicMarkableReference 原子更新带有标记的引用类型，解决是否修改过，将标记戳简化为true&#x2F;false 对象的属性修改原子类： AtomicIntegerFieldUpdater 原子更新对象中int类型字段的值 AtomicLongFieldUpdater 原子更新对象中Long类型字段的值 AtomicReferenceFieldUpdater 原子更新对象中引用类型字段的值 使用要求：更新的对象属性必须使用public volatile修饰符；因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。 原子操作增强类： DoubleAccumulator 一个或多个变量，它们一起保持运行double使用所提供的功能更新值 DoubleAdder 一个或多个变量一起保持初始为零double总和 LongAccumulator 一个或多个变量，一起保持使用提供的功能更新运行的值long ，提供了自定义的函数操作 LongAdder 一个或多个变量一起维持初始为零long总和（重点），只能用来计算加法，且从0开始计算；sum()在并发情况下不保证返回精确值 热点商品点赞计算器，点赞数加加统计，不要求实时精确 123456789101112131415161718192021222324252627class ClickNumber &#123; int number = 0; public synchronized void clickBySynchronized() &#123; number++; &#125; AtomicLong atomicLong = new AtomicLong(0); public void clickByAtomicLong() &#123; atomicLong.getAndIncrement(); &#125; LongAdder longAdder = new LongAdder(); public void clickByLongAdder() &#123; longAdder.increment(); &#125; LongAccumulator longAccumulator = new LongAccumulator((x, y) -&gt; x + y, 0); public void clickByLongAccumulator() &#123; longAccumulator.accumulate(1); &#125;&#125; 和AtomicLong比，LongAdder为什么这么快？ LongAdder是Striped64的子类；Striped64的基本结构里的base变量，类似于AtomicLong中全局的value；collide 扩容意向；cellsBusy 初始化cells或者cells扩容时需要获取锁，0无1有；casCellsBusy() 通过CAS操作修改cellsBusy的值，成功代表获取锁；NCPU 扩容时会用到cpu数量；getProbe() 获取当前线程的hash值；advanceProbe() 重置当前线程的hash值。 cell是java.util.concurrent.atomic下Striped64的一个内部类，cells数组的长度初始默认值是2，扩容为原来的2倍 LongAdder的基本思路就是分散热点，将value值分散到一个Cell数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作（减少乐观锁的重试次数），这样热点就被分散了，冲突的概率就小很多，如果要获取真正的long值，只要将各个槽中的变量值累加返回 sum()会将所有的Cell数组中的value和base累加作为返回值 化整为零，分散热点，空间换时间 20. ThreadLocalThreadLocal是什么？能干吗？ThreadLocal提供线程局部变量，每一个线程在访问ThreadLocal实例的时候（通过其get或set方法）都有自己的、独立初始化的变量副本。不和其他线程共享，从而避免了线程安全问题。withInitial(supplier)静态方法创建线程局部变量。 ThreadLocal中ThreadLocalMap的数据结构和关系Thread.java ——&gt; ThreadLocal.ThredLocalMap threadLocals &#x3D; nullThreadLocal.java ——&gt; static class ThreadLocalMap ——&gt; static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; ThreadLocalMap实际上就是一个以ThreadLocal实例为Key，任意对象为value的Entry对象；当我们为ThreadLocal变量赋值，实际上就是以当前ThreadLocal实例为Key，值为value的Entry往这个ThreadLocalMap中存放。ThreadLocal本身并不存储值。 ThreadLocal的key是弱引用，这是为什么？关于引用： 强引用：对于强引用的对象，就算是出现了OOM也不会对该对象进行回收，死都不收，当一个对象被强引用变量引用时，它处于可达状态，是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到，JVM也不会回收。除非对象引用置为null，或者超过作用域，即变为不可达，此时可以回收。 软引用：当系统内存充足时，不会被回收，当系统内存不足时，他会被回收。 弱引用：只要垃圾回收机制一运行，不管JVM的内存空间是否足够，都会回收该对象占用的内存。 虚引用：虚引用必须和引用队列联合使用，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都有可能被垃圾回收器回收，它不能单独使用也不能通过它访问对象。虚引用的主要作用是跟踪对象被垃圾回收的状态。仅仅是提供了一种确保对象被finalize后，做某些事情的通知机制。虚引用被干掉，将会进入引用队列，在队列中发现有对象，则说明被GC过。 关于为什么用弱引用： 当方法执行完毕后，栈帧销毁，强引用tl也就没有了，但此时线程的ThreadLocalMap里某个entry的Key引用还指向这个对象，若这个Key是强引用，就会导致Key指向的ThreadLocal对象即key指向的对象不能被gc回收，造成内存泄露； 使用弱引用就可以使ThreadLocal对象在方法执行完毕后顺利被回收且entry的key引用指向为null，大概率会减少内存泄漏的问题。（还得考虑value不为null的问题） ThreadLocal内存泄漏问题你知道吗？ThreadLocal中最后为什么要加remove方法？ 不再会被使用的对象或者变量占用的内存不能被回收，就是内存泄漏； 虽然弱引用，保证了Key指向的ThreadLocal对象能够被及时回收，但是v指向的value对象是需要ThreadLocalMap调用get、set时发现key为null时才会去回收整个entry、value，因此弱引用不能100%保证内存不泄露，我们要在不使用某个ThreadLocal对象后，手动调用remove方法来删除它。 都会通过expungeStaleEntry，cleanSomeSlots，replaceStaleEntry这三个方法回收键为null的Entry对象的值（即为具体实例）以及entry对象本身从而防止内存泄漏，属于安全加固的方法。 21. AbstractQueuedSynchronizer之AQSAQS是什么抽象的队列同步器： 是用来实现锁或者其他同步器组件的公共基础部分的抽象实现； 主要用于解决锁分配给“谁”的问题； 整体就是一个抽象的FIFO队列来完成资源获取线程的排队工作，并通过一个int类变量表示持有锁的状态。 AQS为什么是JUC内容中最重要的基石？ ReentrantLock、CountDownLatch、ReentrantReadWriteLock、Semaphore等等类的内部都有抽象的静态内部类Sync继承自AQS：abstract static class Sync extends AbstractQueuedSynchronizer{}； 进一步理解锁和同步器的关系：锁，面向锁的使用者，定义了程序员和锁交互的使用层API，隐藏了实现细节，你调用即可；同步器，面向锁的实现者，Java并发大神DoungLee，提出了统一规范并简化了锁的实现，将其抽象出来，屏蔽了同步状态管理、同步队列的管理和维护、阻塞线程排队和通知、唤醒机制等，是一切锁和同步组件实现的。 AQS的排队等候机制如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中，这个队列就是AQS同步队列的抽象表现。它将要请求共享资源的线程及自身的等待状态封装成队列的节点对象（Node），通过CAS、自旋以及LockSupport.park()的方式，维护着state变量的状态，使其达到同步的状态。 AQS内部体系架构—-内部类Node：Node的等待状态waitState成员变量； AQS源码深度分析 公平锁和非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()—–公平锁加锁时判断等待队列中是否存在有效节点的方法。 lock() ——&gt; acquire(1) 第二个线程及后续线程抢占 if(!tryAcquire(arg)&amp;&amp;acquireQueued(addWaiter(Node.EXCLUSIVE),arg)) addWaiter若链表没初始化就先初始化，否则入队enq(Node)；compareAndSetHead和compareAndSetTail；在双向链表中，第一个节点为虚节点（也叫做哨兵节点），其实不存储任何信息，只是占位。真正的第一个有数据的节点，是从第二个节点开始的。 acquireQueued中自旋tryAcquire、前置节点状态得为SIGNAL、阻塞当前节点parkAndCheckInterrupt()，里面调用的是LockSupport.park(this)。 unlock() ——&gt; release(1) ——&gt; tryRelease(arg) 释放锁、修改资源的占有状态 ——&gt; unparkSuccessor(h) 唤醒头结点的后置结点，里面调用的是LockSupport.unpark(s.thread)。 22. 读写锁ReentrantReadWriteLock是什么？特点有哪些？ 一个资源能够被多个读线程访问，或者被一个写线程访问，但是不能同时存在读写线程； 读读共存，读写互斥，写写互斥； 只有在读多写少情景之下，读写锁才具有较高的性能体现。 读写锁中的锁降级 将写锁降级为读锁 —— 遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级为读锁； 如果一个线程持有了写锁，在没有释放写锁的情况下，它还可以继续获得读锁； 从读锁升级到写锁是不可能的。 有没有比读写锁更快的锁？StampedLock邮戳锁是什么： StampedLock是JDK1.8中新增的一个读写锁，也是对JDK1.5中的读写锁ReentrantReadWriteLock的优化； stamp 代表了锁的状态。当stamp返回零时，表示线程获取锁失败，并且当释放锁或者转换锁的时候，都要传入最初获取的stamp值； ReentrantReadWriteLock实现了读写分离，当前有可能会一直存在读锁，而无法获得写锁，锁饥饿；StampedLock类采取乐观获取锁，其他线程尝试获取写锁时不会被阻塞，在获取乐观读锁后，还需要对结果进行校验。 特点： 所有获取锁的方法，都返回一个邮戳，stamp为零表示失败，其余都表示成功； 所有释放锁的方法，都需要一个邮戳，这个stamp必须是和成功获取锁时得到的stamp一致； StampedLock是不可重入的，危险（如果一个线程已经持有了写锁，在去获取写锁的话会造成死锁） 三种访问模式：Reading（读模式悲观）、Writing（写模式）、Optimistic reading（乐观读模式） 读的时候也可以写，如果读的时候被写了，那就重新读一次。对短的只读代码段，使用乐观模式通常可以减少争用并提高吞吐量 StampedLock 的悲观读锁和写锁都不支持条件变量(Condition),这个也需要注意； 使用 StampedLock一定不要调用中断操作,即不要调用interrupt()方法。 23. Java对象内存布局和对象头24. Synchronized与锁升级","tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/tags/JAVA/"}]},{"title":"CRS-Adversarial Examples","date":"2023-03-20T07:47:31.000Z","path":"2023/03/20/CRS-Adversarial-Examples/","text":"Evaluating the Robustness of Conversational Recommender Systems by Adversarial Examples动机 测试CRS系统的鲁棒性，考虑到人机交互时输入信息的复杂性 贡献 提出了一种包含两类四种方案的对抗性评估方案，并自动生成对抗性实例来评估这些系统在面对不同输入数据时的鲁棒性。 对三个CRS模型进行了对抗测试，结果都是较差的鲁棒性 四种方案 expecting the same prediction by changing the user’s answer期望得到相同的预测，但改变用户的回答 expecting the same prediction by adding more details to the user’s answer期望得到相同的预测，但为用户的回答中添加更多的信息 expecting a different prediction bychanging the user’s answer期望得到不同的预测，但改变用户的回答 expecting a different prediction by adding a contradictory sentence to the user’s answer期望得到不同的预测，但为用户的回答中添加一句矛盾的句子 结果分析及启发 We believe that if a model needs to be successful in this task, should have a strong attention mechanism on the user’s answer. This helps the system to fully understand user preferences. first needs to decide which words are important in the user’s answer, then consider all these important words (which are user preferences) in the recommendation. 这篇文章通过一些对抗实例来测试如今一些好的CRS模型，发现其鲁棒性较差的问题。大部分性能都是下降了，说明在复杂句子中去理解单词的重要性以充分理解用户偏好对CRS性能提升很重要。但也有略微上升的情况，是否可以说明增加适当的对抗或者说干扰，对模型的鲁棒性有一定的提升？带来的思考在于，对抗与非对抗之间的平衡，一方面CRS模型要能抵御一些句子层面上的干扰，另一方面能将干扰化为己用来提高性能。","tags":[{"name":"CRS","slug":"CRS","permalink":"http://example.com/tags/CRS/"}]},{"title":"Hello World","date":"2023-03-14T16:08:31.094Z","path":"2023/03/15/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"some ideas","date":"2023-03-09T06:53:55.000Z","path":"2023/03/09/some-ideas/","text":"Some ideas对话推荐 Conversation Module：对话模块，负责理解用户的自然语言反馈以及给出系统的文本答复 Conversation Module：策略模块，根据当前状态做出如何回复的决定，是继续询问还是进行推荐 Recommender Module：推荐模块，负责根据用户的偏好给出相应的推荐列表或者单个推荐结果 基于属性的对话推荐更多地针对策略模块，希望在最短的交谈次数内实现尽可能精确的推荐。 单轮场景 SIGIR 2018（CRM）：Conversational Recommender System 动机：如何准确地理解用户的意图？如何实施序列化的决策并在每一步采取合适的行动？如何做个性化的推荐以最大化地提升用户的满意程度？ 方法：提出三个模块分别解决上述三个问题。Belief Tracker + Policy Network + Recommender 对于一句话，利用n-gram词表转化为向量，LSTM 网络学习所有对话的隐含表示 推荐模块采用2-way FM二路因子分解机，输入为用户信息、物品信息和对话信息，输出为用户对物品的预测评分 策略模块，输入对话信息，简单的两层前馈神经网络，输出用户的动作预测 。利用强化学习中的 Policy Gradient 方法进行训练 多轮场景 WSDM 2020（EAR）：Estimation–Action–Reflection: Towards Deep Interaction Between Conversational and Recommender Systems 动机：认为对话推荐应该采用多轮场景，系统能对一个用户进行多次推荐，并根据之前推荐的反馈改善后面的推荐 方法：加强对话模块和推荐模块的交互（What attributes to ask? When to recommend items? How to adapt to users’ online feedback?）Estimation–Action–Reflection框架： Estimation 模块完成推荐任务，FM + BPR Action 模块负责决策，基于强化学习训练，网络结构同CRM，更简单的奖励机制 Reflection 模块以负反馈物品为负例构建新的损失函数项进一步训练 搜索剪枝 KDD 2022（CPR）：Interactive Path Reasoning on Graph for Conversational Recommendation 动机：之前的工作都是用隐式的方法来利用用户在属性方面的反馈信息 方法：本文基于图机构（由用户、物品、属性三类节点构成），通过显式方法来利用用户喜欢的属性，删去了大量无关的候选物品。 将决策的动作空间缩小为两个，询问or推荐 持久化地维护之前访问过的属性节点集合、询问用户时被予以否定的属性集合和候选物品集合。显式地利用用户的反馈信息确定了物品和属性的候选范围 在候选集合中进一步排序，与EAR类似 统一架构 SIGIR 2021（UNICORN）：Unified Conversational Recommendation Policy Learning via Graph-based Reinforcement Learning 动机：过去基于属性的对话推荐系统工作总是将决策过程分到多个模块去完成，这对模型的可扩展性造成了影响 方法：将三个决策问题（询问还是推荐、询问什么、推荐什么）统一起来 Graph-based MDP Environment：基本上沿用了 CPR 构建的图上路径推理机制 Graph-enhanced State Representation Learning：将当前对话状态表示成一个向量 Action Selection Strategy：强化学习动作空间，两类动作（推荐和询问）各选 k1 和 k2 个，选择top-k1个物品推荐，选择top-k2个属性进行询问 Deep Q-Learning Network：强化学习决策网络模块，输入是2中的对话状态向量和3中的k1 + k2个节点的embedding，采用DQN算法进行学习训练，输出是？？ 生成式对话推荐更注重向用户提供流畅的对话体验，同时将推荐物品相关的信息融入到回复文本中，提高推荐的可解释性。 降噪协同 NeurIPS 2018（ReDial）:Towards Deep Conversational Recommendations 构造了电影场景下的对话推荐数据集REDIAL（包含 6924 部电影、956 位用户、11348 个对话，平均每个对话由 18 个英文句子构成，并保证每个对话中至少提到 4 部电影，还包含语句的情感判断标签） 先按模块分别用更大的数据集训练，然后再一起端到端地用 REDIAL 训练 对话模块中，使用层次化的RNN结构HRED来编码对话，并采用了预训练的 Gensen 句子向量表示。HRED 得到对话的隐含向量表示之后，一方面会给情感分析 RNN 进行计算，一方面给 Switching Decoder 来将推荐结果融入到对话中，另外还能用于给 RNN 解码出回复语句 推荐模块中，采用降噪自编码器，同时利用了情感分析模块的计算结果进一步修正推荐结果 后续的工作基本上都不再利用情感标签 知识增强 EMNLP 2019（KBRD）：Towards Knowledge-Based Recommender Dialog System 动机：ReDial当对话中没有提到物品时则无法向用户提供推荐结果 方法：引入知识图谱，从中抽取与 REDIAL 任务相关的子图，将上面的节点与 REDIAL 中的实体（包括电影实体和如导演、演员、影片类别等其他实体）进行对齐；R-GCN 学习图上实体的向量表示；采用自注意力机制来进行融合不同实体对应的 embedding，从而得到用户表示；最终通过向量内积来计算每个实体的得分；对话模块采用 Transformer 架构，并在最终生成的词汇分布上加上 Vocabulary Bias 对话模块获得的实体信息对推荐产生促进作用 推荐模块产生的用户embedding转化为Vocabulary Bias来促进对话生成 语义融合 KDD 2020(KGSF)：Improving Conversational Recommender Systems via Knowledge Graph based Semantic Fusion 动机：过去的生成式对话推荐系统工作没能很好地处理文本信息，基于自然语言的表达与基于实体构建的用户偏好表示二者存在天然的语义差异 方法：通过互信息最大化的多知识图谱语义融合技术，打通不同类型信息之间的语义差异 实体信息方面，DBpedia 子图进行编码 词汇信息方面，与 ConceptNet 中的词汇对齐 使用互信息最大化算法来对两类 embedding 进行预训练 对话模块，KGSF 修改了 Transformer 的内部结构，将用户或者说对话构造的实体矩阵、词汇矩阵通过多头自注意力机制逐步融入解码过程中 话题引导 COLING 2020(TGReDial):Towards Topic-Guided Conversational Recommender System 动机：缺乏主动的引导来将非推荐场景的对话转变为推荐场景的对话；由数据标注平台的工作人员对话来生成的对话推荐数据集难以捕捉现实世界场景丰富且复杂的情况 方法： 收集电影序列，对于某一用户可以从其观影记录中的电影构建若干子序列，其中每个序列的电影都有相同的话题标签 构建话题转移的通道，作者借助深度优先搜索算法，在知识图谱 ConceptNet 上找到一条从最初话题（greeting）到目标电影话题的转移路径 利用深度学习模型从话题生成对话文本，并进行人工修改和润色，以保证对话的流畅性 可控生成 EMNLP 2021(NTRD):Learning Neural Templates for Recommender Dialogue System 动机：不能总是将推荐结果精确且恰当地融入到生成的回复中；推荐结果总是在训练集中提到的物品，缺乏泛化性 方法： 将 KGSF 的对话模块改造为 Response Template Generator，具体做法是将数据集中的所有物品（电影）全部替换为特殊符号[ITEM]，使得生成的对话不带具体的电影信息，而是一个个句子模板 构造一个物品选择器来填写模板中的[ITEM]槽，NTRD 使用堆叠的多头注意力函数来构造选择器。在这个堆叠的结构中逐步融入了模板词汇相关信息、模板的槽相关信息、推荐模块得到的候选物品相关信息 UCCR User-Centric Conversational Recommendation with Multi-Aspect User Modeling SIGIR 2022 以用户为中心的对话推荐系统 动机：现有方法本质上当前会话的建模，而忽略了用户建模。而本文发现用户历史会话和相似用户信息也可以很好地辅助用户兴趣建模，特别是在用户当前会话信息较少（冷启动）的场景下效果更佳。 方法：在历史会话建模部分，UCCR同时考虑了用户的实体偏好、语义偏好和消费偏好，从这三种偏好中提取有益于用户当前兴趣建模的信息；之后UCCR基于对比学习，学习不同用户当前&#x2F;历史兴趣偏好之间的内在联系；在查找相似用户部分，UCCR考虑了用户兴趣的动态变化过程，基于用户历史兴趣查找相似用户；最终将多维度的用户信息融合在一起。 历史对话学习器：从历史对话中提取用户multi-view兴趣偏好，包含实体偏好（用户提到的实体）、语义偏好（用户提到的单词）、消费偏好（用户历史喜欢的商品）。 多视图兴趣偏好映射器：学习不同view的兴趣偏好间的内在联系。其核心思想是：同一用户的不同view的兴趣偏好应当相关，而不同用户之间应当无关。 时序相似用户选择器：历史兴趣相似的用户，其当前兴趣有更大概率会相似。 用户兴趣偏好融合：平衡当前对话信息与multi-aspect信息之间的关系 Current Session Learner：对当前对话建模，与KGSF和KBRD差不多，DBpedia和ConceptNet分别编码实体和单词 Historical Sessions Learner： Historical Entity Learner：用户历史提到的所有实体，与当前实体的相似度进行加权平均，目的是更多地选择和当前实体偏好相似的历史实体，以防止不相关信息干扰 Historical Word Learner：建模近因效应提取到适当的语义知识，利用每个单词出现的对话轮数对齐加权平均 Historical Item Learner：历史item，利用当前实体表示和当前单词表示的组合来代替当前商品表示，最终得到历史商品表示 Multi-View Preference Mapper：基于对比学习，学习不同view的内在信息，进而得到更准确地表示 Temporal Look-Alike User Selector：由于CRS中用户兴趣随着对话推进不断变化，将用户每一次交互历史都和target用户历史进行比较，学习其中最有用的信息 Multi-Aspect User-Centric Modeling：Entity-View + Word-View + Item-View ReDial英文数据集 和 TG-ReDial中文数据集利用对话时间对数据集进行重排 UniCRS KDD 2022:Towards Unified Conversational Recommender Systems via Knowledge-Enhanced Prompt Learning Challenges 三个子模块的共同优化 推荐系统的去偏 精心设计的多轮对话策略 引入更多的知识如多模态数据 更合理的评测机制和更好的用户模拟器","tags":[{"name":"CRS","slug":"CRS","permalink":"http://example.com/tags/CRS/"}]},{"title":"pytorch study","date":"2023-02-28T05:52:25.000Z","path":"2023/02/28/pytorch-study/","text":"PyTorch深度学习实践学习记录0 配置环境 conda环境：’pytorch’ conda create -n pytorch python=3.9 GPU：NVIDIA GeForce GTX 1050 Ti 安装cuda conda install pytorch==1.10.1 torchvision==0.11.2 torchaudio==0.10.1 cudatoolkit=10.2 测试一下 import torch torch.cuda.is_available() //成功则返回True 安装pycharm和jupyter notebook dir()和help()函数 1 加载数据 Dataset 提供一种方式去获取数据及其label 如何获取每一个数据及其label？ def __init__(self, root_dir, label_dir) def __getitem__(self, idx): 三种数据集结构 1.label是文件夹名 2.label在txt文件中 3.label包含在文件名中 告诉我们总共有多少的数据？ def __len__(self): return len(self.img_path_list) Dataloader 为后面的网络提供不同的数据形式 test_loader = DataLoader(dataset=test_data, batch_size=64，shuffle=True, num_workers=0) writer = SummaryWriter(&quot;dataloader_logs&quot;) for epoch in range(2): step = 0 for data in test_loader: imgs, targets = data writer.add_images(&quot;epoch: &#123;&#125;&quot;.format(epoch), imgs, step) step = step + 1 2 tensorboard的使用启动tensorboard tensorboard --logdir=logs --port=6007 example： writer = SummaryWriter(&quot;logs&quot;) image_path = &quot;dataset/train/ants/0013035.jpg&quot; img_PIL = Image.open(image_path) img_array = np.array(img_PIL) writer.add_image(&quot;train&quot;, img_array, 1, dataformats=&#39;HWC&#39;) # y = 2x for i in range(100): writer.add_scalar(&quot;y=2x&quot;, 2*i, i) writer.close() 3 transform的使用关注输入和输出类型，多看官方文档，关注方法需要的参数 ToTensor() tensor_trans = transforms.ToTensor() tensor_img = tensor_trans(img) Normalize trans_norm = transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5]) img_norm = trans_norm(tensor_img) Resize trans_resize = transforms.Resize((256, 256)) Compose trans_resize_2 = transforms.Resize(256) trans_compose = transforms.Compose([trans_resize_2, tensor_trans]) img_resize_2 = trans_compose(img) RandomCrop trans_random = transforms.RandomCrop(256) trans_compose_2 = transforms.Compose([trans_random, tensor_trans]) 4 dataset 和 transform 一起使用 dataset_transform = torchvision.transforms.Compose([ torchvision.transforms.ToTensor() ]) train_set = torchvision.datasets.CIFAR10(root=&quot;./dataset_CIFAR10&quot;，transform=dataset_transform, train=True, download=True) test_set = torchvision.datasets.CIFAR10(root=&quot;./dataset_CIFAR10&quot;, transform=dataset_transform, train=False, download=True) 5 Neural Network1 nn.ModuleBase class for all neural network modulesexample: import torch.nn as nn import torch.nn.functional as F class Model(nn.Module): def __init__(self): super().__init__() self.conv1 = nn.Conv2d(1, 20, 5) self.conv2 = nn.Conv2d(20, 20, 5) def forward(self, x): x = F.relu(self.conv1(x)) return F.relu(self.conv2(x)) 2 nn.Conv2dParameters: in_channels (int) – Number of channels in the input image out_channels (int) – Number of channels produced by the convolution kernel_size (int or tuple) – Size of the convolving kernel stride (int or tuple, optional) – Stride of the convolution. Default: 1 padding (int, tuple or str, optional) – Padding added to all four sides of the input. Default: 0 padding_mode (str, optional) – ‘zeros’, ‘reflect’, ‘replicate’ or ‘circular’. Default: ‘zeros’ dilation (int or tuple, optional) – Spacing between kernel elements. Default: 1 空洞卷积 groups (int, optional) – Number of blocked connections from input channels to output channels. Default: 1 bias (bool, optional) – If True, adds a learnable bias to the output. Default: True 3 nn.MaxPool2d又叫下采样， nn.MaxUnpool2d 为上采样Parameters: kernel_size (Union[int, Tuple[int, int]]) – the size of the window to take a max over stride (Union[int, Tuple[int, int]]) – the stride of the window. Default value is kernel_size padding (Union[int, Tuple[int, int]]) – Implicit negative infinity padding to be added on both sides dilation (Union[int, Tuple[int, int]]) – a parameter that controls the stride of elements in the window return_indices (bool) – if True, will return the max indices along with the outputs. Useful for torch.nn.MaxUnpool2d later ceil_mode (bool) – when True, will use ceil instead of floor to compute the output shape 4 Non-linear Activations nn.ReLU nn.Sigmoid效果： 5 nn.Sequentialexample: self.model1 = Sequential( Conv2d(3, 32, 5, padding=2), MaxPool2d(2), Conv2d(32, 32, 5, padding=2), MaxPool2d(2), Conv2d(32, 64, 5, padding=2), MaxPool2d(2), Flatten(), Linear(1024, 64), Linear(64, 10) ) 使用已有模型开发 vgg16_false = torchvision.models.vgg16(pretrained=False) vgg16_true = torchvision.models.vgg16(pretrained=True) vgg16预训练是在ImagNet上，但ImagNetl类别是1000个，Cifar10类别是10个方案1：add_module添加一个线性层 vgg16_true.classifier.add_module(&#39;add_linear&#39;, nn.Linear(1000, 10)) 方案2：直接修改某一层 vgg16_false.classifier[6] = nn.Linear(4096, 10) 模型的保存与导入（两种） torch.save(vgg16_false, “vgg16_method1.pth”) model &#x3D; torch.load(“vgg16_method1.pth”) (recommend) smaller 通过字典形式存储参数 torch.save(vgg16_false.state_dict(), &quot;vgg16_method2.pth&quot;) vgg16_false.load_state_dict(torch.load(&quot;vgg16_method2.pth&quot;)) 完整的训练流程（套路） 准备数据集 dataloader加载数据集 搭建网络模型 创建网络模型实例 定义损失函数 定义优化器 设置网络训练的参数 开始训练 验证模型 最后保存模型 tensorboard训练结果展示 # 准备训练数据集 train_data = torchvision.datasets.CIFAR10(root=&quot;./dataset_CIFAR10&quot;, train=True, transform=torchvision.transforms.ToTensor(),download=True) # 准备训练数据集 test_data = torchvision.datasets.CIFAR10(root=&quot;./dataset_CIFAR10&quot;, train=False, transform=torchvision.transforms.ToTensor(),download=True) print(&quot;训练数据集的长度为：&#123;&#125;&quot;.format(len(train_data))) # 利用DataLoader来加载数据集 train_dataloader = DataLoader(train_data, batch_size=64) test_dataloader = DataLoader(train_data, batch_size=64) # 创建网络模型 model = Model() # 损失函数 loss_fn = nn.CrossEntropyLoss() # 优化器 learning_rate = 1e-2 optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate) # 设置训练网络的一些参数 # 记录训练的次数 total_train_step = 0 # 记录测试的次数 total_test_step = 0 # 训练的轮数 epoch = 10 # 添加tensorboard writer = SummaryWriter(&quot;train_logs&quot;) for i in range(epoch): print(&quot;--------第 &#123;&#125; 轮训练开始--------&quot;.format(i+1)) # 训练步骤 # model.train() # 适用于有dropout层，Norm层 for data in train_dataloader: imgs, targets = data outputs = model(imgs) loss = loss_fn(outputs, targets) # 优化器优化模型 optimizer.zero_grad() loss.backward() optimizer.step() total_train_step = total_train_step + 1 if total_train_step % 100 == 0: print(&quot;训练次数：&#123;&#125;，loss:&#123;&#125;&quot;.format(total_train_step, loss.item())) writer.add_scalar(&quot;train_loss&quot;, loss.item(), total_train_step) # 测试步骤 # model.eval() # 适用于有dropout层，Norm层 total_test_loss = 0.0 with torch.no_grad(): for data in test_dataloader: imgs, targets = data outputs = model(imgs) loss = loss_fn(outputs, targets) total_test_loss += loss.item() accuracy = (outputs.argmax(1) == targets).sum() total_accuracy = total_accuracy + accuracy print(&quot;整体测试集上的Loss：&#123;&#125;&quot;.format(total_test_loss)) print(&quot;整体测试集上的accuracy：&#123;&#125;&quot;.format(total_accuracy/len(test_data))) writer.add_scalar(&quot;test_loss&quot;, total_test_loss, total_test_step) writer.add_scalar(&quot;test_accuracy&quot;, total_accuracy/len(test_data), total_test_step) total_train_step += 1 # 保存模型 # torch.save(model, &quot;model_&#123;&#125;.pth&quot;.format(i)) # print(&quot;模型已保存&quot;) writer.close() 使用GPU训练对模型、损失函数、要训练和验证数据处理，两种方式： .cuda() 先定义device &#x3D; torch.device(“cuda”)，然后对模型、损失函数、数据使用.to(device)可使用google.colab使用免费的计算资源 验证的流程 image_path = &quot;&quot; image = Image.open(image_path) transform = torchvision.transforms.Compose([torchvision.transforms.Resize((32, 32)), torchvision.transforms.ToTensor()]) image = transform(image) # 载入网络模型 # 如果是gpu上训练的结果在cpu上载入，要加map_location=torch.device(&#39;cpu&#39;) model = torch.load(&quot;model_29_gpu.pth&quot;, map_location=torch.device(&#39;cpu&#39;)) image = torch.reshape(image, (1, 3, 32, 32)) model.eval() with torch.no_grad(): output = model(image) print(output) print(output.argmax(1))","tags":[{"name":"PyTorch","slug":"PyTorch","permalink":"http://example.com/tags/PyTorch/"}]},{"title":"Knowledge-Enhanced Prompt Learning","date":"2023-02-24T01:47:52.000Z","path":"2023/02/24/Knowledge-Enhanced-Prompt-Learning/","text":"Towards Unified Conversational Recommender Systems via Knowledge-Enhanced Prompt Learning 通过知识增强的提示学习实现统一的CRS KDD 2022 摘要 propose a unified CRS model named UniCRS based on knowledge-enhanced prompt learning. unifies the recommendation and conversation subtasks into the prompt learning paradigm, and utilizes knowledge-enhanced prompts based on a fixed pre-trained language model (PLM) to fulfill both subtasks in a unified approach. In the prompt design, we include fused knowledge representations, task-specific soft tokens,and the dialogue context, which can provide sufficient contextual information to adapt the PLM for the CRS task. for the recommendation subtask, we also incorporate the generated response template as an important part of the prompt, to enhance the information interaction between the two subtasks. 动机 Existing works either design semantic alignment strategies, or share knowledge resources and representations between the two modules. However, these approaches still rely on different architectures or techniques to develop the two modules, making it difficult for effective module integration.现有的工作要么设计语义对齐策略，要么在两个模块之间共享知识资源和表示。然而，这些方法仍然依赖于不同的架构或技术来开发这两个模块，这使得有效的模块集成变得困难。 it has been pointed out that the generated responses from the conversation module do not always match the predicted items from the recommendation module 方法 用于提示学习的语义融合 根据先前的研究，本文将 KG 合并为特定于任务的知识资源，因为它涉及对话中提到的实体和项目的有用知识。然而，已经发现对话的语义空间和 KGs 之间存在很大的语义差距。 本文需要首先融合两个语义空间以进行有效的知识对齐和丰富。 特别是，这一步的目的是融合来自不同编码器的令牌和实体嵌入。 编码词标记和知识图谱实体：给定对话历史 ，本文首先将对话历史中出现的对话词和 KG 实体分别编码为词嵌入和实体嵌入。 为了补充本文的基础 PLM DialoGPT（单向解码器），本文采用了另一个固定的 PLM RoBERTa（双向编码器）来推导词嵌入。 词实体语义融合：为了弥合词和实体之间的语义鸿沟，本文使用交叉交互机制通过双线性变换将两种语义表示联系起来： 预训练融合模块：为了更好地优化融合模块的参数，提出了一种基于提示的预训练方法，它利用了对话中的自我监督信号 特定于子任务的提示设计 虽然基础 PLM 是固定的，无需微调，但本文可以设计特定的提示以使其适应 CRS 的不同子任务。 对于每个子任务（推荐或对话），提示的主要设计由三部分组成，即对话历史、子任务特定软令牌和融合知识表示。 对于推荐，本文进一步将生成的响应模板合并为额外的提示标记。 接下来，本文详细描述这两个子任务的具体提示设计。 提示生成响应：响应生成的提示由原始对话历史记录（以单词标记 的形式）、特定于生成的软标记（以潜在向量 P 的形式）和融合的文本上下文（以潜在向量 T~ 的形式）组成。 提示项目推荐：项目推荐提示由原始对话历史 （以单词标记的形式）、特定于推荐的软标记 P（以潜在向量的形式）、融合实体上下文 E~（以潜在向量的形式）和 响应模板 （以单词标记的形式）。 实验和结果 KGSF &gt; KBRD &gt; ReDial。 KGSF 和 KBRD 都将外部 KG 纳入其推荐模块中，这可以丰富对话历史中提到的实体的语义，以更好地捕捉用户意图和偏好。 此外，KGSF 还采用互信息最大化的方法来进一步改进实体表示。 对于四个预训练模型，本文可以看到 BERT 和 BART 的表现优于 GPT-2 和 DialoGPT。 原因可能是 GPT-2 和 DialoGPT 基于单向 Transformer 架构，这限制了它们的对话理解能力。 此外，可以看到 BART 在 ReDial 数据集上实现了相当的性能，甚至优于 BERT。 这表明 BART 也可以很好地理解推荐任务的对话语义。最后，可以看到本文模型大大优于所有基线。 本文利用专门设计的提示来指导基础 PLM，并结合 KG 通过预训练任务提高提示质量。 启发","tags":[{"name":"CRS","slug":"CRS","permalink":"http://example.com/tags/CRS/"}]},{"title":"flask+vue+mysql前后分离项目每日记录","date":"2023-02-23T08:50:00.000Z","path":"2023/02/23/flask-vue-mysql前后分离项目每日记录/","text":"flask+vue+mysql前后分离项目每日记录Day1创建项目 conda创建虚拟环境：flask-vue 安装第三方库：requirement.txt 前端用的vue-admin-template-master，在此基础上改造开发 新建mysql数据库movies flask配置数据库创建config.py 文件，配置数据库 SQLALCHEMY_DATABASE_URI = &quot;mysql://root:123456@localhost:3306/movies&quot; SQLALCHEMY_COMMIT_ON_TEARDOWN = True SQLALCHEMY_TRACK_MODIFICATIONS = False 设计user表和movie表（以user表为例） class Users(db.Model): __tablename__ = &#39;user&#39; userid = db.Column(db.Integer, primary_key=True, autoincrement=True) name = db.Column( db.String(255), nullable=False, ) ... created_on = db.Column( db.DateTime, nullable=False, ) enable = db.Column( db.Boolean, default=True, nullable=False, ) def set_password(self, password: str): self.password = generate_password_hash(password, method=&#39;sha512&#39;) def check_password(self, password: str): return check_password_hash(self.password, password) def __repr__(self): return &#39;&lt;User &#123;&#125;&gt;&#39;.format(self.name) @classmethod def add(cls, user): db.session.add(user) db.session.commit() 命令行一次性创建所有表 python run.py create_db //注意切换到项目的conda环境 movie数据 MovieLens Latest Datasets ml-latest-small.zip Small: 100,000 ratings and 3,600 tag applications applied to 9,000 movies by 600 users. Last updated 9&#x2F;2018.通过爬虫从IMBD网站中获取电影的详细信息和封面图片。参考链接 这里直接使用其爬好的最终csv文件，info.csvmysql中导入csv，注意字段的长度！longtext &gt; text &gt; varchar(255) Day2用户登录 def post(self): parser = reqparse.RequestParser() parser.add_argument(&#39;username&#39;, required=True, nullable=False, type=str, location=&#39;json&#39;, help=&quot;username is required&quot;) parser.add_argument(&#39;password&#39;, required=True, nullable=False, type=str, location=&#39;json&#39;, help=&quot;password is required&quot;) args = parser.parse_args() username = args.get(&#39;username&#39;) password = args.get(&#39;password&#39;) user = Users.query.filter_by(name=username).first() if user is None: error = &#39;User not exists&#39; elif user.check_password(password=password): access_token = create_access_token( identity=user.userid, expires_delta=datetime.timedelta(days=1)) return jsonify(&#123;&#39;access_token&#39;: access_token&#125;) else: error = &#39;user and password not match&#39; return error, 401 username与password匹配则返回jwt_token;前端发送请求需携带jwt_token，例如获取用户信息显示在页面头部位置。 @jwt_required() def get(self): userid = get_jwt_identity() user = Users.query.filter_by(userid=userid).first() return jsonify(&#123; &#39;username&#39;: user.name, &#39;email&#39;: user.email &#125;) postman测试如果post请求参数是json需在boby里写。 遇到的问题我把它定义为Flask和Vue在使用JWT过程中的跨域问题。因为使用了flask_cros中间件，其他的方法都是不存在跨域问题的，单单在前端携带token发送请求时报了错。如图：后端控制台显示丢失head信息。但postman测试，如果’Authorization’字段为’Bearer ‘ + token,则可以请求成功。于是把前端的request拦截器中携带token发送请求时也加上’Bearer ‘的头部信息，则成功解决。查阅资料：在token前面加上Bearer是一种规范， W3C 的 HTTP 1.0 规范，Authorization 的格式是： Authorization: &lt;type&gt; &lt;authorization-parameters&gt;Bearer 常见于 OAuth 和 JWT 授权。 明天目标 用户注册 用户首页设计 系统整体功能模块设计","tags":[{"name":"flask,vue,mysql","slug":"flask-vue-mysql","permalink":"http://example.com/tags/flask-vue-mysql/"}]},{"title":"About ChatGPT","date":"2023-02-22T01:29:19.000Z","path":"2023/02/22/About-ChatGPT/","text":"ChatGPT背后的工作原理原文链接 介绍 ChatGPT是OpenAI发布的最新语言模型，能以不同样式、不同目的生成文本，并且在准确度、叙述细节和上下文连贯性上具有更优的表现。 OpenAI使用监督学习和强化学习的组合来调优ChatGPT，其中的强化学习组件使ChatGPT独一无二。OpenAI使用了「人类反馈强化学习」（RLHF）的训练方法，该方法在训练中使用人类反馈，以最小化无益、失真或偏见的输出。 GPT-3非一致模型，基于来自互联网的大量文本数据进行训练，能够生成类似人类的文本，但它们可能并不总是产生符合人类期望的输出。它们的目标函数是词序列上的概率分布，用来预测序列中的下一个单词是什么。一致性问题表现为: 提供无效帮助：没有遵循用户的明确指示。 内容胡编乱造：虚构不存在或错误事实的模型。 缺乏可解释性：人们很难理解模型是如何得出特定决策或预测的。 内容偏见有害：一个基于有偏见、有害数据训练的语言模型可能会在其输出中出现这种情况，即使它没有明确指示这样做。 语言模型训练策略 Next-token-prediction masked-language-modeling一般来说，这些训练策略可能会导致语言模型在一些更复杂的任务中出现不一致，因为一个仅被训练来预测文本序列中的下一个词的模型可能不一定会学习其含义的某些更高级表征。因此，该模型很难推广到需要对语言更深入理解的任务。 RLHFChatGPT 基于最初的 GPT-3 模型，但为了解决模型的不一致问题，使用了人类反馈来指导学习过程，对其进行了进一步训练。方法总体上包括三个不同步骤： 有监督的调优：预训练的语言模型在少量已标注的数据上进行调优，以学习从给定的 prompt 列表生成输出的有监督的策略（即 SFT 模型）； 模拟人类偏好：标注者们对相对大量的 SFT 模型输出进行投票，这就创建了一个由比较数据组成的新数据集。在此数据集上训练新模型，被称为训练回报模型（Reward Model，RM）； 近端策略优化（PPO）：RM 模型用于进一步调优和改进 SFT 模型，PPO 输出结果是策略模式。步骤 1 只进行一次，而步骤 2 和步骤 3 可以持续重复进行：在当前最佳策略模型上收集更多的比较数据，用于训练新的 RM 模型，然后训练新的策略。 监督调优模型 数据收集：选择一个提示列表，标注人员按要求写下预期的输出。对于 ChatGPT，使用了两种不同的 prompt 来源：一些是直接使用标注人员或研究人员准备的，另一些是从 OpenAI 的 API 请求（即从 GPT-3 用户那里）获取的。虽然整个过程缓慢且昂贵，但最终得到的结果是一个相对较小、高质量的数据集（大概有 12-15k 个数据点），可用于调优预训练的语言模型。 模型选择：GPT-3.5 系列中的预训练模型，text-davinci-003这里的问题是监督学习步骤具有高可扩展性成本。为了克服这个问题，使用的策略是让人工标注者对 SFT 模型的不同输出进行排序以创建 RM 模型，而不是让人工标注者创建一个更大的精选数据集。 训练回报模型这一步的目标是直接从数据中学习目标函数。该函数的目的是为 SFT 模型输出进行打分，这代表这些输出对于人类来说可取程度有多大。这强有力地反映了选定的人类标注者的具体偏好以及他们同意遵循的共同准则。最后，这个过程将从数据中得到模仿人类偏好的系统。 选择 prompt 列表，SFT 模型为每个 prompt 生成多个输出（4 到 9 之间的任意值）； 标注者将输出从最佳到最差排序。结果是一个新的标签数据集，该数据集的大小大约是用于 SFT 模型的精确数据集的 10 倍； 此新数据用于训练 RM 模型 。该模型将 SFT 模型输出作为输入，并按优先顺序对它们进行排序。对于标注者来说，对输出进行排序比从头开始打标要容易得多，这一过程可以更有效地扩展。 PPO模型微调SFT模型强化学习被应用于通过优化 RM 模型来调优 SFT 模型。近端策略优化（PPO），近端策略优化模型。 PPO 可以根据所采取行动的估计价值对策略进行更明智的更新。PPO 模型由 SFT 模型初始化，价值函数由 RM 模型初始化。该环境是一个「bandit environment」，它会产生随机 prompt 并期望对 prompt 做出响应。对于给定的 prompt 和响应，它会产生相应的回报（由 RM 模型决定）。SFT 模型会对每个 token 添加 KL 惩罚因子，以尽量避免 RM 模型的过度优化。 局限性 会受到各种错综复杂的主观因素的影响 缺乏对照研究 相关论文 Training language models to follow instructions with human feedback（https://arxiv.org/pdf/2203.02155.pdf） InstructionGPT Learning to summarize from Human Feedback （https://arxiv.org/pdf/2009.01325.pdf） RLHF PPO（https://arxiv.org/pdf/1707.06347.pdf） PPO Deep reinforcement learning from human preferences （https://arxiv.org/abs/1706.03741）","tags":[{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://example.com/tags/ChatGPT/"}]},{"title":"Is ChatGPT A Good Translator?","date":"2023-02-21T08:13:49.000Z","path":"2023/02/21/Is-ChatGPT-A-Good-Translator/","text":"Is ChatGPT A Good Translator? A Preliminary Study摘要 提供了ChatGPT对机器翻译的初步评估，包括翻译提示性、多语言翻译和翻译的鲁棒性。我们采用ChatGPT建议的提示来触发其翻译能力，并发现候选提示通常效果很好，并表现出微小的性能差异。 ChatGPT在高资源的欧洲语言上与商业翻译产品（例如谷歌翻译）具有竞争能力，但在低资源或遥远的语言上明显落后。 For distant languages, we explore an interesting strategynamed pivot prompting that asks ChatGPT to translate the source sentence into a high-resource pivot language before into the target language, which improves the translation performance significantly. 至于翻译的健壮性，ChatGPT在生物医学摘要或Reddit注释上的性能不如商业系统，但它可能是一个很好的口语翻译器。 动机 We are particularly interested in how ChatGPT performs for machine translation tasks, especially the gap between ChatGPT and commercial translation products. Translation Prompt 翻译提示 Multilingual Translation 多语种翻译 Translation Robustness 翻译的鲁棒性 实验和结果Translation PromptTo design the prompts for triggering the machine translation ability of ChatGPT, we seek inspiration from ChatGPT by asking it for advice.Thus, we summarize them into three candidate prompts,where[SRC] and [TGT] represent the source and target languages of translation.TP3 performs the best in terms of all the three metrics. Thus, we use TP3 throughout this report by default. Multilingual Translation Specifically, we ask ChatGPT to translate the source sentence into a high-resource pivot language (i.e., English by default) first and then into the target language. Translation Robustness 总结与启发可以在对chatGPT解决某一任务做实验的过程中发现chatGPT的缺点，并提出一定的解决方案，作出改进，比如本文中的pivot策略。","tags":[{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://example.com/tags/ChatGPT/"}]},{"title":"An Analysis of the Automatic Bug Fixing Performance of ChatGPT","date":"2023-02-21T06:37:25.000Z","path":"2023/02/21/An-Analysis-of-the-Automatic-Bug-Fixing-Performance-of-ChatGPT/","text":"An Analysis of the Automatic Bug Fixing Performance of ChatGPT（ChatGPT在Bug自动修复的性能分析）摘要 evaluate ChatGPT on the standard bug fixing benchmark set, QuixBugs, and compare the performance with the results of several other approaches reported in the literature.在标准bug修复基准集Quixbug上评估ChatGPT，并将其性能与文献中报道的其他几种方法的结果进行比较。 ChatGPT’s bug fixing performance is competitive to the common deep learning approaches CoCoNut and Codex and notably better than the results reported for the standard program repair approaches.ChatGPT的bug修复性能与常见的深度学习方法CoCoNut和Codex相比具有竞争力，并且明显优于标准程序修复方法报告的结果。 ChatGPT offers a dialogue system through which further information, e.g., the expected output for a certain input or an observed error message, can be entered. By providing such hints to ChatGPT, its success rate can be further increasedChatGPT提供了一个对话系统，通过该系统可以输入进一步的信息，例如，某个输入的预期输出或观察到的错误信息。通过向ChatGPT提供这些提示，可以进一步提高其成功率。 动机 The bug fixing performance of ChatGPT is so far unclear. 方法 first ask ChatGPT for bug fixes for the selected benchmarks and manually check whether the suggested solution is correct or not.首先询问ChatGPT对所选基准测试的bug修复，并手动检查建议的解决方案是否正确。 study and categorize ChatGPT’s answers to gain a deeper understanding of its behavior.研究和分类ChatGPT的答案，以获得更深入地了解它的行为。 provide a small hint to the model (e.g., a failing test input with an error it produces) to see if it improves ChatGPT’s fix rate.为模型提供了一个小提示（例如，一个失败的测试输入并产生一个错误），看看它是否提高了ChatGPT的修复率。 对于QuixBugs中的40个基准测试问题中的每一个，使用错误的Python代码，删除所有包含的注释，并询问ChatGPT代码是否包含bug以及如何修复它。对于每个基准测试问题，向ChatGPT发出几个独立的请求，并手动检查给定的答案是否正确。通过对每个查询使用相同的格式来标准化我们的过程。 expect from ChatGPT an answer that addresses the bug in line 7, where n ˆ&#x3D; n - 1 should be replaced with n &amp;&#x3D; n - 1, either with a response containing the complete code snippet with the fixed bug (correctly addressed) or bygiving an exact and correct description how to change the affected code lines. 结果对比结果a checkmark (✓) indicates that a correct answer was given in at least one of the four runs for a benchmark problem. A cross (✗) indicates that no correct answer was given in any of the runs. for some problems, ChatGPT suggests a complete re-implementation which is then bug-free. these are probably no real bug fixes, since the introduced bug is not localized. We assume that ChatGPT simply reproduced what it has learned here. Furthermore, we do not count a bug as fixed if additional changes suggested by ChatGPT introduce new errors that prevent the program from running properly. 对回答分类 与其对话give ChatGPT an exact input example and the resulting error message from Python (lines 17–19) human input can be of much help to an automated APR system, with ChatGPT providing means to do so. 启发 将chatGPT在某一基准数据集下的推荐性能与其他模型进行比较，分析推荐任务方面的性能 突出其对话的特性，使其在后续follow-up中性能有所提高，如本文与其他模型相比而言平平无奇，但加入和系统对话，为chatgpt提供更多信息或提示后，优越性立马体现出来。","tags":[{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://example.com/tags/ChatGPT/"}]}]